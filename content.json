{"meta":{"title":"GYNote","subtitle":null,"description":null,"author":"Gu Yong","url":"https://guyong.xyz"},"pages":[{"title":"Categories","date":"2018-07-27T12:53:55.000Z","updated":"2018-07-27T11:58:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://guyong.xyz/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-07-27T12:53:55.000Z","updated":"2018-07-27T11:58:34.000Z","comments":true,"path":"tags/index.html","permalink":"https://guyong.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Notes for Learning Python 5th","slug":"python/notes for learning python","date":"2018-09-04T16:12:39.000Z","updated":"2018-09-04T16:12:39.000Z","comments":true,"path":"python/notes for learning python.html","link":"","permalink":"https://guyong.xyz/python/notes for learning python.html","excerpt":"* Types and Operations * Core Types * Numbers * String * Lists and Dictionaries * Tuples, files and everything else * Statements and Syntax * Assignments, Expressions, and Prints * if Tests and Syntax Rules * while and for Loops * Iterations and Comprehensions","text":"Types and OperationsCore TypesNumbersStringLists and DictionariesTuples, files and everything elseStatements and SyntaxAssignments, Expressions, and Printsif Tests and Syntax Ruleswhile and for LoopsIterations and ComprehensionsDocumentation InterludeFunctions and GeneratorsFunction BasicsScopesArgumentsAdvanced Function TopicsComprehensions and GenerationsThe benchmarking InterludePart V. Modules and PackagesModule Coding BasicsModule Packages Types and Operations Objects are pieces of memory, with values and sets of associated operations. Everything we process in Python programs is a kind of obj The Python Conceptual Hierarchy: Programs are composed of modules. Modules contain statements. Statements contain expressions. Expressions create and process objects. In formal terms, this means that Python is dynamically typed , a model that keeps track of types for you automatically instead of requiring declaration code, but it is also strongly typed, a constraint that means you can perform on an object only operations that are valid for its type. Core Types Immutable: number, string, tuple, bytes Mutable: list, dictionary, set, bytearray Primitive: number Collection: Sequence: string, tuple, bytes, list, bytearray Mapping: dictionary, set bytearray is a distinct hybrid of immutable bytes strings (whose b’…’ syntax is required in 3.X and optional in 2.X) and mutable lists (coded and displayed in [] ). generic operations that span multiple types show up as built-in functions or expressions (e.g. len(X) , X[0] ), but type-specific operations are method calls (e.g., aString.upper() ). Both dir and help also accept as arguments either a real object (like our string S) , or the name of a data type (like str , list , and dict ). As a notable difference, Python 2.X allows its normal and Unicode strings to be mixed in expressions as long as the normal string is all ASCII; in contrast, Python 3.X has a tighter model that never allows its normal and byte strings to mix without explicit conversion. None of the string object’s own methods support pattern-based text processing. Unlike out-of-bounds assignments in lists, which are forbidden, assignments to new dictionary keys create those keys, fetching a nonexistent key is still a mistake. (Use the get() method) A file’s contents are always a string in your script, regardless of the type of data the file contains: 1&gt;&gt;&gt; for line in open('data.txt'): print(line) Text files represent content as normal str strings and perform Unicode encoding and decoding automatically when writing and reading data, while binary files represent content as a special bytes string and allow you to access file content unaltered. Sets are unordered collections of unique and immutable objects. Decimal, Fraction, booleans As you’ll learn, in Python, we code to object interfaces (operations supported), not to types. Numbers Floating-point numbers are implemented as C “doubles” in standard CPython, and therefore get as much precision as the C compiler used to build the Python interpreter gives to doubles. built-in calls: hex(I), oct(I), bin(I), int(str,base), X.bit_length(),round(X), X.as_integer_ratio() Internally, complex numbers are implemented as pairs of floating-point numbers Comparison operators may be chained: X &lt; Y &lt; Z produces the same result as X &lt; Y and Y &lt; Z . 12&gt;&gt;&gt; 1 == 2 &lt; 3 # Same as: 1 == 2 and 2 &lt; 3False # Not same as: False &lt; 3 (which means 0 &lt; 3, which is true!) In recent Pythons, the slice expression X[I:J:K] is equivalent to indexing with a slice object: X[slice(I, J, K)]. In Python 3.X, nonnumeric mixed-type magnitude comparisons are not allowed and raise exceptions; this includes sorts by proxy. Operators lower in the table have higher precedence, and so bind more tightly in mixed expressions. Operators in the same row in Table 5-2 generally group from left to right when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right). Besides mixing operators in expressions, you can also mix numeric types: in mixed-type numeric expressions, Python first converts operands up to the type of the most complicated operand, and then performs the math on same-type operands. Python ranks the complexity of numeric types like so: integers are simpler than floating point numbers, which are simpler than complex numbers. In general, Python does not convert across any other type boundaries automatically. Adding a string to an integer, for example, results in an error, unless you manually convert one or the other. In 3.X, the / now always performs true division, returning a float result that includes any remainder, regardless of operand types. The // performs floor division, which truncates the remainder and returns an integer for integer operands or a float if any operand is a float. The // operator truncates the result down to its floor, which means the closest whole number below the true result. Frozenset Internally, the names True and False are instances of bool , which is in turn just a subclass (in the object oriented sense) of the built-in integer type int . True and False behave exactly like the integers 1 and 0, except that they have customized printing logic. 12&gt;&gt;&gt; True + 4 # (Hmmm)5 Numpy, Scipy The dynamic typing A variable never has any type information or constraints associated with it. The notion of type lives with objects, not names. Variables are generic in nature; they always simply refer to a particular object at a particular point in time. Variables always link to objects and never to other variables, but larger objects may link to other objects (for instance, a list object has links to the objects it contains). These links from variables to objects are called references in Python—that is, a reference is a kind of association, implemented as a pointer in memory Technically speaking, objects have more structure than just enough space to represent their values. Each object also has two standard header fields: a type designator used to mark the type of the object, and a reference counter used to determine when it’s OK to reclaim the object. reference counter, cyclic reference sys.getrefcount(X) If a[:], a[k] appears in expression, they are copied. e.g. after b=a[:3], b refers to a new object. If a[:], a[k] appears in left side of assignment, they referred to the original object. e.g. after a=[0,1,2] a[:] = [0,1], a becomes [0,1] Because everything seems to work by assignment and references in Python, a basic understanding of this model is useful in many different contexts. As you’ll see, it works the same in assignment statements, function arguments, for loop variables, module imports, class attributes, and more. The good news is that there is just one assignment model in Python; weakref String String literal forms: Single quotes: ‘spa&quot;m’ Double quotes: “spa’m” Triple quotes: ‘’’… spam …’’’ , “”&quot;… spam …&quot;&quot;&quot; Escape sequences: “s\\tp\\na\\0m” Raw strings: r&quot;C:\\new\\test.spm&quot; Bytes literals in 3.X and 2.6+ (see Chapter 4 , Chapter 37 ): b’sp\\x01am’ Unicode literals in 2.X and 3.3+ (see Chapter 4 , Chapter 37 ): u’eggs\\u0020spam’ In fact, 3.X defines str strings formally as sequences of Unicode code points, not bytes, to make this clear. There’s more on how strings are stored internally in Chapter 37 if you care to know. Some escape sequences allow you to embed absolute binary values into the characters of a string. Python keeps both the string’s length and text in memory. In fact, no character terminates a string in Python Notice that Python displays nonprintable characters in hex, regardless of how they were specified. That is, r&quot;…&quot; is not a valid string literal—a raw string cannot end in an odd number of backslashes. If you need to end a raw string with a single backslash, you can use two and slice off the second (r’1\\nb\\tc\\’[:-1]), tack one on manually (r’1\\nb\\tc’ + ‘\\’), or skip the raw string syntax and just double up the backslashes in a normal string (‘1\\nb\\tc\\’). 1234567891011&gt;&gt;&gt; menu = &quot;&quot;&quot;spam # comments here added to string!... eggs # ditto... &quot;&quot;&quot;&gt;&gt;&gt; menu&apos;spam # comments here added to string!\\neggs # ditto\\n&apos;&gt;&gt;&gt; menu = (... &quot;spam\\n&quot; # comments here ignored... &quot;eggs\\n&quot; # but newlines not automatic... )&gt;&gt;&gt; menu&apos;spam\\neggs\\n&apos; built-in tool: ord() chr() The method call expression: object.method(arguments) is evaluated from left to right—Python will first fetch the method of the object and then call it, passing in both object and the arguments string formatting expressions and string formatting method calls Technically, the format built-in runs the subject object’s __format__ method, which the str.format method does internally for each formatted item. The % expressions tend to be a bit simpler and more concise; the format method has a handful of advanced features that the % expression does not, but even more involved formatting still seems to be essentially a draw in terms of complexity. 1&gt;&gt;&gt; from formats import commas, money Types Share Operation Sets by Categories: numbers sequences mappings Lists and Dictionaries Slice assignment, the last operation in the preceding example, replaces an entire section of a list in a single step. Because it can be a bit complex, it is perhaps best thought of as a combination of two steps: Deletion. The slice you specify to the left of the = is deleted. Insertion. The new items contained in the iterable object to the right of the = are inserted into the list on the left, at the place where the old slice was deleted. Note, L[2:5]=L[3:6], for instance, works fine because the value to be inserted is fetched before the deletion happens on the left. 12345678910&gt;&gt;&gt; L = [1]&gt;&gt;&gt; L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front&gt;&gt;&gt; L[2, 3, 4, 1]&gt;&gt;&gt; L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end&gt;&gt;&gt; L[2, 3, 4, 1, 5, 6, 7]&gt;&gt;&gt; L.extend([8, 9, 10]) # Insert all at end, named method&gt;&gt;&gt; L[2, 3, 4, 1, 5, 6, 7, 8, 9, 10] The effect of L.append(X) is similar to L+[X], but while the former changes L in place, the latter makes a new list. In Python 3.X, this has changed: magnitude comparison of mixed types raises an exception instead of falling back on the fixed cross-type ordering. L.sort() vs. sorted built-in tools: reversed Like lists, dictionaries store object references (not copies, unless you ask for them explicitly) keys in 3.X returns an iterable object, instead of a physical list Unlike lists, however, whenever you assign a new dictionary key (one that hasn’t been assigned before) you create a new entry in the dictionary. In 3.X the dictionary keys , values , and items methods all return view objects , whereas in 2.X they return actual result lists. Besides being iterable, dictionary views also retain the original order of dictionary components, reflect future changes to the dictionary, and may support set operations. Unlike 2.X’s list results, though, dictionary views in 3.X are not carved in stone when created—they dynamically reflect future changes made to the dictionary after the view object has been created: In set operations, views may be mixed with other views, sets, and dictionaries; dictionaries are treated the same as their keys views in this context: 123456&gt;&gt;&gt; D = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; D.keys() &amp; D.keys() # Intersect keys views&#123;&apos;b&apos;, &apos;c&apos;, &apos;a&apos;&#125;&gt;&gt;&gt; D.keys() &amp; &#123;&apos;b&apos;&#125; # Intersect keys and set&#123;&apos;b&apos;&#125;&gt;&gt;&gt; D. 12&gt;&gt;&gt; Ks.sort()AttributeError: &apos;dict_keys&apos; object has no attribute &apos;sort&apos; To work around this, in 3.X you must either convert to a list manually or use the sorted call (introduced in Chapter 4 and covered in this chapter) on either a keys view or the dictionary itself: OrderedDict Tuples, files and everything else As you can see, named tuples are a tuple/class/dictionary hybrid (In short, named tuples build new classes that extend the tuple type, inserting a property accessor method for each named field that maps the name to its position) Empty lines in the file come back as strings containing just a newline character, not as empty strings. 12&gt;&gt;&gt; myfile.readline() # Empty string: end-of-file&apos;&apos; Text files represent content as normal str strings, perform Unicode encoding and decoding automatically, and perform end-of-line translation by default. Binary files represent content as a special bytes string type and allow programs to access file content unaltered. pickle, shelve, json, struct In fact, when nested objects are present, Python automatically traverses data structures to apply comparisons from left to right, and as deeply as needed. More specifically, Python compares types as follows: Numbers are compared by relative magnitude, after conversion to the common highest type if needed. Strings are compared lexicographically (by the character set code point values returned by ord ), and character by character until the end or first mismatch (“abc”&lt; “ac” ). Lists and tuples are compared by comparing each component from left to right, and recursively for nested structures, until the end or first mismatch ([2] &gt; [1, 2] ). Sets are equal if both contain the same items (formally, if each is a subset of the other), and set relative magnitude comparisons apply subset and superset tests. Dictionaries compare as equal if their sorted (key, value) lists are equal. Relative magnitude comparisons are not supported for dictionaries in Python 3.X, but they work in 2.X as though comparing sorted (key, value) lists. Nonnumeric mixed-type magnitude comparisons (e.g., 1 &lt; ‘spam’ ) are errors in Python 3.X. They are allowed in Python 2.X, but use a fixed but arbitrary ordering rule based on type name string. By proxy, this also applies to sorts, which use comparisons internally: nonnumeric mixed-type collections cannot be sorted in 3.X. Python 3.X disallows mixed-type magnitude testing, except numeric types. More generally, the notions of true and false are intrinsic properties of every object in Python—each object is either true or false, as follows: Numbers are false if zero, and true otherwise. Other objects are false if empty, and true otherwise. That is, None is something, not nothing (despite its name!)—it is a real object and a real piece of memory that is created and given a built-in name by Python itself. In fact, even types themselves are an object type in Python. Calls to these names are really object constructor calls, not simply conversion functions, though you can treat them as simple functions for basic usage. For classic classes in Python 2.X, all class instances are instead of the type “instance,” and we must compare instance __class__ attributes to compare their types meaningfully. Repetition Adds One Level Deep 123&gt;&gt;&gt; L = [4, 5, 6]&gt;&gt;&gt; X = L * 4 # Like [4, 5, 6] + [4, 5, 6] + ...&gt;&gt;&gt; Y = [L] * 4 # [L] + [L] + ... = [L, L,...] If you remember that repetition, concatenation, and slicing copy only the top level of their operand objects, these sorts of cases make much more sense Beware of Cyclic Data Structure 1234&gt;&gt;&gt; L = ['grail'] # Append reference to same object&gt;&gt;&gt; L.append(L) # Generates cycle in object: [...]&gt;&gt;&gt; L['grail', [...]] Statements and Syntax Assignments, Expressions, and Prints Assignments create object references. (i.e. link a name with an object) They always create references to objects instead of copying the objects. Names are created when first assigned. Names must be assigned before referenced. Module imports, function and class definitions, for loop variables, and function arguments are all implicit assignments. sequence assignment—any sequence of names can be assigned to any sequence of values, and Python assigns the items one at a time by position. In fact, the original tuple and list assignment forms in Python have been generalized to accept any type of sequence (really, iterable) on the right as long as it is of the same length as the sequence on the left. Multiple-target assignment: Python assigns a reference to the same object (the object farthest to the right) to all the targets on the left. In tuple/list assignment, Python creates a temporary tuple that saves the original values of the variables on the right before assigning. we can even assign nested sequences, and Python unpacks their parts according to their shape, as expected. The sequence-nesting shape of the object on the left must match that of the object on the right. This nested tuple (really, sequence) unpacking assignment form works for function argument lists in Python 2.X (though not in 3.X) In short, a single starred name, *X, can be used in the assignment target in order to specify a more general matching against the sequence—the starred name is assigned a list, which collects all items in the sequence not assigned to other names. In fact, the starred name can appear anywhere in the target. This is similar in spirit to slicing, but not exactly the same—a sequence unpacking assignment always returns a list for multiple matched items, whereas slicing returns a sequence of the same type as the object sliced 12345&gt;&gt;&gt; a, *b = &apos;spam&apos;&gt;&gt;&gt; a, b(&apos;s&apos;, [&apos;p&apos;, &apos;a&apos;, &apos;m&apos;])&gt;&gt;&gt; S[0], S[1:] # Slices are type-specific, * assignment always returns a list(&apos;s&apos;, &apos;pam&apos;) Finally, errors can still be triggered if there is more than one starred name, if there are too few values and no star (as before), and if the starred name is not itself coded inside a sequence: 12&gt;&gt;&gt; *a = seqSyntaxError: starred assignment target must be in a list or tuple For augmented assignments, inplace operations may be applied for mutable objects as an optimization. 12345678910&gt;&gt;&gt; L = [1, 2]&gt;&gt;&gt; L = L + [3] # Concatenate: slower&gt;&gt;&gt; L[1, 2, 3]&gt;&gt;&gt; L.append(4) # Faster, but in place&gt;&gt;&gt; L[1, 2, 3, 4]&gt;&gt;&gt; L += [9, 10] # Mapped to L.extend([9, 10])&gt;&gt;&gt; L[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Note however, that because of this equivalence += for a list is not exactly the same as a + and = in all cases—for lists += allows arbitrary sequences (just like extend), but concatenation normally does not: 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; L += &apos;spam&apos; # += and extend allow any sequence, but + does not!&gt;&gt;&gt; L[&apos;s&apos;, &apos;p&apos;, &apos;a&apos;, &apos;m&apos;]&gt;&gt;&gt; L = L + &apos;spam&apos;TypeError: can only concatenate list (not &quot;str&quot;) to list Although Python now supports statements like X += Y, it still does not have C’s auto-increment/decrement operators (e.g., X++, −−X). Naming For portability, case also matters in the names of imported module files, even on platforms where the filesystems are case-insensitive. True, False, and None, are somewhat unusual in meaning—they also appear in the built-in scope of Python described in Chapter 17, and they are technically names assigned to objects. Names that begin with a single underscore (_X) are not imported by a from module import * statement Names that begin with two underscores and do not end with two more (__X) are localized (“mangled”) to enclosing classes. Expression Statements In Python, you can use an expression as a statement, too. Expressions are commonly used as statements in two situations: For calls to functions and methods For printing values at the interactive prompt A statement that is not an expression must generally appear on a line all by itself, not nested in a larger syntactic structure. For example, Python doesn’t allow you to embed assignment statements (=) in other expressions. Besides, C assignments return the value assigned, but Python assignments are just statements, not expressions. Expression statements are often used to run list methods that change a list in place: 123&gt;&gt;&gt; L = L.append(4) # But append returns None, not L&gt;&gt;&gt; print(L) # So we lose our list!None Normally, whether printed output is buffered in memory or not is determined by file; passing a true value to flush forcibly flushes the stream. Because the print statement just sends text to the sys.stdout.write method, you can capture printed text in your programs by assigning sys.stdout to an object whose write method processes the text in arbitrary ways if Tests and Syntax Rules There is no switch or case statement in Python Block and statement boundaries are detected automatically. Compound statements = header + “:” + indented statements. Blank lines, spaces, and comments are usually ignored. Docstrings are ignored but are saved and displayed by tools. Statements may span multiple lines if you’re continuing an open syntactic pair. Boolean operators stop evaluating (“short circuit”) as soon as a result is known. Boolean and and or operators return a true or false object in Python, not the values True or False For A = Y if X else Z, Python runs expression Y only if X turns out to be true, and runs expression Z only if X turns out to be false. When defining classes, we can specify their Boolean nature with either the bool or len methods. while and for Loops The optional else block run if didn’t exit loop with break Python doesn’t have what some languages call a “do until” loop statement. Python has no “go to” statement. Python 3.X (but not 2.X) allows ellipses coded as … (literally, three consecutive dots) to appear any place an expression can. Because ellipses do nothing by themselves, this can serve as an alternative to the pass statement, 123&gt;&gt;&gt; X = ... # Alternative to None&gt;&gt;&gt; XEllipsis After the for loop, this loop variable normally still refers to the last item visited, which is the last item in the sequence unless the loop exits with a break statement. Even nested structures may be automatically unpacked this way in a for: 1&gt;&gt;&gt; for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c) In fact, as a general rule, you should resist the temptation to count things in Python—its iteration tools automate much of the work you do to loop over collections in lower-level languages like C. built-in tools: range, zip, enumerate The zip function is more general than this example suggests. For instance, it accepts any type of sequence (really, any iterable object, including files), and it accepts more than two arguments. Moreover, zip truncates result tuples at the length of the shortest sequence when the argument lengths differ. Iterations and Comprehensions Iterator vs. Iterable vs. Iteration tool/context Single scan vs. multiple scan In some cases these two objects are the same when only a single scan is supported (e.g., files), and the iterator object is often temporary, used internally by the iteration tool. Moreover, some objects are both an iteration context tool (they iterate) and an iterable object (their results are iterable)—including Chapter 20’s generator expressions, and map and zip in Python 3.X. When the for loop begins, it first obtains an iterator from the iterable object by passing it to the iter built-in function; the object returned by iter in turn has the required next method. The iter function internally runs the iter method, much like next and __next__. For comprehensions, their full syntax allows for any number of for clauses, each of which can have an optional associated if clause. Keep in mind, though, that every built-in tool that scans from left to right across objects uses the iteration protocol. Notice that, unlike map and others, sorted returns an actual list in Python 3.X instead of an iterable. One of the fundamental distinctions of Python 3.X is its stronger emphasis on iterators than 2.X. This, along with its Unicode model and mandated new-style classes, is one of 3.X’s most sweeping changes. Unlike range, map, zip, filter are their own iterators—after you step through their results once, they are exhausted. In Python 3.X the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time. Documentation Interlude The PyDoc system covered here can render a module’s internal documentation as either plain text in a shell, or HTML in a web browser. The help function: press the space bar to move to the next page, Enter to go to the next line, and Q to quit: Sphinx Functions and Generators Function Basics def is executable code. it’s legal (and even occasionally useful) to nest def statements inside if statements, while loops, and even other defs. def creates an object and assigns it to a name. Function objects may also have arbitrary user-defined attributes attached to them to record data. Names are always looked up in scopes—places where variables are stored— and assignments bind names to scopes. Files must generally be rewound (e.g., with a file.seek(0) or another open) after they have been read to end-of-file once, and so are single-pass iterators Scopes When we talk about the search for a name’s value in relation to code, the term scope refers to a namespace: that is, the location of a name’s assignment in your source code determines the scope of the name’s visibility to your code. By default, all names assigned inside a function are associated with that function’s namespace, and no other. Lexical scoping: If a variable is assigned inside a def, it is local to that function. If a variable is assigned in an enclosing def, it is nonlocal to nested functions. If a variable is assigned outside all defs, it is global to the entire file. Each module is a global scope, the global scope spans a single file only. Assigned names are local unless declared global or nonlocal All other names are enclosing function locals, globals, or built-ins. Each call to a function creates a new local scope. Note L=X within a function will classify L as a local, but L.append(X) will not. Name Resolution: The LEGB Rule Name assignments create or change local names by default. Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in. Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively. Note that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup level. Also keep in mind that these rules apply only to simple variable names (e.g., spam). Qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here. There are technically three more scopes in Python—temporary loop variables in some comprehensions, exception reference variables in some try handlers, and local scopes in class statements In 3.X, the loop variables are local to the expression itself in all comprehension forms: generator, list, set, and dictionary. In 2.X, they are local to generator expressions and set and dictionary compressions, but not to list comprehensions that map their names to the scope outside the expression. By contrast, for loop statements never localize their variables to the statement block in any Python. In 3.X, exception reference variables are local to that except block, and in fact are removed when the block is exited (even if you’ve used it earlier in your code!). Although the LEGB rule is used to resolve names used in both the top level of a class itself as well as the top level of method functions nested within it, classes themselves are skipped by scope lookups—their names must be fetched as object attributes. The global/nonlocal Statement The global statement consists of the keyword global, followed by one or more names separated by commas. All the listed names will be mapped to the enclosing module’s scope when assigned or referenced within the function body. 1global x The name x do not need even exist in the enclosing module before the function runs; in this case, the first assignment in the function creates x in the module. If, on the other hand, X is declared nonlocal within the function in 3.X (only), the assignment changes the name X in the closest enclosing function’s local scope. The name X must have been defined in at least one enclosing function. 123456def f1():x = 88def f2(x=x): # Remember enclosing scope X with defaultsprint(x)f2()f1() # Prints 88 Because the second x is evaluated before Python steps into the nested def, it still refers to the x in f1. 1234def func():x = 4action = (lambda n, x=x: x ** n) # Pass x in manuallyreturn action Loop variables may require defaults, not scopes, Compare 12345&gt;&gt;&gt; def makeActions():acts = []for i in range(5): # Tries to remember each iacts.append(lambda x: i ** x) # But all remember same last i!return acts with 12345&gt;&gt;&gt; def makeActions():acts = []for i in range(5): # Use defaults insteadacts.append(lambda x, i=i: i ** x) # Remember current ireturn acts Because defaults are implemented as single objects attached to functions, mutable defaults retain state from call to call, rather than being initialized anew on each call. Unlike global, nonlocal names must already exist in the enclosing function’s scope when declared. In fact, they are checked at function definition time before either an enclosing or nested function is called. Nonlocal both allows assignment to names in enclosing function scopes and limits scope lookups for such names to enclosing defs. Python uses naming conventions in both 2.X and 3.X that ensure that the arbitrary names you assign as function attributes won’t clash with names related to internal implementation. To summarize: globals, nonlocals, classes, and function attributes all offer changeable state-retention options. Arguments In Python 2.X, it’s also possible to automatically unpack tuples in arguments passed to a function. 1def f((a,(b,c))) This def syntax is no longer supported in Python 3.X. Instead, code this function as: 1def f(T): (a, (b, c)) = T Tuple unpacking argument syntax is also disallowed by 3.X in lambda function argument lists. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.X for loops targets By default, arguments are matched by position, from left to right, and you must pass exactly as many arguments as there are argument names in the function header. In a function call, arguments must appear in this order: any positional arguments or the *iterable form, followed by any keyword arguments or the **dict form. If we see *iterable and **dict as being unpacked to positional arguments and keyword arguments, the order becomes: any positional arguments, followed by any keyword arguments. In a broad sense, there are only two arguments: positional and keyword. 123456def foo(a,b,c,d,e,f,g): print(&apos;ok&apos;)b=[2]x = &#123;&apos;d&apos;:4,&apos;e&apos;:5&#125;y = &#123;&apos;f&apos;:6&#125;foo(1,*b,3,**x,g=7,**y) //ok In a function header, we use the term “parameter” instead of “argument” In a function header, parameters must appear in this order: any normal parameter(name); followed by any default parameters (name=value); followed by the *name (or * in 3.X) form; followed by any name or name=value keyword-only arguments (in 3.X); followed by the **name form We can use a * character by itself in the arguments list to indicate that a function does not accept a variable-length argument list but still expects all arguments following the * to be passed as keywords. The name=value form has two meaning: before the form *name, it’s positional with default value after the form *name, it’s keyword-only with default value There can be at most one *name parameter, which collects all remaining positional arguments (including those in *iterabe). Similarly, There can be at most one **dict parameter, which collects all remaining keyword arguments (including those in **dict arguments). 12345def foo(a,b=3,*c,d,**e): print(b,e)x = [3,4]y = &#123;&apos;d&apos;:5,&apos;e&apos;:6,&apos;f&apos;:7&#125;foo(1,2,*x,**y) # 2 &#123;&apos;e&apos;: 6, &apos;f&apos;: 7&#125; The steps that Python internally carries out to match arguments before assignment can roughly be described as follows: Assign nonkeyword arguments by position. Assign keyword arguments by matching names. Assign extra nonkeyword arguments to *name tuple. Assign extra keyword arguments to **name dictionary. Assign default values to unassigned arguments in header. Note that in both function call and header, the name = value form are not assignments. The default parameters are attached to function objects, if you code a default to be a mutable object (e.g., def f(a=[])), the same, single mutable object is reused every time the function is later called—even if it is changed in place within the function. Below is a tracer function example: 123def tracer(func, *pargs, **kargs): # Accept arbitrary arguments print(&apos;calling:&apos;, func.__name__) return func(*pargs, **kargs) # Pass along arbitrary arguments Advanced Function Topics In fact, recursion is not used nearly as often in Python as in more esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural. On the other hand, recursion—or equivalent explicit stack-based algorithms we’ll meet shortly—can be required to traverse arbitrarily shaped structures. Also note that standard Python limits the depth of its runtime call stack—crucial to recursive call programs—to trap infinite recursion errors. To expand it, use the sys module: 1234&gt;&gt;&gt; sys.getrecursionlimit() # 1000 calls deep default1000&gt;&gt;&gt; sys.setrecursionlimit(10000) # Allow deeper nesting&gt;&gt;&gt; help(sys.setrecursionlimit) # Read more about it Function attributes and annotations 12&gt;&gt;&gt; func.__code__&gt;&gt;&gt; func.__code__.co_varnames Python’s own implementation-related data stored on functions follows naming conventions that prevent them from clashing with the more arbitrary attribute names you might assign yourself. In 3.X, all function internals’ names have leading and trailing double underscores (“__X__”); Attributes are related to objects instead of scopes (and must be referenced through the function name within its code). Python provides special syntax for specifying annotations, but it doesn’t do anything with them itself; annotations are completely optional, and when present are simply attached to the function object’s annotations attribute for use by other tools. Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values. 123456&gt;&gt;&gt; def func(a: &apos;spam&apos;, b: (1, 10), c: float) -&gt; int:return a + b + c&gt;&gt;&gt; func(1, 2, 3)6&gt;&gt;&gt; func.__annotations__&#123;&apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;b&apos;: (1, 10), &apos;a&apos;: &apos;spam&apos;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125; Finally, note that annotations work only in def statements, not lambda expressions. lambda is an expression, not a statement. lambda’s body is a single expression, not a block of statements. Defaults work on lambda arguments, just like in a def. The code in a lambda body also follows the same scope lookup rules as code inside a def. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule) 12&gt;&gt;&gt; ((lambda x: (lambda y: x + y))(99))(4)103 useful library: functools, operator Comprehensions and Generations map calls can be twice as fast as equivalent for loops, and list comprehensions are often faster than map calls. Generator function vs. Generator vs. Generator expression send advances to the next item yield is now an expression form, it must be enclose in parentheses unless it’s the only item on the right ride of the assignment statement. methods: throw, close yield from Generator expressions may also run slightly slower than list comprehensions in practice, so they are probably best used only for very large result sets, or applications that cannot wait for full results generation. A subtle but important point: both generator functions and generator expressions are their own iterators and thus support just one active iteration. Python 3.X localizes loop variables in all four forms—temporary loop variable names in generator, set, dictionary, and list comprehensions are local to the expression. In general, list comprehensions are usually the quickest of the bunch; map beats list comprehensions in Python only when all tools must call functions; for loops tend to be slower than comprehensions; and generator functions and expressions are slower than comprehensions by a constant factor. Under The benchmarking Interlude Timeing modules: time, timer, profile, timeit, pystone.py Part V. Modules and Packages Modules are processed with two statements and one important function: import: Lets a client (importer) fetch a module as a whole from: Allows clients to fetch particular names from a module imp.reload (reload in 2.X): Provides a way to reload a module’s code without stopping Python In Python, cross-file module linking is not resolved until such import statements are executed at runtime; their net effect is to assign module names—simple variables like b—to loaded module objects. In fact, the module name used in an import statement serves two purposes: it identifies the external file to be loaded, but it also becomes a variable assigned to the loaded module. Similarly, objects defined by a module are also created at runtime, as the import is executing: import literally runs statements in the target file one at a time to create its contents. In python, imports perform three distinct steps the first time a program imports a given file: Find the module’s file. Compile it to byte code (if needed). Run the module’s code to build the objects it defines. Bear in mind that all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named sys.mod ules and checking there at the start of an import operation. If the module is not present, a three-step process begins. (see imp.reload) Python keeps already imported modules in the built-in sys.modules dictionary so it can keep track of what’s been loaded. Notice that compilation happens when a file is being imported. Because of this, you will not usually see a .pyc byte code file for the top-level file of your program, unless it is also imported elsewhere—only imported files leave behind .pyc files on your machine. The Module Search Path Roughly, Python’s module search path is composed of the concatenation of these major components, some of which are preset for you and some of which you can tailor to tell Python where to look: The home directory of the program (subdirectories not included) PYTHONPATH directories (if set) Standard library directories The contents of any .pth files (if present) The site-packages home of third-party extensions Ultimately, the concatenation of these four components becomes sys.path, a mutable list of directory. The first and third elements of the search path are defined automatically. Because Python searches the concatenation of these components from first to last, though, the second and fourth elements can be used to extend the path to include your own source code directories. By modifying the sys.path list, you can modify the search path for all future imports made in a program’s run. Such changes last only for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path—the first per user, and the second per installation. Python automatically selects any type that matches a module’s name. For same names with different extensions, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations. By using import hooks, archived files are automatically extracted at import time when a .zip file is selected from the module import search path. For details, see the builtin importlib.__import__ function Third-party extensions for Python typically use the distutils tools in the standard library to automatically install themselves, so no path configuration is required to use their code. Systems that use distutils generally come with a setup.py script, which is run to install them; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\site-packages subdirectory of the Python install tree, wherever that resides on the target machine). Module Coding Basics Module Filenames The .py is technically optional for top-level files that will be run but not imported. In fact, both the names of module files and the names of directories used in package imports (discussed in the next chapter) must conform to the rules for variable names presented. import fetches the module as a whole, so you must qualify to fetch its names; in contrast, from fetches (or copies) specific names out of the module. In Python 3.X, the from …* statement form described here can be used only at the top level of a module file, not within a function. Just like def, import and from are executable statements, not compile-time declarations. They may be nested in if tests, to select among options; appear in function defs, to be loaded only on calls (subject to the preceding note); be used in try statements, to provide defaults; and so on. 123&gt;&gt;&gt; from small import x, y # Copy two names out&gt;&gt;&gt; x = 42 # Changes local x only&gt;&gt;&gt; y[0] = 42 # Changes shared mutable in place At least conceptually, a from statement like this one: 1from module import name1, name2 # Copy these two names out (only) is equivalent to this statement sequence: 1234import module # Fetch the module objectname1 = module.name1 # Copy names out by assignmentname2 = module.name2del module # Get rid of the module name The from always imports the entire module into memory if it has not yet been imported, regardless of how many names it copies out of the file. There is no way to load just part of a module file. Moreover, the from module import * form really can corrupt namespaces and make names difficult to understand, especially when applied to more than one file. Probably the best real-world advice here is to generally prefer import to from for simple modules, to explicitly list the variables you want in most from statements, and to limit the from * form to just one import per file. The as extension works in both import and from as a simple renaming tool. In fact, internally, module namespaces are stored as dictionary objects. The LEGB scope rule applies only to bare, unqualified names—it may be used for the leftmost name in a name path, but later names after dots search specific objects instead. lexical scoping notion—in Python, the scopes surrounding a piece of code are completely determined by the code’s physical position in your file. Scopes are never influenced by function calls or module imports. import operations never give upward visibility to code in imported files —an imported file cannot see names in the importing file. In some sense, although imports do not nest namespaces upward, they do nest downward. 1print(mod2.mod3.X) # Nested mod3&apos;s X Reloading Modules The reload function forces an already loaded module’s code to be reloaded and rerun. Assignments in the file’s new code change the existing module object in place. Note that reload currently only works on modules written in Python; Because reload expects an object, a module must have been previously imported successfully before you can reload it. When you call reload, Python rereads the module file’s source code and reruns its toplevel statements. Perhaps the most important thing to know about reload is that it changes a module object in place; it does not delete and re-create the module object. Reloads impact all clients that use import to fetch modules Reloads impact future from clients only. Clients that used from to fetch attributes in the past won’t be affected by a reload; they’ll still have references to the old objects fetched before the reload. Reloads apply to a single module only. You must run them on each module you wish to update, unless you use code or tools that apply reloads transitively. Module Packages","categories":[{"name":"python","slug":"python","permalink":"https://guyong.xyz/categories/python/"}],"tags":[]},{"title":"Site Building","slug":"site-building","date":"2018-09-04T04:53:04.000Z","updated":"2018-09-04T04:53:04.000Z","comments":true,"path":"site-building.html","link":"","permalink":"https://guyong.xyz/site-building.html","excerpt":"This site is build by hexo, with theme icarus and plugins: * hexo-directory-category * hexo-auto-excerpt * hexo-renderer-markdown-it (checkbox, footnote, anchor, toc, etc) Todo * Implement remote source folder (e.g. facilitate date info) * Improve UI: pagenation, page-nav, index, category ind","text":"This site is build by hexo, with theme icarus and plugins: hexo-directory-category hexo-auto-excerpt hexo-renderer-markdown-it (checkbox, footnote, anchor, toc, etc) Todo Implement remote source folder (e.g. facilitate date info) Improve UI: pagenation, page-nav, index, category index Improve sidebar Improve date info Steps Initialize &lt;root&gt; with hexo Installl theme icarus Replace with markdown-it 12npm un hexo-renderer-marked --savenpm i github:gynote/hexo-renderer-markdown-it --save Install other plugins 1npm i --save hexo-directory-category hexo-auto-excerpt Config hexo and theme Generate and deploy 123456#!/bin/shcd ~/Coding/github/gynote.github.io/rm -rf source/_posts/*cp -r ~/Works/SyncNotes/* source/_posts/hexo clean &amp;&amp; hexo gcp -r ~/Works/SyncNotes/.pastes public/","categories":[],"tags":[]},{"title":"notes for Fluent Python","slug":"python/notes for flunet python","date":"2018-09-03T16:13:37.000Z","updated":"2018-09-03T16:13:37.000Z","comments":true,"path":"python/notes for flunet python.html","link":"","permalink":"https://guyong.xyz/python/notes for flunet python.html","excerpt":"immutable: number, string, tuple, bytes mutable: list, dict, set, byte array sequence: list, string string vs. bytes vs. byte array In each iteration of for i in a:, i get a copy of the current element * modifying i doesn’t affect a, i.e. i is not a lvalue reference of a[] * usea[:] as a copy o","text":"immutable: number, string, tuple, bytes mutable: list, dict, set, byte array sequence: list, string string vs. bytes vs. byte array In each iteration of for i in a:, i get a copy of the current element modifying i doesn’t affect a, i.e. i is not a lvalue reference of a[] usea[:] as a copy of a if you need to modify the sequence default argument is evaluated only once at the point of function definition in the defining scope. set may contain duplicate elements while dict may not. Note that the current implementation only supports function attributes on user-defined functions. Function attributes on built-in functions may be supported in the future.","categories":[{"name":"python","slug":"python","permalink":"https://guyong.xyz/categories/python/"}],"tags":[]},{"title":"tools","slug":"Collection/tools","date":"2018-09-03T16:02:48.000Z","updated":"2018-09-03T16:02:48.000Z","comments":true,"path":"Collection/tools.html","link":"","permalink":"https://guyong.xyz/Collection/tools.html","excerpt":"Zotero Jetbrains VSCode Quiver Trello Hackmd sharelatex TexStudio Ipe ideone.com slant alternativeto.net github -> wiki/gist listary, everything, wox","text":"Zotero Jetbrains VSCode Quiver Trello Hackmd sharelatex TexStudio Ipe ideone.com slant alternativeto.net github -&gt; wiki/gist listary, everything, wox","categories":[{"name":"Collection","slug":"Collection","permalink":"https://guyong.xyz/categories/Collection/"}],"tags":[{"name":"original","slug":"original","permalink":"https://guyong.xyz/tags/original/"}]},{"title":"C Declaration","slug":"cpp/c declarations","date":"2018-09-01T14:07:56.000Z","updated":"2018-09-01T14:07:56.000Z","comments":true,"path":"cpp/c declarations.html","link":"","permalink":"https://guyong.xyz/cpp/c declarations.html","excerpt":"How to scramble a declaration In C, a type T can be one of the follows: 1. Base Type BT BT x; Base type BT ca be primitive types (int, double) and composite types (struct, union) 2. Array of type AT AT x[]; 3. Function returning type FT FT x() 4. Pointer to type PT PT *x; B","text":"How to scramble a declaration In C, a type T can be one of the follows: Base Type BT BT x; Base type BT ca be primitive types (int, double) and composite types (struct, union) Array of type AT AT x[]; Function returning type FT FT x() Pointer to type PT PT *x; Basic rules for legal declarations a function can’t return a function, so you’ll never see foo()() a function can’t return an array, so you’ll never see foo()[] an array can’t hold a function, so you’ll never see foo[]() It can be inferred that: AT can’t be FT FT can’t be AT, FT Precedence rule To unscramble a declaration, we also need the precedence rule: parentheses grouping together parts of a declaration the postfix operators: parentheses () indicating a function square brackets [] indicating an array the prefix operator: the asterisk denoting “pointing to” Now, it’s time to unscramble a declaration First, we should find the identifier x, the declaration is interpreted as “x is …”. x can be any kind: BT, AT, FT, PT By precedence rules, we should check first whether x is an array or function by looking to the right. (We still use x to denote the parts we have got) If it’s an array, we get an AT x[], which can be BT, AT, PT. So we should check whether x[] is an array again and again. When we can’t get an array, it can be BT, PT. Or if it’s a function, we get an FT x(), which can be BT,PT. Check whether x is a pointer by looking to the left. If it is, *x can be any kind. So go to step 2. The remaining part must be BT. Note that there can be grouping parentheses, as well as const and voatile. We ignore them above. Unscramble steps Go to the leftmost identifier, say “identifier is” Look at the next token to the right. If it is a square bracket, for each pair, say “array of”. Go to step 4 Or if it is an opening parenthesis, read up to the closing parenthesis, say “function returning” If the token to the left is an opening parenthesis, this is the opening parenthesis grouping together part of the declaration we have already dealt with. Read up to the balancing parenthesis, start again at step 2 If the token to the left is any of const, volatile, *, keep reading tokens to the left, until it’s not one of these three. Go to step 4. The tokens that remain form the basic type of the declaration. References Expert C programming","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Misc","slug":"cpp/misc","date":"2018-07-30T10:43:03.000Z","updated":"2018-07-30T10:43:03.000Z","comments":true,"path":"cpp/misc.html","link":"","permalink":"https://guyong.xyz/cpp/misc.html","excerpt":"LLVM (low level virtual machine) 是一系列binary和tools的集合，可以用来构造编译器。clang 是用LLVM 构造的应用于c/c++, objective c/c++等语言的编译器，clang是前端，LLVM是后端。llvm-gcc是一个modified version of gcc，使用了llvm作为后端（而不是gcc的后端），现在已经deprecated. 从编译器使用者的角度看，clang基本兼容gcc, 但在诸如compile commands、link、extensions等方面有些小差异。 https://clang.llvm.org ht","text":"LLVM (low level virtual machine) 是一系列binary和tools的集合，可以用来构造编译器。clang 是用LLVM 构造的应用于c/c++, objective c/c++等语言的编译器，clang是前端，LLVM是后端。llvm-gcc是一个modified version of gcc，使用了llvm作为后端（而不是gcc的后端），现在已经deprecated. 从编译器使用者的角度看，clang基本兼容gcc, 但在诸如compile commands、link、extensions等方面有些小差异。 https://clang.llvm.org https://gcc.gnu.org/onlinedocs/gcc/index.html C and C++ provide for three levels of linkage: • A name with no linkage denotes an entity that can’t be referenced via names from anywhere else. • A name with internal linkage denotes an entity that can be referenced via names declared in the same scope or in other scopes of the same translation unit. • A name with external linkage denotes an entity that can be referenced via names declared in the same scope or in other scopes of the same translation unit (just as with internal linkage), or additionally in other translation units. Both function and object names can have either internal or external linkage. Object names can also have no linkage. Beyond that, all other names in C have no linkage. In contrast, other names in C++ can have external linkage, including names for classes, enumeration types and constants, namespaces, references, and templates. References and function templates can also have internal linkage. static library vs. dynamic library on windows","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Draft","slug":"default/draft","date":"2018-07-28T16:57:18.000Z","updated":"2018-07-28T16:57:18.000Z","comments":true,"path":"default/draft.html","link":"","permalink":"https://guyong.xyz/default/draft.html","excerpt":"Blog requirements * article meta: tags, times, title, excerpt GFM doesn’t support: * fontawesome * toc * math * sup, sub, mark * footnotes * abbreviation","text":"Blog requirements article meta: tags, times, title, excerpt GFM doesn’t support: fontawesome toc math sup, sub, mark footnotes abbreviation","categories":[{"name":"default","slug":"default","permalink":"https://guyong.xyz/categories/default/"}],"tags":[]},{"title":"Links","slug":"links","date":"2018-07-28T16:55:24.000Z","updated":"2018-07-28T16:55:24.000Z","comments":true,"path":"links.html","link":"","permalink":"https://guyong.xyz/links.html","excerpt":"About Stickers","text":"About Stickers","categories":[],"tags":[]},{"title":"Stickers","slug":"stickers","date":"2018-07-28T16:54:46.000Z","updated":"2018-07-28T16:54:46.000Z","comments":true,"path":"stickers.html","link":"","permalink":"https://guyong.xyz/stickers.html","excerpt":"Keep writing, reviewing, exercising, and thinking. 2017-08-23 透过表象看本质，抓住本质找规律，运用规律改变世界","text":"Keep writing, reviewing, exercising, and thinking. 2017-08-23 透过表象看本质，抓住本质找规律，运用规律改变世界","categories":[],"tags":[]},{"title":"Book list","slug":"Collection/books","date":"2018-07-28T16:54:03.000Z","updated":"2018-07-28T16:54:03.000Z","comments":true,"path":"Collection/books.html","link":"","permalink":"https://guyong.xyz/Collection/books.html","excerpt":"English writing * Academic Writing: A Handbook for International Students * On writing well * Elements of style * College writing skills with readings","text":"English writing Academic Writing: A Handbook for International Students On writing well Elements of style College writing skills with readings","categories":[{"name":"Collection","slug":"Collection","permalink":"https://guyong.xyz/categories/Collection/"}],"tags":[]},{"title":"About","slug":"about","date":"2018-07-28T16:47:23.000Z","updated":"2018-07-28T16:47:23.000Z","comments":true,"path":"about.html","link":"","permalink":"https://guyong.xyz/about.html","excerpt":"About this site Motivation Keep writing, reading, practicing, and thinking. It’s one of my dreams to make a personal website since I came into the internet world. I’m neither interesting nor good at writing. However, from time to time there are some ideas that come to my mind and die away since I","text":"About this site Motivation Keep writing, reading, practicing, and thinking. It’s one of my dreams to make a personal website since I came into the internet world. I’m neither interesting nor good at writing. However, from time to time there are some ideas that come to my mind and die away since I didn’t put them into actions for various reasons. Therefore, I think it’s worth to take a note. In addition, I’ve been suffering from searching solutions on internet for similar or even the same problems over and over again because the solutions are forgotten or I only took the small part I needed at that time. So, I think collection and summary may help a lot. Site Building This site is build by hexo, with theme icarus , see site-building About me I’m a graduate student in Beijing, China. I’m interested in： Programing and Designing. Various ball related sports— badminton, billiards，tennis, table tennis, basketball, football, etc. Online novels, RTS games, Animation. contact email: dujcel AT icloud DOT com","categories":[],"tags":[]},{"title":"Initialization","slug":"cpp/initialization","date":"2018-07-28T16:09:35.000Z","updated":"2018-07-28T16:09:35.000Z","comments":true,"path":"cpp/initialization.html","link":"","permalink":"https://guyong.xyz/cpp/initialization.html","excerpt":"Initialization For each declarator, the initializer may be one of the following: * ( expression-list ) comma-separated list of arbitrary expressions and braced-init-lists in parentheses * = expression * { Initializer-list } braced-init-list: possibly empty, comma-separated list of expressi","text":"Initialization For each declarator, the initializer may be one of the following: ( expression-list ) comma-separated list of arbitrary expressions and braced-init-lists in parentheses = expression { Initializer-list } braced-init-list: possibly empty, comma-separated list of expressions and other braced-init-lists Depending on context, the initializer may invoke one of the following: Value-initialization, e.g. std:string s{}; Direct-initialization, e.g. std:string s(&quot;hello&quot;); Copy-initialization, e.g. std:string s = &quot;hello&quot; List-initialization, e.g. std:string s{'a','b','c'} Aggregate-initialization, e.g. char a[3] = {'a','b'} Reference-initialization, e.g. char &amp;c = a[0]; If no initializer is provided, the rules of default initialization apply. constant initialization Non-local variables Static initialization: constant/zero initialization Dynamic initialization Static local variables One Initializer If an initializer is specified for an object, that initializer determines the initial value of an object. An initializer can use one of four syntactic styles: 1234X a1 &#123;v&#125;; // &#123;&#125; initialization (since c++11)X a2 = &#123;v&#125;;X a3 = v;X a4(v); // invoke constructor explictly Of these, only the first can be used in every context, and I strongly recommend its use. The two forms using = are what you use in C. Old habits die hard, so I sometimes (inconsistently) use = when initializing a simple variable with a simple value. However, anything much more complicated than that is better done using {}. Initialization using {}, list initialization, does not allow narrowing (§iso.8.5.4). That is: An integer cannot be converted to another integer that cannot hold its value. For example, char to int is allowed, but not int to char. A floating-point value cannot be converted to another floating- point type that cannot hold its value. For example, float to double is allowed, but not double to float. A floating-point value cannot be converted to an integer type. An integer value cannot be converted to a floating-point type. There is no advantage to using {} initialization, and one trap, when using auto to get the type determined by the initializer. The trap is that if the initializer is a {}-list, we may not want its type deduced (§6.3.6.2). For example: 12auto z1 &#123;99&#125;; // z1 is an initializer_list&lt;int&gt;auto z2 = 99; // z2 is an int So prefer = when using auto. The empty initializer list, {}, is used to indicate that a default value is desired. For example: 12345int x4 &#123;&#125;; // x4 becomes 0double d4 &#123;&#125;; // d4 becomes 0.0char* p &#123;&#125;; // p becomes nullptrvector&lt;int&gt; v4&#123;&#125;; // v4 becomes the empty vectorstring s4 &#123;&#125;; // s4 becomes &quot;&quot; Most types have a default value. For integral types, the default value is a suitable representation of zero. For pointers, the default value is nullptr (§7.2.2). For user-defined types, the default value (if any) is determined by the type’s constructors (§17.3.3). For user-defined types, there can be a distinction between direct initialization (where implicit conversions are allowed) and copy initialization (where they are not); see §16.2.6. Initialization of particular kinds of objects is discussed where appropriate: Pointers: §7.2.2, §7.3.2, §7.4 References: §7.7.1 (lvalues), §7.7.2 (rvalues) • Arrays: §7.3.1, §7.3.2 Constants: §10.4 Classes: §17.3.1 (not using constructors), §17.3.2 (using constructors), §17.3.3 (default), §17.4 (member and base), §17.5 (copy and move) User-defined containers: §17.3.4 Missing Initializers For many types, including all built-in types, it is possible to leave out the initializer. If you do that – and that has unfortunately been common – the situation is more complicated. If you don’t like the complications, just initialize consistently. The only really good case for an uninitialized variable is a large input buffer. 123constexpr int max = 1024*1024;char buf[max];some_stream.get(buf,max); // read at most max characters into buf We could easily have initialized buf: 1char buf[max] &#123;&#125;; // initialize every char to 0 By redundantly initializing, we would have suffered a performance hit which just might have been significant. Avoid such low-level use of buffers where you can, and don’t leave such buffers uninitialized unless you know (e.g., from measurement) that the optimization compared to using an initialized array is significant. If no initializer is specified, a global (§6.3.4), namespace (§14.3.1), local static (§12.1.8), or static member (§16.2.12) (collectively called static objects) is initialized to {} of the appropriate type. For example: Local variables and objects created on the free store (sometimes called dynamic objects or heap objects; §11.2) are not initialized by default unless they are of user-defined types with a default constructor (§17.3.3). For example: 1234567891011int a; // global, means &quot;int a&#123;&#125;;&quot; so that a becomes 0void f() &#123;static int b; // local static, means &quot;static int b&#123;&#125;;&quot; so that b becomes 0int x; // x does not have a well-defined valuechar buf[1024]; // buf[i] does not have a well-defined valueint* p &#123;new int&#125;; // *p does not have a well-defined valuechar* q &#123;new char[1024]&#125;; // q[i] does not have a well-defined valuestring s; // s==&quot;&quot; because of string&apos;s default constructorvector&lt;char&gt; v; // v==&#123;&#125; because of vector&apos;s default constructorstring* ps &#123;new string&#125;; // *ps is &quot;&quot; because of string&apos;s default constructor// ... &#125; Initializer Lists More complicated objects can require more than one value as an initializer. This is primarily handled by initializer lists delimited by { and }. For example: 12345int a[] = &#123; 1, 2 &#125;; // array initializerstruct S &#123; int x, string s &#125;;S s = &#123; 1, &quot;Helios&quot; &#125;; // struct initializercomplex&lt;double&gt; z = &#123; 0, pi &#125;; // use constructorvector&lt;double&gt; v = &#123; 0.0, 1.1, 2.2, 3.3 &#125;; // use list constructor In the cases above, the = is redundant. However, some prefer to add it to emphasize that a set of values are used to initialize a set of member variables. In some cases, function-style argument lists can also be used (§2.3, §16.2.5). For example: 12complex&lt;double&gt; z(0,pi); // use constructorvector&lt;double&gt; v(10,3.3); // use constructor: v gets 10 elements initialized to 3.3 In a declaration, an empty pair of parentheses, (), always means “function” (§12.1). So, if you want to be explicit about “use default initialization” you need {}. For example: 1234complex&lt;double&gt; z1(1,2); // function-style initializer (initialization by constructor)complex&lt;double&gt; f1(); //function declarationcomplex&lt;double&gt; z2 &#123;1,2&#125;; // initialization by constructor to &#123;1,2&#125;complex&lt;double&gt; f2 &#123;&#125;; //initialization by constructor to the default value &#123;0,0&#125; Note that initialization using the {} notation does not narrow (§6.3.5). When using auto, a {}-list has its type deduced to std::initializer_list. {}-lists A {}-list is used to construct an object of some type, so the number of elements and their types must be what is required to construct an object of that type. In addition to their use for initializing named variables (§6.3.5.2), {}-lists can be used as expressions in many (but not all) places. They can appear in two forms: [1] Qualified by a type, T{…}, meaning “create an object of type T initialized by T{…}”; §11.3.2 [2] Unqualified {…}, for which the the type must be determined from the context of use; §11.3.3 Class Object Initialization Problems: copy initialization vs. copy constructors vs. copy assignment Initialization Without (used-declared) Constructors We cannot define a constructor for a built-in type, yet we can initialize it with a value of suitable type. For example: 12int a &#123;1&#125;;char* p &#123;nullptr&#125;; Similarly, we can initialize objects of a class for which we have not defined a constructor using memberwise initialization, copy initialization, or default initialization (without an initializer or with an empty initializer list). For example: 12345678910struct Work &#123;string author;string name;int year;&#125;;Work s9 &#123; &quot;Beethoven&quot;,&quot;Symphony No. 9 in D minor, Op. 125; Choral&quot;,1824 &#125;; // memberwise initializationWork currently_playing &#123; s9 &#125;; // copy initializationWork none &#123;&#125;; // default initialization For default initialization: The default initialization of using {} is defined as initialization of each member by {}. Where no constructor requiring arguments is declared, it is also possible to leave out the initializer completely.(This needs complier provided default constructor ?) For example: 12345Work alpha;void f() &#123; Work beta; // ...&#125; For statically allocated objects (§6.4.2), the rules are exactly as if you had used {}, so the value of alpha is {&quot;&quot;,&quot;&quot;,0}. However, for local variables and free-store objects, the default initialization is done only for members of class type, and members of built-in type are left uninitialized, so the value of beta is {&quot;&quot;,&quot;&quot;,unknown}. The reason for this complication is to improve performance in rare critical cases. Naturally, memberwise initialization works only if we can access the members. Initialization Using Constructors When a class has a constructor, all objects of that class will be initialized by a constructor call. If the constructor requires arguments, these arguments must be supplied: 1234Date today = Date(23,6,1983);Date xmas(25,12,1990); // abbreviated formDate my_birthday; // error: initializer missingDate release1_0(10,12); // error: third argument missing When a class has no user-defined constructor, a default constructor is provided by compiler. 12345678910class X &#123; X(Sometype); // &quot;ordinary constructor&quot;: create an object X(); // default constructor X(const X&amp;); // copy constructor X(X&amp;&amp;); // move constructor X&amp; operator=(const X&amp;); // copy assignment: clean up target and copy X&amp; operator=(X&amp;&amp;); // move assignment: clean up target and move ~X(); // destructor: clean up // ...&#125;; Except for the “ordinary constructor,” these special member functions can be generated by the compiler; see §17.6. Since a constructor defines initialization for a class, we can use the {}-initializer notation: 123Date today = Date &#123;23,6,1983&#125;;Date xmas &#123;25,12,1990&#125;; // abbreviated formDate release1_0 &#123;10,12&#125;; // error: third argument missing I recommend the {} notation over the () notation for initialization because it is explicit about what is being done (initialization), avoids some potential mistakes, and can be used consistently (§2.2.2, §6.3.5). There are cases where () notation must be used (§4.4.1, §17.3.2.1), but they are rare. An initialization with an = is considered a copy initialization. In principle, a copy of the initializer is placed into the initialized object. However, such a copy may be optimized away (elided), and a move operation (§3.3.2, §17.5.2) may be used if the initializer is an rvalue (§6.4.1). Leaving out the = makes the initialization explicit. Explicit initialization is known as direct initialization. The distinction between direct and copy initialization is maintained for list initialization (§17.3.4.3).","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"graph","slug":"algorithms/graph","date":"2018-07-28T14:32:25.000Z","updated":"2018-07-28T14:32:25.000Z","comments":true,"path":"algorithms/graph.html","link":"","permalink":"https://guyong.xyz/algorithms/graph.html","excerpt":"Minimum Height Trees(MHTs) Given a tree T, find all the roots that make the minimum height. * solution 1 Find any longest path, its middle point(s) is the answer. Finding a longest path can be solved in $O(n)$ time by tree dp, or simply 2 tree travesal. * solution 2 Use direct dp, let dp","text":"Minimum Height Trees(MHTs) Given a tree T, find all the roots that make the minimum height. solution 1 Find any longest path, its middle point(s) is the answer. Finding a longest path can be solved in $O(n)$ time by tree dp, or simply 2 tree travesal. solution 2 Use direct dp, let dp[i] be the height of the tree when the tree root is i, compute dp[0],…,dp[n - 1] by tree dp in a dfs manner. In dfs, when we reach node u, let T be the subtree by removing all u’s descendants. We also maintain a variable acc that keeps track of the length of the longest path in T with u being on end. Then we have dp[u] = max(height[u], acc). In dfs, when we move from u to its child v, then newAcc = max(acc + 1, height[v’]+2) for all other child v’ of u. We can compute it in $O(1)$ time by maintaining two heights of each node u, one is the conventional height, the other is the height after removing the branch w.r.t. the convention height. solution 3 Iterately prune leaves. Use Set to denote the adjancency, compute the answer in O(n) time. Leetcode solution 1 and 2 Leetcode solution 3 Graph Algorithm (4+3+3+5 = 10 algs) Elementary BFS DFS Topological Sort SCC MST Generic-MST Kruskal Prim SSSP Bellman-Ford SSSP-DAG Dijkstra APSP Slow-Matrix-Mulplication Faster-Matrix-Mulplication Floyd-Warshall Transitive Clousure Johnson","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://guyong.xyz/categories/algorithms/"}],"tags":[]},{"title":"Daily","slug":"default/daily","date":"2018-07-28T09:58:39.000Z","updated":"2018-07-28T09:58:39.000Z","comments":true,"path":"default/daily.html","link":"","permalink":"https://guyong.xyz/default/daily.html","excerpt":"羽毛球笔记： 上网步伐练习 1. 初始位置永远是右脚稍稍在前，重心下蹲 2. 交叉步两步上网，不要用垫步 3. 第一步判断来球方位，不要出拍;判断好来球方位后第二步要根据击球点来跨（跨远还是跨近），跨步的同时出拍抢最高点 4. 出拍时拍面接近于水平（有一点偏角），拍杆与前臂夹角接近90度，不要呈180度的水平夹角 5. 击球后回退时先退一小步（并步退，保持右脚在前），准备下一拍可能的扑球。然后再退第二步，退的时候注意稍稍压低重心","text":"羽毛球笔记： 上网步伐练习 初始位置永远是右脚稍稍在前，重心下蹲 交叉步两步上网，不要用垫步 第一步判断来球方位，不要出拍;判断好来球方位后第二步要根据击球点来跨（跨远还是跨近），跨步的同时出拍抢最高点 出拍时拍面接近于水平（有一点偏角），拍杆与前臂夹角接近90度，不要呈180度的水平夹角 击球后回退时先退一小步（并步退，保持右脚在前），准备下一拍可能的扑球。然后再退第二步，退的时候注意稍稍压低重心","categories":[{"name":"default","slug":"default","permalink":"https://guyong.xyz/categories/default/"}],"tags":[]},{"title":"ICALP ppt","slug":"default/ICALP ppt","date":"2018-07-28T09:58:23.000Z","updated":"2018-07-28T09:58:23.000Z","comments":true,"path":"default/ICALP ppt.html","link":"","permalink":"https://guyong.xyz/default/ICALP ppt.html","excerpt":"Slide 1 Hello, every one. I’m gonna talk about the paper “Improved Time …” Slide 2 To introduce the problem, we first define the term “non-decreasing path”. As the name implies, a non-decreasing path is “a path on which …” Now, our goal is to compute the minimum last edge weight of any NDP between","text":"Slide 1 Hello, every one. I’m gonna talk about the paper “Improved Time …” Slide 2 To introduce the problem, we first define the term “non-decreasing path”. As the name implies, a non-decreasing path is “a path on which …” Now, our goal is to compute the minimum last edge weight of any NDP between all pairs of vertices. Formally, we want to compute a matrix R, whose entry (i,j) equals “the minimum last edge weight …” (or \\infty if there is no such a path) As usual, we’ll use m and n to denote the number of edges and the number of vertices respectively. use w§ to denote the minimum last edge weight of P If consider the weight to be time, then we want to travel from i to j with the earliest arrival time. Slide 3 Ok, here are some related results. The most related problem is “Single Source …” which asks to compute the same thing, but only for a single given source. A folklore modification of the Dijkstra’s algorithms solves it in “” time Then, about a decade ago, this paper by Virginia gave a O(m log log n) time algorithm, which is faster in sparse graph. Besides, this paper also gave a linear time algorithm, but in the word-RAM model of computation. For the APNP problem, the same paper gave “the first …”, which runs in this time, with the exponent (15+w)/6. This result can be directly improved by using a faster sub-routine. (Where \\omega is the exponent of the time for matrix multiplication) Note that the APNP problem is “at least as hard as …” In this paper, we first give a result of “”, and then slightly improve it to “”. The relation of these values can be seen in this graph. Slide 4 In this paper, we first define two matrix products, which are kind of similar to the standard matrix multiplication. The first is the dominance product, which counts the number of dominated entries. Another is the “star” product, which is similar as dominance product, but gives the minimum dominating entry in matrix B. The best known result for the star product is given by this paper with this result. This is the faster subroutine that improves virginia’s APNP algorithm Slide 5 Suppose A is the weight matrix of graph G. It can be seen as the APNP result matrix for restricted NDPs containing exactly one edge of G Then A\\star A corresponds to NDPs containing … And the minimum of them corresponds to … In this example, the entry (1,3) of A\\star A get the value 2, which you can see from the graph: there is path from vertex 1 to 2 and then to 3. Slide 6 Let’s call it the Min-Star operation, which functions as extending one edge. If R corresponds to NDPs … Then the result of the Min-Star operation corresponds to NDPs … So, we can come up a Naive algorithm like this. It just repeats the Min-Star operation (n-1) times. However, it costs more than O(n^3) time. Slide 7 Here we give a different perspective of the Min-Star operation It’s easy to see that in the star product, the entries in k-th column of R are only compared to the entries in k-th row of A So, we can compute the Min-Star operation in a “Scanning” style. Specifically, we use every entry of R to scan its corresponding row in A. It seems that this is even worse since it costs O(n^3) time for each Min-Star operation, which results in O(n^4) time in total. But if we look a little closely, we can see that in the “…” So, if we sort the list of finite entries of each row of A, then we can eliminate “…” Slide 8,9,10 Here is a simple example. We use a matrix N to record the position of scanning. N[i,j] is initialized to the beginning position. Here we use R’ to scan A once and the result matrix is R. We use every finite entry of R’ to scan the corresponding row of A from the position N[i,k]. Whenever an entry is scanned, update R as needed. In this scanning, … Here, we use the scanning entry of value 7 to scan the first row of A When the first entry 12 is scanned, the corresponding entry in R is updated. The the same for the second scanned entry 8 We continue scanning until “…” The key point is that: the next repetition of scanning begins … So, for each entry (i,j), the number of scanned entries in the whole n-1 repetitions of scanning is at most n. Therefore, the total time for n-1 repetition of the Min-star operation is reduced to O(n^3) Slide 11 It’s time to introduce our algorithms. We first divide “…” So each sub-matrix contains … We claim that any NDP is … because of the nature of NDP With only one exception: there may be some edges … We handle this by splitting out those edges into … There are at most L such matrices Then we can extend NDPs from A_l to A’_l by matrix multiplication . Because the weights in A’_l are same, which is w_l, and which is greater than all finite entries in A_l Ok, from now on, we’ll ignore this issue. Slide 12 Here are some useful notations. Note that n_l represents the number of … Note that “new” entries are those entries become finite in R_l We conclude that the sum of all n_l’s is at most n^2 because … Slide 13 The main idea of out algorithm is to compute R_1, R_2, …, R_L one by one At the beginning of each phase, we first perform “one edge extension” by … After this, we get a matrix R_l’, which represents the APNP matrix … Then, we do scanning at most (n-1) times You may ask why we do this two steps, rather than just scan n-1 times. Actually, this is one of the main ideas of our paper. Slide 14 After one edge extension, we only need to use those “new entries to do scanning” because … So our algorithm works like this Slide 15 Generally, the … as mentioned before But there are two observations: first … and second A_l contains … it’s sparse By taking advantage of them, the one edge extension can be computed … First, We use boolean matrix multiplication to … Then we use column-balancing … Slide 16 Ok, now we give a simple case. Under the assumption that each row of A_l … which means that … recall that each G_l contains at most n^2/L Then the scanning time is … Hence the total time is beautiful. It’s optimum in some sense. So, the question is: What if … ? Slide 17 To solve this question, we use a similar method as the APNP algorithm in Virginia’s paper The algorithm in that paper first compute … Then it samples a hitting set S of this amount of vertices and compute all NDPs … The algorithm works because: If an … So we can compute p[i,j] by concatenating two subpaths. One is from i to some vertex in S, whose information can be read directly from R Another subpath is from this vertex in S to j, which needs the following oracle Slide 18 The oracle T(h_1,j) for … The oracle for each h_1 can be … There is a byproduct matrix H_2 which … This matrix will play an important role in our algorithm Slide 19 Here is an example. Note that when w’=2, w’’=4 because … w’’ can be found by binary searching For example, given 1, it outputs 4 given 4, it outputs 7 The size of set S is … and the number of queries is … since we query for each pair i,j and each vertex in S The total time of Virginia’s algorithm is hence this value Slide 20 Now let’s get back to our algorithms. What remains is the question … We handle it using the concatenation method as before. For ease of analysis, we replace the notation L with n^t Then we need to deal with the case when “rows of A_l …” We distinguish two kinds of vertices: … Then we solve the question by these two steps: first scan … , after this, we have examined all NDPs that do not pass any high vertex then examine … Slide 21 We use the same oracle for concatenation The time for computing the oracle is … Each query costs However, a new problem comes up. We can’t afford so many queries Here comes the another main idea of our paper. Slide 22 Fortunately, we can query only … We first split a matrix H_1 from R^L where R^L is … Recall that we’ve got a byproduct when computing the oracle By computing a boolean matrix multiplication We claim that we only need to query … It takes this time by using sparse … Specifically, the query procedure works like this The number of queries is bounded by this value Slide 23 Here is the main framework of our algorithm Each phase consists of three steps: … Slide 24 Here is the total time Slide 25 Now we concatenate n^q+1 paths There are two kinds of paths Slide 26 In each phase, we repeat n^q times of scanning and concatenating Then we’ve computed paths through at most … Slide 27 The time for the star product can be reduced because they are two rectangular matrix. In this time, \\omega(1,k,1) is … Also, note that the scanning time … For paths through more than n^q high vertices, … Slide 28 By reducing rectangular matrix multiplication to matrix multiplication, we have this inequality. And the total time can be improved slightly to n^2.78","categories":[{"name":"default","slug":"default","permalink":"https://guyong.xyz/categories/default/"}],"tags":[]},{"title":"review paper","slug":"default/review_paper","date":"2018-07-28T09:58:15.000Z","updated":"2018-07-28T09:58:15.000Z","comments":true,"path":"default/review_paper.html","link":"","permalink":"https://guyong.xyz/default/review_paper.html","excerpt":"Review of “On Counting Oracles for Path Problems” ----------- Overall evaluation ----------- This paper presents algorithms for two oracles answering counting queries: the number of (shortest) paths between any pair of vertices. The first oracle answers the number of paths for a planar DAG; the seco","text":"Review of “On Counting Oracles for Path Problems” ----------- Overall evaluation ----------- This paper presents algorithms for two oracles answering counting queries: the number of (shortest) paths between any pair of vertices. The first oracle answers the number of paths for a planar DAG; the second answers the number of shortest paths for a planar graph (directed or undirected) with positive edge weights. Both oracles take $O(n^{1.5})$ preprocessing time, $O(n^{1.5})$ space and $O(\\sqrt{n})$ query time. The results can be extended to other graphs that admit small balanced separators. The first oracle can be used to improve the time of counting the number of minimum $(s,t)$-cuts in planar and bounded genus graphs (the last paragraph of the main content). For the first oracle, the algorithm works in a divide-and-conquer manner. It first computes a separator $(A,B,C)$ with no edges between $A$ and $B$ and only $O(\\sqrt{n})$ vertices in $C$. Then all paths are divided into two classes: those intersecting $C$ and those don’t. The latter can be handled by recursion on $A$ and $B$. The former are divided according to the specific first intersecting vertex in $C$. The algorithm uses vertices in $C$ as intermediaries. For each $c\\in C$, it computes and stores the cardinality of two sets: the set of $s-c$ paths which intersects $C$ first at $c$ and the set of $c-t$ paths. Then the number of $s-t$ paths intersecting $C$ first at $c$ is the product of those two cardinality because there is a bijection between the set of $s-t$ paths intersecting $C$ first at $c$ and the Cartesian product of those two sets (which is the main technical aspect of their contribution). Therefore, the number of $s-t$ paths intersecting $C$ can be computed by summing over all $c\\in C$ in the query procedure. The algorithm for the second oracle works similarly. It computes shortest paths instead of all paths, stores the weights of those paths as well as the number of them. In the query procedure, it counts only those paths having the shortest weights. Note that the similar bijection doesn’t hold for all those sub-paths, but holds for those achieving the shortest weights, which is exactly what the query procedure requires to count. [Overall assessment] This paper initiate the study on counting oracles for various paths. The first result can be used to improve the time of counting minimum $s-t$-cuts in planar and bounded genus graphs. It’s interesting to known whether there are other applications since the algorithms are sort of restricted. Some more specific comments: At the beginning of section 1.1, the first two works are only for planar graphs. Algorithm 1 only applies to undirected graphs with positive edge weights. It applies to digraphs by a trivial modification. In lemma 3, the time should be $T(n)+O(m)$, since the algorithm is not restricted to planar graphs. Section 5 has the same problem. In section 5, the solutions to some recurrences are wrong. There are a few typos such as: “the separator” -&gt; “the separator C” in section 3 “CONSTRUCTORACLE” -&gt; “CONSTRUCTSHORTESTPATHORACLE” in Alg. 4. “positive edge weights” and “shortest” should be added in Theorem 14 2. Results apply to both undirected graphs and digraphs, can be extended to multigraphs. Algorithm 1 only applies to “positively weighted undirected graphs”. It applies to directed graphs by removing the “else if” segment. Lemma 3, the running time should be $T(n)+O(m)$, unless it’s restricted to plannar graphs. CountPath(G,u): G is a DAG CountShortestPath(G,u): G is positively weighted. 3. Lemma 7, note that the condition “G is a DAG”, to be checked again. The algorithm computes an oracle answering the number of paths between any two veritces in a plannar DAG. It takes $O(n^{1.5})$ time and $O(n^{1.5})$ space to construct and answers each query in time $O(\\sqrt{n})$. The algorithm works in a divide-and-conquer manner. It first computes a balanced separator $(A,B,C)$. Then all paths are divided to two classes: those intersecting C and those don’t. The latter can be counted by recurrsion. It remains to count the former. The former are divided according to the specific first intersecting vertex in C. For every pair $(s,t)$, the algorithm computes and stores for each $c\\in C$ the number of simple paths from $s$ to $c$, which intersects $C$ first at $c$, and the number of simple paths from $c$ to $t$. Then the number of paths intersecting $C$ first at $c$ is the product of them. Therefore, the number of paths intersecting C can be computed by summing over all $c\\in C$. In lemma 7, it’s G is DAG that makes the concatenation of $s-c$ sub-path and $c-t$ sub-path work, i.e. the resulted $s-c-t$ path is a “simple” path. 4. The second algorithm computes an oracle answering the number of shortest paths between any two vertices in a plannar graph (directed or undirected) with positive edge weights. The algorithms costs the same resources as the first one. It also works as similar as it with small modification. In the construction procedure, it computes and stores the number of shortest paths from $s$ to $c$ and from $c$ to $t$ instead of all the paths. Meanwhile, it also records the weights of those paths. In the query procedure, the algorithm examine each possible path and only count those having the shortest weight. The concatenated $s-c-t$ path is not necessarily simple, but the really counted $s-c-t$ in the query procedure must be simple.","categories":[{"name":"default","slug":"default","permalink":"https://guyong.xyz/categories/default/"}],"tags":[]},{"title":"Target:summary","slug":"cpp/Target: Summary","date":"2018-07-27T16:31:24.000Z","updated":"2018-07-27T16:31:24.000Z","comments":true,"path":"cpp/Target: Summary.html","link":"","permalink":"https://guyong.xyz/cpp/Target: Summary.html","excerpt":"C++ 中有很多难点，包括但不限于： 1. Rvalue reference 2. Templates 3. functions 4. concurrency 5. special member functions Target 系列将以每一个难点为专题来剖析，尽量做到以下几点： * 整体方面的完整性 * 描述各问题的本质 * 交叉重复内容使用交叉索引 Rvalue reference * lvalue/rvalue * (const) lvalue/rvalue reference * binding * std::move, std::forward Te","text":"C++ 中有很多难点，包括但不限于： Rvalue reference Templates functions concurrency special member functions Target 系列将以每一个难点为专题来剖析，尽量做到以下几点： 整体方面的完整性 描述各问题的本质 交叉重复内容使用交叉索引 Rvalue reference lvalue/rvalue (const) lvalue/rvalue reference binding std::move, std::forward Templates type deduction instantiation (and function overloading) specialization function function signature specifiers noexcept, explicit, inline, (pure) virtual, noreturn, constexpr, final/override overloading function objects","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"","slug":"ideas","date":"2018-07-27T16:02:22.000Z","updated":"2018-07-27T16:02:22.000Z","comments":true,"path":"ideas.html","link":"","permalink":"https://guyong.xyz/ideas.html","excerpt":"游戏设计 * 突显个人特色，不能复制他人的经验和教程 * 赛马，预测","text":"游戏设计 突显个人特色，不能复制他人的经验和教程 赛马，预测","categories":[],"tags":[]},{"title":"Node Basics","slug":"web/node_basics","date":"2018-07-27T16:01:42.000Z","updated":"2018-07-27T16:01:42.000Z","comments":true,"path":"web/node_basics.html","link":"","permalink":"https://guyong.xyz/web/node_basics.html","excerpt":"Module How does require() work ? require() 源码解读 by 阮一锋 nodejs official reference about module 1. Require statements are executed sychronously. That is, all the statements in the required module are executed before continuing execute statements after the require statement. 2. Required modules are","text":"Module How does require() work ? require() 源码解读 by 阮一锋 nodejs official reference about module Require statements are executed sychronously. That is, all the statements in the required module are executed before continuing execute statements after the require statement. Required modules are cached. They can be viewed as single instance. Basic modules fs stream https path Other common modules cheerio: for jquery underscore: for underscore bluebird: for Promise Npm Install npm install installs all dependent packages (and those dependent on these packages, and…) specified in package.json. npm install &lt;package&gt; installs ‘package’. options: -g : install globally (default locally in ./node_modules/) –save: save to package.json as dependency –save-dev: save to package.json as dependencyDev Others create a symlink on mac 1ln -s /path/to/origin /path/to/link","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Node","slug":"web/node","date":"2018-07-27T16:01:34.000Z","updated":"2018-07-27T16:01:34.000Z","comments":true,"path":"web/node.html","link":"","permalink":"https://guyong.xyz/web/node.html","excerpt":"Node.js 1. The art of node This article expatiates asynchrous mechanism in node. It explains why node is a I/O based language. It mainly talks about “callbacks”, “events”, “modules”. “stream” is talked about in stream-handbook 2. Javascript promise, under the hood. This article illustrate how promi","text":"Node.js 1. The art of node This article expatiates asynchrous mechanism in node. It explains why node is a I/O based language. It mainly talks about “callbacks”, “events”, “modules”. “stream” is talked about in stream-handbook 2. Javascript promise, under the hood. This article illustrate how promise works by writing its own promise library squab. It clearly shows what “promise” generally looks like. 3.《深入浅出node.js》 This book explains lots of fundmental mechanism behind the scene. Packages file system fs fs-extra chokidar hexo-fs","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Misc","slug":"web/misc","date":"2018-07-27T16:01:18.000Z","updated":"2018-07-27T16:01:18.000Z","comments":true,"path":"web/misc.html","link":"","permalink":"https://guyong.xyz/web/misc.html","excerpt":"What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text I/O Models and event loop in javascript","text":"What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text I/O Models and event loop in javascript","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Js Promise","slug":"web/js_promise","date":"2018-07-27T16:01:00.000Z","updated":"2018-07-27T16:01:00.000Z","comments":true,"path":"web/js_promise.html","link":"","permalink":"https://guyong.xyz/web/js_promise.html","excerpt":"Promise Javascript promise, under the hood. This article illustrate how promise works by writing its own promise library squab. It clearly shows what “promise” generally looks like. A Promise represents a value which may be available now, or in the future, or never. It’s just a syntactical sugar f","text":"Promise Javascript promise, under the hood. This article illustrate how promise works by writing its own promise library squab. It clearly shows what “promise” generally looks like. A Promise represents a value which may be available now, or in the future, or never. It’s just a syntactical sugar for asynchronous function callback. Promise by 廖雪锋 Promise/A+ The official specification 1. A ‘promise’ is an object or function with a then method whose behavior conforms to this specification. 2. A promise must be in one of three states: pending, fulfilled, or rejected. When pending, a promise: may transition to either the fulfilled or rejected state. When fulfilled, a promise: must not transition to any other state. must have a value, which must not change. When rejected, a promise: must not transition to any other state. must have a reason, which must not change. Here, “must not change” means immutable identity (i.e. ===), but does not imply deep immutability. 3. A promise must provide a then method to access its current or eventual value or reason. A promise’s then method accepts two arguments (both are optional, non-function are ignored): 1promise.then(onFulfilled, onRejected) then must return a promise 1234567891011121314'use strict';var p1 = new Promise(function (resolve, reject) &#123; console.log('p1 creating...'); //execute immediately reject('rejecting'); //transit to fulfilled resolve('resolving'); //invalid console.log('p1 created'); //execute immediately&#125;);console.log(typeof p1); //objectconsole.log(p1);p1.then(function (result) &#123; console.log(result)&#125;, function (err) &#123; console.log(err)&#125;); output: 12345p1 creating...p1 createdobjectPromise &#123; &lt;rejected&gt; &apos;rejecting&apos; &#125;rejecting","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Js Others","slug":"web/js_others","date":"2018-07-27T16:00:52.000Z","updated":"2018-07-27T16:00:52.000Z","comments":true,"path":"web/js_others.html","link":"","permalink":"https://guyong.xyz/web/js_others.html","excerpt":"1. jquery w3 tutorial 2. underscore","text":"jquery w3 tutorial underscore","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Js Object oriented","slug":"web/js_object_oriented","date":"2018-07-27T16:00:44.000Z","updated":"2018-07-27T16:00:44.000Z","comments":true,"path":"web/js_object_oriented.html","link":"","permalink":"https://guyong.xyz/web/js_object_oriented.html","excerpt":"Object oriented Object Every variable can be used as a object, except for undefined and null . Even number literal has its dot operation if the dot is not parsed as float point. 1 2 3 4 2.toString(); // SyntaxError 2..toString(); // valid 2 .toString(); // valid (2).toString(); //valid However,","text":"Object oriented Object Every variable can be used as a object, except for undefined and null . Even number literal has its dot operation if the dot is not parsed as float point. 12342.toString(); // SyntaxError2..toString(); // valid2 .toString(); // valid(2).toString(); //valid However, javascript distinguish object data types (including function object and array object) from primary data types (Number, String, …) 12345678910var a = 3;a.x = 2; //invalid, a.x is undifiendvar b = [3, 2];b.x = 2; //validfunction foo()&#123;&#125;foo.x = 2; //validvar c = &#123;&#125;c.x = 2; //validvar s = \"str\";s.x = 2; //invalid object can be used as hash tables. A property can be accessed in two ways: dot operation and [] operation. They are equivalent, except that [] operation can be used in following two cases while dot operation can’t: set property dynamiclly property name is a not valid variable name Objects created using {} are inherited form Object.prototype. A property can only be deleted using delete operation Usage of this this can only be used inside of function, it always refers to the caller of this function. this may refers to global 12345var x = 1;function test()&#123; alert(this.x);&#125;test(); // 1 this in constructor function 1234567var x = 2;function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 alert(o.x); //1 this in bound function: apply, call 123456789var x = 0;function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0o.m.apply(o); //1 Prototypal inheritance We distinguish __proto__ from prototype Every object (include function object) has an implicit __proto__ property. It is this property that implements prototype chain. 12345678910function getProperty(obj, prop) &#123; if (obj.hasOwnProperty(prop)) return obj[prop] else if (obj.__proto__ !== null) return getProperty(obj.__proto__, prop) else return undefined&#125; Note: The in, for in operations will search upward the prototype chain, use hasOwnProperty as filter if needed. Every constructor function has a property prototype, which is an empty object by default. If variable x is constructed (using new) by function F, then x.__proto__ === F.prototype Here is how new works: 1234567function New (F) &#123; var n = &#123; '__proto__': f.prototype &#125;; return function () &#123; F.apply(n, arguments); return n; &#125;;&#125; 3. x = new f() doesn’t implement “x inherits another object”. However, Douglas Crockford found a way to exploit the new operator to do real Prototypal Inheritance! 12345Object.create = function (parent) &#123; function F() &#123;&#125; F.prototype = parent; return new F();&#125;; Instance object (object that is not function) don’t have prototype (undefined). This prototype has a constructor property. Whenever a constructor’s prototype is manually modified, its constructor should be maintained properly. ( to ensure the correctness of operations like this.constructor.prototype.constructor.prototype and instance of) 123456789101112function Animal() &#123; this.species = \"动物\"; &#125;function Cat(name, color) &#123; this.name = name; this.color = color; &#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 The code above implement that “Cat inherit Animal”, which is actually “cat1 inherits new Animal()” Not standard: __proto__ is non-standard and even deprecated. Also native Object.create and Douglas Crockford implementation are not exactly equivalent. Not optimized: Object.create (native or custom) has not yet been as heavily optimized as the new construction. It can be up to 10 times slower. class inheritance The class keyword is introduced in ES6, but is syntactical sugar, JavaScript remains prototype-based References: Javascript – How Prototypal Inheritance really works (by vjeux) 原型继承 (by 廖雪峰) Javascript继承机制的设计思想 (by 阮一锋) Javascript面向对象编程（二）：构造函数的继承 (by 阮一锋) Prototypal inheritance","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Js Eventloop","slug":"web/js_event_loop","date":"2018-07-27T16:00:35.000Z","updated":"2018-07-27T16:00:35.000Z","comments":true,"path":"web/js_event_loop.html","link":"","permalink":"https://guyong.xyz/web/js_event_loop.html","excerpt":"Concurrency model and Event Loop","text":"Concurrency model and Event Loop","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Js Closures","slug":"web/js_closure","date":"2018-07-27T16:00:24.000Z","updated":"2018-07-27T16:00:24.000Z","comments":true,"path":"web/js_closure.html","link":"","permalink":"https://guyong.xyz/web/js_closure.html","excerpt":"Closure How do JavaScript closures work under the hood[1] This is the best article I’ve read that illustrats how “closures” works and what is going on behind the scene when they’re used. 1. scope objects Each function object has a “scope” property that points to the scope the function is defined.","text":"Closure How do JavaScript closures work under the hood[1] This is the best article I’ve read that illustrats how “closures” works and what is going on behind the scene when they’re used. 1. scope objects Each function object has a “scope” property that points to the scope the function is defined. Whenever a function is called, a corresponding scope is created. (If same function is called multiple times, then multiple seprate scope object are created.) This new created scope object has a pointer pointing to its parent scope object, which is the scope property of the function object, resulting in a scope chain. Scope chain works as same as prototype chain, except that ReferenceError is throwed rather than undefiend is returned. Whenever there is a reference to it, a scope exists, even if the corresponding function is returned. Otherwise, it will be garbage-collected on occasion. 2. this this is not saved as a part of the scope chain. Instead, value of this depends on the “function invocation pattern”. method invocation pattern function invocation pattern constructor invocation pattern apply invocation pattern Function.prototype.apply/call/bind/ For more details on closure, also refer to [2] and [3] Dmitry Frank. How do JavaScript closures work under the hood ? ↩︎ Stackoverflow. Several excellent introductions to closures. (especially the two most voted). ↩︎ MDN. Function reference ↩︎","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Js Basis","slug":"web/js_basics","date":"2018-07-27T15:59:52.000Z","updated":"2018-07-27T15:59:52.000Z","comments":true,"path":"web/js_basics.html","link":"","permalink":"https://guyong.xyz/web/js_basics.html","excerpt":"1. Basics * scripting language (interpreted, not complied) * object-oriented (inheritance, encapsulation, polymorphism) * prototype-based (also called classless, prototype-oriented, or instance-based) prototype is essentially object, which can be modified dynamically, while “class” can’t * dy","text":"1. Basics scripting language (interpreted, not complied) object-oriented (inheritance, encapsulation, polymorphism) prototype-based (also called classless, prototype-oriented, or instance-based) prototype is essentially object, which can be modified dynamically, while “class” can’t dynamic-typing (type of variable are not fixed) 2. How to use it ? In order to be executed by a browser, js scripts should be used by embeding it in a html file. You can directly place js source code in html with &lt;script&gt; tag &lt;script&gt;...&lt;/script&gt; or place it in a seperate js file then include it in the html file using &lt;script src=&quot;/path/to/js&quot;&gt;&lt;/script&gt; Js script can be placed anywhere in html file. Usually it is placed in &lt;head&gt;. Placing it at the bottom of page can avoid possible loading delay. 3. Data types JavaScript has six data types. Five data types are primitives: string number boolean null undefined symbol: (since ES2015) A data type whose instances are unique and immutable. One type is complex: object ( includes array, function ) You can consider it a bug in JavaScript that typeof null is an object. It should be null. 1234typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true 4. Declaration There are three types of declarations (since ES6): var: global variable or function level variable. let: block level local variable. const: read-only constant. Itself can’t be assigned while it’s properties can. Must be initialized. It’s scope is the same as ‘let’ value variables declared by ‘let’ and ‘var’ with no initial value has the value “undefined” variable scope global: declared outside of function local: declared in function function level 1234if (true) &#123; var x = 5;&#125;console.log(x); // x is 5 block level 1234if (true) &#123; let y = 5;&#125;console.log(y); // ReferenceError: y is not defined variable hositing and function hoisting Variables in JavaScript are in a sense “hoisted” or lifted to the top of the function or statement. However, variables that are hoisted will return a value of undefined. In ECMAScript 2015, let (const) will not hoist the variable to the top of the block. For functions, only function declaration gets hoisted to the top and not the function expression. 12345678910111213141516/* Function declaration */foo(); // \"bar\"function foo() &#123; console.log(\"bar\");&#125;/* Function expression */baz(); // TypeError: baz is not a functionvar baz = function() &#123; console.log(\"bar2\");&#125;; global variables Global variables are in fact properties of the global object. In web pages the global object is window","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Javascript","slug":"web/js","date":"2018-07-27T15:59:38.000Z","updated":"2018-07-27T15:59:38.000Z","comments":true,"path":"web/js.html","link":"","permalink":"https://guyong.xyz/web/js.html","excerpt":"Javascript Notes 1. Online version of “Exploring ES6” by Dr. Axel Rauschmayer If you really want to understand ES6, you have to understand how each feature works, even when you’re dealing with unusual situations and edge cases. What sets Axel Rauschmayer’s Exploring ES6 apart from other books is tha","text":"Javascript Notes 1. Online version of “Exploring ES6” by Dr. Axel Rauschmayer If you really want to understand ES6, you have to understand how each feature works, even when you’re dealing with unusual situations and edge cases. What sets Axel Rauschmayer’s Exploring ES6 apart from other books is that it really cares about the inner workings of ECMAScript. It doesn’t just describe the common use cases that you probably already understand. It digs deep into the semantics and, where necessary, wallows in the edge cases. It explains why features work the way that they work and how they are used in realistic code. Assimilate the material in this book and you will be an ES6 expert. 2. How do JavaScript closures work under the hood This is the best article I’ve read that illustrats how “closures” works and what is going on behind the scene when they’re used. 3. Javascript – How Prototypal Inheritance really works (by vjeux) Other reference: 原型继承 (by 廖雪峰) Javascript继承机制的设计思想 (by 阮一锋) Javascript面向对象编程（二）：构造函数的继承 (by 阮一锋) Prototypal inheritance","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Index","slug":"web/index","date":"2018-07-27T15:59:31.000Z","updated":"2018-07-27T15:59:31.000Z","comments":true,"path":"web/index.html","link":"","permalink":"https://guyong.xyz/web/index.html","excerpt":"html * introduction css Javascript * Index * Basics * Closure * Object oriented * Event loop * Promise * Others Node.js * Index * Basics Markdown * Index * My markdown renderer * Markdown cheatsheet (GFM)","text":"html introduction css Javascript Index Basics Closure Object oriented Event loop Promise Others Node.js Index Basics Markdown Index My markdown renderer Markdown cheatsheet (GFM)","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"Graph Theory","slug":"research/graph theory","date":"2018-07-27T15:58:59.000Z","updated":"2018-07-27T15:58:59.000Z","comments":true,"path":"research/graph theory.html","link":"","permalink":"https://guyong.xyz/research/graph theory.html","excerpt":"Graph theory Courses 1. Theory of Algorithms by Robert Tarjan Papers 1. Linear-Time Approximation for Maximum Weight Matching Ran Duan, Seth Pettie. 2014 Matching Definition and theorems alternating path, augmenting path, blossom, blossom lemma, Berge theorem Results 1. Unweighted, bipartite","text":"Graph theory Courses Theory of Algorithms by Robert Tarjan Papers Linear-Time Approximation for Maximum Weight Matching Ran Duan, Seth Pettie. 2014 Matching Definition and theorems alternating path, augmenting path, blossom, blossom lemma, Berge theorem Results Unweighted, bipartite augmenting path $O(mn)$ Hopcroft-Karp algorithm $O(\\sqrt{n}m)$ Weighted, bipartite (assignment problem) $O(mn+n^2\\log n)$ Unweighted, general Edmonds method (blossom shinking) $\\quad O(mn^2)\\quad O(nm\\alpha(m,\\lceil m/n\\rceil)) \\quad O(m\\sqrt{n})$ Weighted, general Edmonds method (blossom shinking) $\\quad O(mn^2)\\quad O(mn+n^2\\log n)$ Lectures and Papers Matching algorithms Includes augmenting path, Hopcroft-Karp algorithm, Edmonds method. Algorithms and proofs as well as the definition and lemma of blossom is more clear. Graph matching nonbipartite matching Includes Edmonds method, explains why bolssom shirking is needed in general graph. In DFS, a node may be encountered both in odd and even position. It’s necessary to record both of the two kinds of visited label. Otherwise, feasible augmenting path may exists but not found. However, if the algorithm distinguish the two kinds of visited label, odd length cycle may exists in a found path. Therefore, blossom shirking is needed. 2-Matching Definitions and Theorems b-matching, capacitated b-matching, 2-factors, $C_k$-free, TSP Definitions and Theorems Results","categories":[{"name":"research","slug":"research","permalink":"https://guyong.xyz/categories/research/"}],"tags":[]},{"title":"Deep Work","slug":"reading/deep work","date":"2018-07-27T15:58:50.000Z","updated":"2018-07-27T15:58:50.000Z","comments":true,"path":"reading/deep work.html","link":"","permalink":"https://guyong.xyz/reading/deep work.html","excerpt":"亚马逊满99元赚的书，今天到货花了大概四个小时通读了一遍，觉的有不少收获，是个人当前所需要的。全书主要分为两部分： * 深度工作理论：深度工作是什么以及深度工作的价值、意义 * 深度工作准则：进行深度工作的一些准则 在这里我只记下一些重要的笔记，一是通过总结加深下自己的印象，二是以备以后不时之需。注意： 1. 书中有大量\b丰富有趣的事例，这里都略掉了。 2. 有些感想类比是个人所写（大都在以括号标出） 深度工作理论 深度工作与\b浮浅工作 深度工作的特点： 1. 无干扰 2. 使个人认知能力达到极限 3. 创造新的价值，提升技能 4. 难以复制 浮浅工作的特点：","text":"亚马逊满99元赚的书，今天到货花了大概四个小时通读了一遍，觉的有不少收获，是个人当前所需要的。全书主要分为两部分： 深度工作理论：深度工作是什么以及深度工作的价值、意义 深度工作准则：进行深度工作的一些准则 在这里我只记下一些重要的笔记，一是通过总结加深下自己的印象，二是以备以后不时之需。注意： 书中有大量\b丰富有趣的事例，这里都略掉了。 有些感想类比是个人所写（大都在以括号标出） 深度工作理论 深度工作与\b浮浅工作 深度工作的特点： 无干扰 使个人认知能力达到极限 创造新的价值，提升技能 难以复制 浮浅工作的特点： 往往有干扰 对认识能力要求不高 没什么价值 容易复制 在极度浮浅的状态下度过足够的时间，将永久性的\b降低自己深度工作的能力 深度工作的价值 信息时代技术更新很快 ➡ 需要快速学习复杂技能 ➡ 需要深度工作 深度工作创造的价值 ➡ 受众可能是无限的 ➡ 极大的提升所获得的奖励 精心挑选深度工作（切换题材从而保持新鲜感？注意力残留？），无法避免的浮浅工作则拆分成小块，在日程的间隙完成（碎片化 vs. 集中化 ？） 三类人 数字科技（智能机器）的发展分化了劳动力市场（数字鸿沟），筛选出了三类获益人： 高级技术工人：擅长使用智能机器进行创造性工作 超级明星：行业翘楚，胜者通吃（因为远程协作，信息\b流通等技术） 所有者：即所谓的资本家，因为劳动力限制得到大为降低 ==学习复杂技能(不可复制），将技能推向极限来创造实在的价值、成果== 培养和深化自己的头脑 深度专注、刻意学习(deliberate practice) 注意力全情投入 （需要深度工作） 适时得到反馈，从而调整方法 专注于某一项特定技能，反复利用同一大脑回路，能有效的固化这项技能 (神经反射，熟能生巧) 高质量产生 ＝ 时间 x 专注度 注意力残留：多任务并行效率低于按次序完成多项任务 （参考js单线程，以前好像在\b知乎上看到有人讲这个） ==长时间、无干扰、高度专注于单一任务== 注意力管理 集中注意力 vs. 分散注意力 负面恐惧、遗憾 vs. 生活中的美好事物，忽略负面信息 （工作内容） 游手好闲是万恶之源。当你失去关注点时，头脑不会想着生活中的好事，而会纠缠于生活中可能出现的问题 一个人的身体或大脑在自觉努力完成某项艰难且有价值的工作过程中达到极限时，往往是最优体验发生的时候 工作其实比休闲时光更容易带来享受，头脑喜欢挑战 深度工作带来的心流经历可以为你带来深度的满足感 从哲学上看 对工作有某种神圣感（所谓的匠心？），认识到自己工作的意义，能很大程度上得到满足感，从而产生正反馈的激励作用。\b 深度工作准则 准则1：工作要深入 （培养工作的习惯） 欲望是常态，而非个例 工作生活中诱惑是很多的，不要高估自己的抵抗力。意志力是有限的，每次抵抗都会有消耗。 越过良好的意图，在工作生活中加入一些特别设计的惯例和固定程序。以下有6种策略： 首先要选定你的深度哲学：\b 禁欲 （苦修式） 双峰 (例如每年一个月”隐居“，其它时间正常) 节奏：按计划每天特定时候深度工作 新闻记者：由于工作的特殊性，需要随时随地进入深度\b工作 习惯化：将深度工作习惯化（具体的习惯要看个人是否合适） 要有大手笔：适当加大精力、金钱的投入来创造深度工作的良好环境（包括\b物理和心理） 不要独自工作：恰当的加入协作 像经\b商一样执行 关注点放到极端重要的事情上 （你想做的事情越多，完成的事情越少） 抓信引领性指标 （及时反馈，如深度工作的时间） 准备一个醒目的记分板 （记录，提醒，公开化来得到动力） 定期问责 （反馈，调整） 图安逸： 劳逸结合 准则2：拥抱无聊 一旦你适应了分心，你就会迷恋于此 策略：预先\b计划好网络使用时间，在其它时间避免使用网络 ==使用令人分必的网络本身，并不能减少你大脑专注的能力。实际上减损这种能力的行为是，稍有无聊或有一点点认知上的挑战，就从低刺激、高价值的活动转向高刺激、低价值的活动，这使得你的大脑不能容忍没有新\b奇性的东西== （好像也是在知乎上看到过？） 通过分割网络（相当于分割了分心），减少了自己分心的次数，这样就增强了自己控制注意力的力量。 注意： 即使工作需要大量使用网络，该策略也适用 需要保证彻底地屏藩网络 在工作外也按\b计划使用\b网络，可以进一步提升专注训练的效果 准则3：远离社交媒体 明确在你的职业和个人生活中决定成功与幸福的核心因素，只有一种工\b具对这些因素的实际益处大于实际害处时才选择使用它。 如果你想抵御娱乐网站对你时间和精力的诱惑，那么就给大脑找一些高质量的替代活动 准则4：摒弃浮浅 减少浮浅工作的时间，保持深度工作。 工作时间减少了，但是效率增加了。 一天的每一分钟都要做好计划（太严格了吧？），定量分析每一项活动的深度 （合理的规划） update: 2017-08-24","categories":[{"name":"reading","slug":"reading","permalink":"https://guyong.xyz/categories/reading/"}],"tags":[]},{"title":"网络编程","slug":"python/python网络编程","date":"2018-07-27T15:58:40.000Z","updated":"2018-07-27T15:58:40.000Z","comments":true,"path":"python/python网络编程.html","link":"","permalink":"https://guyong.xyz/python/python网络编程.html","excerpt":"杂记： 网卡一般是双工的，上行下行可同时发生，传输是以字节Byte为最小单位（本质上传输的是比特流）。","text":"杂记： 网卡一般是双工的，上行下行可同时发生，传输是以字节Byte为最小单位（本质上传输的是比特流）。","categories":[{"name":"python","slug":"python","permalink":"https://guyong.xyz/categories/python/"}],"tags":[]},{"title":"杂记","slug":"python/python杂记","date":"2018-07-27T15:58:31.000Z","updated":"2018-07-27T15:58:31.000Z","comments":true,"path":"python/python杂记.html","link":"","permalink":"https://guyong.xyz/python/python杂记.html","excerpt":"types分类 immutable: number, string, tuple mutable: list, dict, class-object Function arguments are passed by values: immutable objects are copied by value, while mutable objects are copied by aliasing. classes themselves are objects. Iterable, Iterator, Generator * Iterable: implementing iter()","text":"types分类 immutable: number, string, tuple mutable: list, dict, class-object Function arguments are passed by values: immutable objects are copied by value, while mutable objects are copied by aliasing. classes themselves are objects. Iterable, Iterator, Generator Iterable: implementing iter() to return an iterator. Iterator: implementing next() and using StopIteration to indicate the end of iteration. Generator: a function returning an iterator. Thread Lock 即 Mutex, RLock 是一种特殊的Lock, 在同一线程中可多次获取（需多次释放），支持 acquire() 和 release() Condition是由一个主Lock (可以是RLock)和若干个 Waiter Lock 组成，除acquire(), release()外还支持wait(), notify() Semaphore 是带counter的Condition Event是Condition的一个adaptor，支持set(), wait(), clear() Queue 是由若干个Contiiton实现的queue, 支持 put(), get(), task_done(), join() Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues Understanding Asynchronous IO With Python 3.4’s Asyncio And Node.js Python 开源异步并发框架的未来 (2014年4月)","categories":[{"name":"python","slug":"python","permalink":"https://guyong.xyz/categories/python/"}],"tags":[]},{"title":"Async","slug":"python/python async","date":"2018-07-27T15:58:23.000Z","updated":"2018-07-27T15:58:23.000Z","comments":true,"path":"python/python async.html","link":"","permalink":"https://guyong.xyz/python/python async.html","excerpt":"Future python 中的 Future 相当于 js 中的 Promise ，功能是把”事件发生“ 与”回调函数“ 分离。不仅可以先注册callback, 等“事件发生”（Future中是set_result, js中是resolve)后自动调用一个或多个callback; 还可以在 set_result后在注册callback. 内部通过保存”事件发生“这一状态来实现 Deferred 效果。 Select python中的select module中有针对不同平台的系统函数来完成IO复用的功能，最原始的是select函数, 在大多数平台上都有。poll比 select更优化一些，","text":"Future python 中的 Future 相当于 js 中的 Promise ，功能是把”事件发生“ 与”回调函数“ 分离。不仅可以先注册callback, 等“事件发生”（Future中是set_result, js中是resolve)后自动调用一个或多个callback; 还可以在 set_result后在注册callback. 内部通过保存”事件发生“这一状态来实现 Deferred 效果。 Select python中的select module中有针对不同平台的系统函数来完成IO复用的功能，最原始的是select函数, 在大多数平台上都有。poll比 select更优化一些，本质上差不多。只存在于linux上的epoll 以及 BSD 上的 kqueue，windows上的IOCP, Solaris上的devpoll 则更加优化和强大。其中IOCP是真正的异步，不存在阻塞，其它或多或少有一点阻塞，epoll和kqueue在性能上基本上更真正的异步差不多，devpoll不太清楚。 这些类select函数根据平台的不同，有的只支持sockets（IOCP), 有的还支持pipe( epoll ) 或其它file-like objects. 有的只能监听到readable/writable/error, 有的能精确区分更复杂的事件。epoll 有水平（level）触发和边沿（edge)触发。 python中的selectors module (相当于nodejs中隐含在内部的libuv库） 则将这些不同的select函数抽象成一个统一的接口，用户只需要用DefaultSelector 来获得当前平台下最适合的select。这些类select主要实现以下功能 register(fileobj, events, data=Non): 注册fileobj 以及需要监听的事件 unregister(fileobj): 注销 modify(fileobj, events, data=Non): 更改 select(timeout=None): 返回有”事件发生“的(key, events) list, 其中的key 为SectorKey类，包含fileobj, fd, events, data。该方法会根据timeout的值进行阻塞或非阻塞调用。其内部原理比较复杂，大致是结合了中断和轮询来实现的。 epoll详细工作原理 asyncio 有了python的callback机制，以及select module, 我们已经可以手写地实现python中的异步功能。但是，这样写会很麻烦，代码不易读。于是就有了各种第三方库来简化，如 Tornado, Twisted, Gevent, Eventlet, greenlet等。从3.4开始, python引入了标准库 asyncio. greenlet （比较低级，一般用来构建其它库） Eventlet (基于IO复用和coroutine, 相当于implictly调用coroutine, 不需要像coroutine那样explictly切换控制流) Gevent (与Eventlet类似，但功能更强大） Twisted（面向对象，基于事件驱动的网络库，比较低级） Tornado (作为一个web框架和异步网络库使用，同样基于IO复用和coroutine） async实现了许多功能，要理解它的话需要理解以下几个关键的东西：coroutine, Task, event_loop Coroutine coroutine是通过将Future与generator结合实现的, 其核心在于： 通过yield一个Future将该运行中的coroutine控制流”挂起“ ，相当于thread中的sleep。然而这里是通过generator的机制来保存其运行中间状态，而不是thread中的context switch. 这样不仅比thread节省时间和空间资源，还能减少绝大多数的data race. 因为这里的控制流只在yield处才会被挂起，而thread的挂起是由内核决定的，可发生的任意时候（除非加锁，disable中断）。因些coroutne某种意义上可看作green thread(轻量级线程） 在需要的时候（例如Task中），通过send将某个coroutine唤醒 coroutine 的好处在于可以将异步流用同步的方式来写。 Task 以下是Task的一个简化版 1234567891011121314class Task: def __init__(self, coro): self.coro = coro f = Future() f.set_result(None) self.step(f) def step(self, future): try: next_future = self.coro.send(future.result) except StopIteration: return next_future.add_done_callback(self.step) 每构造一个Task, 其中的coroutine就会执行，一直到yield处”挂起“，并返回一个Future。等到Future被set_result后，该coroutine又会被”唤醒“。其中Future的set_result是由select来完成的。 Event_loop run_until_complete函数接收一个或多个Task对象（若是Future的话，会自动包装生成Task)，直至所有的Task返回。这些Task的”用户代码“ 可以看作是运行在单线程中，而IO操作是通过select功能得到复用。 123456789101112131415class EventLoop: def run_until_complete(self, coro): \"\"\"Run until the coroutine is done.\"\"\" task = Task(coro) task.add_done_callback(stop_callback) try: self.run_forever() except StopError: passclass StopError(BaseException): \"\"\"Raised to stop the event loop.\"\"\"def stop_callback(future): raise StopError 有了coroutine, Task, Event_loop 后，我们还需要自己写select的注册/注销/返回事件 等操作，register写在yield前，unregister写在yield后。但是一些支持异步的库会自动实现这两步，不需要手动来写。例如aiohttp. selector.select()函数的调用也不需要手写，个人猜测是event_loop自动开了这样一个coroutine (或thread)运行。 12345while True: events = selector.select() for event_key, event_mask in events: callback = event_key.data callback(event_key, event_mask)","categories":[{"name":"python","slug":"python","permalink":"https://guyong.xyz/categories/python/"}],"tags":[]},{"title":"Probability","slug":"math/probability","date":"2018-07-27T15:58:14.000Z","updated":"2018-07-27T15:58:14.000Z","comments":true,"path":"math/probability.html","link":"","permalink":"https://guyong.xyz/math/probability.html","excerpt":"大数定理（频率收敛于概率） 设$X_1,…,X_n$为独立同分布的随机变量，记它们的公共均值为$a$, 方差存在并记为$\\sigma^2$. 则对任意给定的$\\epsilon$, 有 $$\\lim_{n\\rightarrow\\infty} P(|\\overline{X_n}-a|\\ge\\epsilon) = 0$$ 中心极限定理 在很一般的情况下，$X_1+X_2+…+X_n$的极限分布就是正态分布。中心极限定理指的是一类定理，以下为其最简单的一种： 设$X_1,…,X_n$为独立同分布的随机变量，记它们的公共均值为$a$, 方差存在并记为$\\sigma^2$. 则对任何实数$x$, 有$$","text":"大数定理（频率收敛于概率） 设$X_1,…,X_n$为独立同分布的随机变量，记它们的公共均值为$a$, 方差存在并记为$\\sigma^2$. 则对任意给定的$\\epsilon$, 有 $$\\lim_{n\\rightarrow\\infty} P(|\\overline{X_n}-a|\\ge\\epsilon) = 0$$ 中心极限定理 在很一般的情况下，$X_1+X_2+…+X_n$的极限分布就是正态分布。中心极限定理指的是一类定理，以下为其最简单的一种： 设$X_1,…,X_n$为独立同分布的随机变量，记它们的公共均值为$a$, 方差存在并记为$\\sigma^2$. 则对任何实数$x$, 有$$\\lim_{n\\rightarrow\\infty} (\\frac{1}{\\sqrt{n}\\sigma}(X_1+…+X_n-na)\\le x)=\\Phi(x)$$ 1、大数定律和中心极限定理可以看做随机变量的零阶和一阶“泰勒展开”，其中大数定律是随机变量的“零阶估计”，中心极限定理是在大数定律成立下的“一阶导数”，在极限下高阶小量可忽略。2、大数定律负责给出估计——期望，中心极限定理负责给出大数定律的估计的误差——标准差乘以标准正态分布。 作者：张雨萌 链接：https://www.zhihu.com/question/22913867/answer/34376453 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"math","slug":"math","permalink":"https://guyong.xyz/categories/math/"}],"tags":[]},{"title":"Index","slug":"math/index","date":"2018-07-27T15:58:03.000Z","updated":"2018-07-27T15:58:03.000Z","comments":true,"path":"math/index.html","link":"","permalink":"https://guyong.xyz/math/index.html","excerpt":"Math Foundation Calculus 如何更好地理解并记忆泰勒展开式 — by 知乎 在圆上用极坐标积分（二元积分），对面积微分时为什么要用$\\rho,d\\rho,d\\theta$ ？ * 一种简单的理解是： 扇形的面积 $S=1/2\\rho^2\\theta$, $dS = \\frac{d S}{d\\theta d\\rho} d\\theta d\\rho = \\frac{\\partial S}{\\partial\\theta \\partial\\rho} d\\theta d\\rho = \\rho d\\rho d\\theta$ * 一种错解是 $dS=d(1/2\\rho^2\\the","text":"Math Foundation Calculus 如何更好地理解并记忆泰勒展开式 — by 知乎 在圆上用极坐标积分（二元积分），对面积微分时为什么要用$\\rho,d\\rho,d\\theta$ ？ 一种简单的理解是： 扇形的面积 $S=1/2\\rho^2\\theta$, $dS = \\frac{d S}{d\\theta d\\rho} d\\theta d\\rho = \\frac{\\partial S}{\\partial\\theta \\partial\\rho} d\\theta d\\rho = \\rho d\\rho d\\theta$ 一种错解是 $dS=d(1/2\\rho^2\\theta) =\\rho\\theta d\\rho + 1/2\\rho^2 d\\theta$, 该表达式本身没问题，但无法利用对其积分来解原问题。 用直观图形表示，在$(\\rho,\\theta)$点时，分别增加$d\\rho,d\\theta$, 则面积增加有三个部分，用扇形公式可计算出分别是$1/2\\rho^2 d\\theta, \\theta\\rho d\\rho, \\rho d\\rho d\\theta$, 用于二元积分时，只需取最后一项$\\rho d\\rho d\\theta$. 这是因为积分在极限意义下为求和，二元求和$\\Sigma_x\\Sigma_y \\Delta x\\Delta y$ 不仅是对直角线上的$\\Delta x\\Delta y$ 求和，而是对整个矩阵求和。所以二元积分看似只取了对角线一项，实际上求的是整个微分$dS$. 简单点的情况，可以考虑直角坐标上矩形的积分，使用的是$dxdy$, 而非 $dS=xdy+ydx$ Algebra","categories":[{"name":"math","slug":"math","permalink":"https://guyong.xyz/categories/math/"}],"tags":[]},{"title":"Alg","slug":"math/alg","date":"2018-07-27T15:57:52.000Z","updated":"2018-07-27T15:57:52.000Z","comments":true,"path":"math/alg.html","link":"","permalink":"https://guyong.xyz/math/alg.html","excerpt":"Recurrence Master Theorem Akra–Bazzi Method","text":"Recurrence Master Theorem Akra–Bazzi Method","categories":[{"name":"math","slug":"math","permalink":"https://guyong.xyz/categories/math/"}],"tags":[]},{"title":"Writing","slug":"english/writing","date":"2018-07-27T15:57:39.000Z","updated":"2018-07-27T15:57:39.000Z","comments":true,"path":"english/writing.html","link":"","permalink":"https://guyong.xyz/english/writing.html","excerpt":"To simplify the ::ensuing:: presentation, … Had there been that if …","text":"To simplify the ::ensuing:: presentation, … Had there been that if …","categories":[{"name":"english","slug":"english","permalink":"https://guyong.xyz/categories/english/"}],"tags":[]},{"title":"Words and Phrases","slug":"english/words_and_phrases","date":"2018-07-27T15:57:32.000Z","updated":"2018-07-27T15:57:32.000Z","comments":true,"path":"english/words_and_phrases.html","link":"","permalink":"https://guyong.xyz/english/words_and_phrases.html","excerpt":"词汇与短语笔记 1. in the wake of “在…之后，紧跟” 2. all in all “总之” 3. “Not choice, but habit rules the unreflecting herd.” William Wordsworth said in the 19th century. 1）unreflecting 意为“缺乏思考的”。2) herd 常见意思是“畜群，牧群”，这里指“民众，百姓”，常含贬义。 4. Among the most popular: paternity and kinship testing. Which adop","text":"词汇与短语笔记 in the wake of “在…之后，紧跟” all in all “总之” “Not choice, but habit rules the unreflecting herd.” William Wordsworth said in the 19th century. 1）unreflecting 意为“缺乏思考的”。2) herd 常见意思是“畜群，牧群”，这里指“民众，百姓”，常含贬义。 Among the most popular: paternity and kinship testing. Which adopted children can use to find their biological relatives and families can use to track down kids put up for adoption. 1） track down 意思是“跟踪找到，追查到”。2) put up for adoption 指“将…送给别人收养”。 To take this approach to the New Englanders normally means to start with the Puritan’s theological innovations and their distinctive ideas about the church—important subjects that we may not neglect. 【译文】以这种方法看待新英格兰人通常意味着要从这些清教徒的神学变革和他们关于教堂的与众不同的理念入手——这些是我们不容忽视的重要主题。 【点拨】 动词短语 take a/an …approach to sth.意思是“对…采用…方法/态度”。 Copyright rested with the journal publisher, and researchers seeking knowledge of the results would have to subscribe to the journal. 【译文】论文的版权归杂志社所有，要想查阅此研究成果的研究者必须订阅该杂志。 【点拨】rest 通常情况下作名词，意为“休息”或“剩余部分”。在本句中，rest 为不及物动词，意为“归于；在于”，此时常与 with 连用。 The report, by John Houghton of victoria University in Australia and Graham Vickery of the OECO,makes heavy reading for publishers who have, so far, made handsome profits. 【译文】这份澳大利亚维多利亚大学的约翰·霍顿和“经合组织”的格雷厄姆·维克瑞共同撰写的报告让那些迄今为止获取了巨大利润的出版商们读起来心情沉重。 【点拨】1） make heavy reading for 在句中是指报告让出版商们“读起来心情沉重”。2) handsome 原意为“英俊的”，但在本句中意为“（收入、收益等）可观的，丰厚的。” by and large 意为“总的来说；大体上” Scholars, policymakers, and critics of all stripes have debated the social implications of these changes,but few have looked at the side effect: family risk has risen as well. 【译文】学者、政策制定者以及形形色色的评论家就这些变化的社会意义展开了讨论，但是却很少有人看到其副作用；家庭风险也提高了。 trade A for B 用A交换B Left, until now, to odd, low-level IT staff to put right, and seen as a concern only of data-rich industries such as banking, telecoms and air travel, information protection is now high on the boss’s agenda in businesses of very variety. 【译文】在这之前，信息保护通常还只是临时的、低层次的信息技术员的工作，并且只被诸如银行、电信、航空公司等数据量大的行业重视，可现在这个问题被放在了各行各业老板的议事日程的重要位置。","categories":[{"name":"english","slug":"english","permalink":"https://guyong.xyz/categories/english/"}],"tags":[]},{"title":"Mood","slug":"english/mood","date":"2018-07-27T15:57:22.000Z","updated":"2018-07-27T15:57:22.000Z","comments":true,"path":"english/mood.html","link":"","permalink":"https://guyong.xyz/english/mood.html","excerpt":"语气（Moods） 语气是利用动词变化来表达“真、假”口吻的方式。依各种不同程度的“真、假”口吻，可以细分为四种语气： * 叙述事实语气（Indicative）：表示所说的是真的 * 条件语气（Conditional）：表示真假还不能确定 * 假设语气（Subjunctive）：说反话，表示所说的与事实相反 * 祈使语气（Imperative）：表示希望能成真，但尚未实现 叙述事实语气 一般的英语句子都是这种语气，在时态部分所学的现在式、过去式、未来式等等也都是属于叙述事实语气，所以不必多作解释。其中只有未来式要说明一下： 1. I’ll go to the U.S. next","text":"语气（Moods） 语气是利用动词变化来表达“真、假”口吻的方式。依各种不同程度的“真、假”口吻，可以细分为四种语气： 叙述事实语气（Indicative）：表示所说的是真的 条件语气（Conditional）：表示真假还不能确定 假设语气（Subjunctive）：说反话，表示所说的与事实相反 祈使语气（Imperative）：表示希望能成真，但尚未实现 叙述事实语气 一般的英语句子都是这种语气，在时态部分所学的现在式、过去式、未来式等等也都是属于叙述事实语气，所以不必多作解释。其中只有未来式要说明一下： I’ll go to the U.S. next year to study for an MBA degree. 现在、过去的事情，真假已经可以确定，所以用叙述事实语气。未来的事情还没有发生，严格说起来还不能确定真假，所以未来式中动词要加上助动词 will, 因为助动词都带有不确定的语气。 The weatherman says sunrise tomorrow is at 5:32. The movie starts in 5 minutes. 虽然还没有发生，但是由于所描述的事在某种程度上可以视为“确定的事实”，不必加上表示不确定性的助动词。 I’ll be ready when he comes. If you are late again, you’ll be fired. 同时叙述两件未来的事性，而两者之间有时间或条件的关联性时，往往其中一件（副词从句中的那句）要改成现在式。这是因为两件未来的事情都不确定，需要先假定其中一件是事实已经发生，才能去推论另一件事。 条件语气 句子中一旦加上语气助动词（如 must, should, will/would, may/might, can/could 等），就产生了不确定的语气，称为条件语气。有两点需要注意： 表达时间功能的不完整性 语气助动词中，must 和 should 这两个词在拼法上没有变化。至于 will/would, may/might, can/could 这三对虽然拼法有变化，可是并不表示时间，而是语气的变化：每一对的后者比前者更不确定。 语气助动词，不论是must这一类，还是can/could这一类，都无法明确表达过去式。助动词后面要用动词原形，同样缺乏时间变化，所以语气助动词需要寻找另一种特别的方式来表达过去时间。 用完成式表达对过去的猜测 语气助动词用来猜测过去的事情时，因为缺乏表达过去时间的能力，所以要借助完成式来表达。例如： It may rain any minute now. (对现在、未来的猜测) It may have rained a little last night. （对过去的猜测） 假设语气 这是一种“说反话”的语气，表示所说的话和事实相反。这种语气是以动词的过去形态作为表达“非事实”的手段。 现在时间 If I were you, I wouldn’t do it. 假设语气是用动词的过去形态来表示”非事实“，因此用 I were you 来表示。连带在主句中也用过去形态（不代表过去时间）的 would 来表示非事实。 过去时间 If I had known earlier, I might have done something. 句子描述的时间本来就是过去时间，要用过去形态来表示”非事实“，就必须用过去完成形态 had known. 同样，主句中也要用过去完成形态（注意区分过去完成时） might have done. 其中 might 是过去形态， have done 是完成式。 未来时间 If an asteroid should hit the earth, man could die out. 这是未来的事情，严格说起来还不能确定，但是发生的可能性甚低，所以可以用非事实语气来叙述。条件从句中用过去形态但不代表过去式的 should hit 来表示非事实，主句中也是用 could die 来表示非事实。 如果是绝无可能发生的事，还有另一种表达方式： If I were to take the bribe, I could never look at other people in the eye again. 用 be going to 的过去形态 were to 来表示未来也绝不会去做。 如果用的是 should， 语气就比较松动，表示应无发生的可能但不排除万一。 以上三种时间的鸡窝，有些地方值得进一步了解一下： 句型的规律性 因为假设语气的句子是用过去形态来表示非事实，所以动词看起来都是过去形态。从以上例子可以看出，主句中都有过去式的语气助词（would, might, could). 这是因为这些句子都是在表达在一个假定的条件（非事实）下“就会”、“就可能”、“就能“有什么结果（也是非事实），所以假设语气的主句中都会有过去拼法的助动词存在。 在假设语气的条件从句中，表示现在时间和过去时间的都没有助动词存在，这是因为要先把假设的条件当真，不能用表示不确定性的助动词。只有未来时间无法排除不确定性，所以用 should 来表示可能性极小的情况，绝无可能的状况用 were to 来表示。这是条件从句中唯一会见到助动词的地方。 动词的规律性 假设语气的动词都是以过去形态来表示非事实，若是现在时间就退后成过去形态，过去时间也就退后成为过去完成形态，而未来时间则是主从句都用过去拼法的助动词来表示。 混合时间的变化 If I had studied harder in school, I could qualify for the job now. 混合真假的变化 I could have contributed to the fund dirve then, only that I didn’t have any money with me. 句型的变化 假设语气的句型很可能不是规规矩矩的“条件从句＋主句”的形态。例如： It’s time kids were in bed. If only I had more time! 祈使语气 祈使语气可视为是条件语气中，省略助动词来表示“希望能成真，但尚未实现”。例如： Come in! 可视为 You may come in! 的省略。 一般语法书上列出一些规则，如： It is necessary that… I insist that… 这些句型后面要用原形动词。其实这就是一种命令句，所以把它称为“间接命令句”，放在祈使语气中来介绍。","categories":[{"name":"english","slug":"english","permalink":"https://guyong.xyz/categories/english/"}],"tags":[]},{"title":"线程同步机制","slug":"dev/线程同步机制","date":"2018-07-27T15:57:10.000Z","updated":"2018-07-27T15:57:10.000Z","comments":true,"path":"dev/线程同步机制.html","link":"","permalink":"https://guyong.xyz/dev/线程同步机制.html","excerpt":"线程基础知识 线程同步的底层支持包括： 1. TSL （或其它）原子操作 2. 中断服务 互斥锁Mutex 最基本的同步机制是锁（Lock），包括 互斥锁(Mutex), Read-Write 锁, 空转锁。以Mutex为例： * 对Mutex状态的判断及修改是通过机器提供的原子性指令完成的。 * 每个Mutex上有一个等待队列（waiting list) * Lock()操作在”locked” 情况下会被挂起，实际上是先空转（spin）一小会再挡土挂起（yield），当前线程会加入到Mutex的waiting list中。 * 挂起是指将线程置于”睡眠“状态，并调用线程调试","text":"线程基础知识 线程同步的底层支持包括： TSL （或其它）原子操作 中断服务 互斥锁Mutex 最基本的同步机制是锁（Lock），包括 互斥锁(Mutex), Read-Write 锁, 空转锁。以Mutex为例： 对Mutex状态的判断及修改是通过机器提供的原子性指令完成的。 每个Mutex上有一个等待队列（waiting list) Lock()操作在”locked” 情况下会被挂起，实际上是先空转（spin）一小会再挡土挂起（yield），当前线程会加入到Mutex的waiting list中。 挂起是指将线程置于”睡眠“状态，并调用线程调试函数切换到其它线程 Unlock() 操作会释放锁, 并且唤醒waiting list中的一个（或所有）线程。 Condition Variables pthread_join()解决的是多个线程等待同一个线程的结束。Condition variable解决的是多个线程等待某个条件发生。 Condition主要用来实现通知/同步机制，内部也是由waiting list实现。实际上Mutex也有”通知唤醒“功能，但Mutex功能过于简单，用来实现通知/同步功能时容易出问题：每个线程需要不断的试图获取Mutex锁并检查条件是否发生，从而浪费大量资源。（python的condition内部就是用多个waiter lock实现的。） Condition 一定要配合 Mutex 才能使用，因为状态的检测/改变与等待/发信操作需要具有原子性。 wait() 会自动释放Mutex, 等到被唤醒时会自动去获取Mutex notify() 会唤唤醒waiting list中的线程 检测条件状态要用while, 发信号要在临界区 Semaphore 信号量 semaphore是进程间PV，可以理解为带计数器的Condition variable Python中的Event, Queue References 操作系统如何实现mutex pthread的各种同步机制 When is a condition variable needed, isn’t a mutex enough? Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues 关于Condition Variable为什么需要一个Mutex的思考 Linux并发与同步","categories":[{"name":"dev","slug":"dev","permalink":"https://guyong.xyz/categories/dev/"}],"tags":[]},{"title":"Misc","slug":"dev/misc","date":"2018-07-27T15:56:55.000Z","updated":"2018-07-27T15:56:55.000Z","comments":true,"path":"dev/misc.html","link":"","permalink":"https://guyong.xyz/dev/misc.html","excerpt":"常见指令时间 https://zhuanlan.zhihu.com/p/30742986","text":"常见指令时间 https://zhuanlan.zhihu.com/p/30742986","categories":[{"name":"dev","slug":"dev","permalink":"https://guyong.xyz/categories/dev/"}],"tags":[]},{"title":"Design Patterns","slug":"dev/design patterns","date":"2018-07-27T15:56:49.000Z","updated":"2018-07-27T15:56:49.000Z","comments":true,"path":"dev/design patterns.html","link":"","permalink":"https://guyong.xyz/dev/design patterns.html","excerpt":"Google研院的Peter Norvig大叔总结了23个design pattern在lisp/python等函数式语言之下的对应物。 引用如下 ===================================================== 16 of 23 patterns are either invisible or simpler, due to: First-class types (6): Abstract-Factory, Flyweight, Factory-Method, State, Proxy, Chain-Of-Responsibility Fi","text":"Google研院的Peter Norvig大叔总结了23个design pattern在lisp/python等函数式语言之下的对应物。 引用如下 ===================================================== 16 of 23 patterns are either invisible or simpler, due to: First-class types (6): Abstract-Factory, Flyweight, Factory-Method, State, Proxy, Chain-Of-Responsibility First-class functions (4): Command, Strategy, Template-Method, Visitor Macros (2): Interpreter, Iterator Method Combination (2): Mediator, Observer Multimethods (1): Builder Modules (1): Facade ===================================================== 总结： Design Pattern揭露了OOP系统本身的不灵活","categories":[{"name":"dev","slug":"dev","permalink":"https://guyong.xyz/categories/dev/"}],"tags":[]},{"title":"参考资料","slug":"cpp/参考资料","date":"2018-07-27T15:55:41.000Z","updated":"2018-07-27T15:55:41.000Z","comments":true,"path":"cpp/参考资料.html","link":"","permalink":"https://guyong.xyz/cpp/参考资料.html","excerpt":"1. 入门基础 C++ Primer (5th) The C++ Programming Language (4th) 2. 实战技术 Effective C++ Effective Modern C++ Effective STL 3. 中级教程 More Effective C++ Exceptional C++ More Exceptional C++ Exceptional C++ Style C++ Coding Standards C++ Templates","text":"入门基础 C++ Primer (5th) The C++ Programming Language (4th) 实战技术 Effective C++ Effective Modern C++ Effective STL 中级教程 More Effective C++ Exceptional C++ More Exceptional C++ Exceptional C++ Style C++ Coding Standards C++ Templates","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Tools","slug":"cpp/tools","date":"2018-07-27T15:55:31.000Z","updated":"2018-07-27T15:55:31.000Z","comments":true,"path":"cpp/tools.html","link":"","permalink":"https://guyong.xyz/cpp/tools.html","excerpt":"Commands 1. nm 2. c++filt","text":"Commands nm c++filt","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Target:references","slug":"cpp/Target: reference","date":"2018-07-27T15:55:15.000Z","updated":"2018-07-27T15:55:15.000Z","comments":true,"path":"cpp/Target: reference.html","link":"","permalink":"https://guyong.xyz/cpp/Target: reference.html","excerpt":"lvalues, rvalues * lvalues/rvalues are expression types, used to tell compiler whether it’s eligible to be moved from. * rvalues are eligible to be moved from, but not guaranted. const rvalues are not eligible. * Applying std::move to an (const) object casts it to rvalue. The returned type is (co","text":"lvalues, rvalues lvalues/rvalues are expression types, used to tell compiler whether it’s eligible to be moved from. rvalues are eligible to be moved from, but not guaranted. const rvalues are not eligible. Applying std::move to an (const) object casts it to rvalue. The returned type is (const) rvalue reference. expression types are independent of object types. e.g. a rvalue reference can be either an lvalue or an rvalue (depending on whether it has a name) lvalue(has identity, not movable), xvalue(has identity, movable), rvalue(movable), prvalue (movable, no identity) One way to distinguish between lvalue and rvalue is to consider whether the expression has an “owner”. An “owner” assumes that it can access the expression’s normal value (not destructed). So, a variable name is an “owner” of the object it stands for. A pointer is an “owner” of the object it refers to, etc. An lvalue reference returned by a function has an “owner” (e.g. [] operator), hence it’s an lvalue. An rvalue reference returned by a function doesn’t have an “owner” (e.g. std::move）, hence it’s an rvalue. However, if it’s afterwards binded to a variable name, it has a “owner”. 12345678function f(Widget&amp; w)&#123; //...&#125;function f(Widget&amp;&amp; w)&#123; //... // w is an lvalue, one reason to consider w to be an \"owner\" is that w may be used multiple times in the function body. We need to assume w can access its undestructed value.&#125;Widget w;f(std::move(w)); // std::move(w) is an rvalue, so the move version of f is called reference For effiency, pointers to large objects are used. However, pointers have some annoy features: The syntax is different A pointer may point to different objects A pointer may be nullptr The language mechanism addressing these problems is called a reference. It doesn’t do much harm to think about a reference as a pointer that is dereferenced each time it is used, as long as one remember that a reference isn’t an object. (In some cases, the compiler can optimize away a reference so that there is no object representing that reference at run time) references are implicitly dereferenced. Only in initialization can they be read or written to. Since the goal of an ordinary reference is to mimic the object it reference to, we need to reflect lvalue/rvalue and const/non-const distinctions. There are three kinds of references: lvalue reference: to refer to objects whose value we want to change const reference: to refer to objects whose value we do not want to change (e.g. a constant) rvalue reference: to refer to objects whose value we do not need to preserve after we have used it (e.g. a temporary) The first two are both called lvalue reference. lvalue reference The initializer for a “plain” T&amp; must be an lvalue of type T The initializer for a const T&amp; need not be an lvalue or even of type T. In such cases, a temporary object is created and implicit conversion is applied if necessary and it points to the temporary object. (otherwise it points to the initializer object) rvalue reference An rvalue reference can bind to an rvalue, but not to an lvalue. Both a const lvalue reference and an rvalue reference can bind to an rvalue. However, the purposes will be fundamentally different: We use rvalue references to implement a “destructive read” for optimization of what would otherwise have required a copy. We use a const lvalue reference to prevent modification of an argument. reference binding lvalue references const lvalue reference rvalue references const rvalue references lvalue may binds to #1, #2 const lvalue may binds to #2 rvalue may binds to #3, #4, #2 const rvalue may binds to #4, #2 The binding order is used in function overloading. reference collapse In reference collapse, lvalue reference always wins. Reference to reference can only happen as the result of an alias or a template type argument. (i.e. when the compiler “calculate” a reference type) 1int &amp;&amp; &amp;r - i; //error Universal reference std::move and std::forward std::move performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything. std::forward casts its argument to an rvalue only if that argument is bound to an rvalue. Neither std::move nor std::forward do anything at runtime.","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Summary","slug":"cpp/summary","date":"2018-07-27T15:55:01.000Z","updated":"2018-07-27T15:55:01.000Z","comments":true,"path":"cpp/summary.html","link":"","permalink":"https://guyong.xyz/cpp/summary.html","excerpt":"Books and tutorials The Definitive C++ Book Guide and List * Accelerated C++ * Essential C++ * Inside the C++ Object Model * The Annotated C++ Reference Manual * The C++ Standard (INCITS/ISO/IEC 14882-2011) * The C++ Programming Language (Bjarne Stroustrup) Useful references and terms rvalue","text":"Books and tutorials The Definitive C++ Book Guide and List Accelerated C++ Essential C++ Inside the C++ Object Model The Annotated C++ Reference Manual The C++ Standard (INCITS/ISO/IEC 14882-2011) The C++ Programming Language (Bjarne Stroustrup) Useful references and terms rvalue reference explained copy elision and RVO RVO V.S. std::move copy elision Conditions under which compiler will not define implicits (constructor, destructor, copy constructor, copy assignment) Conditions for automatic generation of special member functions What is object slicing?(answer by splicer) Resource acquisition is initialization (RAII) Named Return Value Optimization (NRVO) Run-Time Type Information (RTTI) const in function overloading ref-qualifier in function overloading","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"STL","slug":"cpp/stl","date":"2018-07-27T15:54:53.000Z","updated":"2018-07-27T15:54:53.000Z","comments":true,"path":"cpp/stl.html","link":"","permalink":"https://guyong.xyz/cpp/stl.html","excerpt":"The C++ standard library contains mainly: * Input/Output * Containers * Iterators * Algorithms The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Iterator categories * Input iterator (e.g. istream_iterato","text":"The C++ standard library contains mainly: Input/Output Containers Iterators Algorithms The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Iterator categories Input iterator (e.g. istream_iterators) Output iterator (e.g. ostream_iterators) Forward iterator (e.g. forward_list::iterators) Bidirectional iterator (e.g. list::iterators) Random-access iterator","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Index","slug":"cpp/index","date":"2018-07-27T15:54:16.000Z","updated":"2018-07-27T15:54:16.000Z","comments":true,"path":"cpp/index.html","link":"","permalink":"https://guyong.xyz/cpp/index.html","excerpt":"Basics Building Process of C++ Functions Initialization Classes 1. Three programing patterns * procedual programing * abstract data * object oriented * general programing 2. Main features of object oriented programing * Incapsulation * Inheritance * Polymorphism","text":"Basics Building Process of C++ Functions Initialization Classes Three programing patterns procedual programing abstract data object oriented general programing Main features of object oriented programing Incapsulation Inheritance Polymorphism Templastes","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Function","slug":"cpp/functions","date":"2018-07-27T15:53:49.000Z","updated":"2018-07-27T15:53:49.000Z","comments":true,"path":"cpp/functions.html","link":"","permalink":"https://guyong.xyz/cpp/functions.html","excerpt":"Overloading 1. type of parameters ( conversion ) 2. number of parateters 3. const keyword * C++ allows member methods to be overloaded on the basis of const type. Overloading on the basis of const type can be useful when a function return reference or pointer. * C++ allows functions to be over","text":"Overloading type of parameters ( conversion ) number of parateters const keyword C++ allows member methods to be overloaded on the basis of const type. Overloading on the basis of const type can be useful when a function return reference or pointer. C++ allows functions to be overloaded on the basis of const-ness of parameters only if the const parameter is a reference or a pointer. Argument Passing Reference Arguments Array Arguments List Arguments Unspecified number of Arguments Default Arguments A general function often needs more arguments than are necessary to handle simple cases. In particular, functions that construct objects (§16.2.5) often provide several options for flexibility. Consider the complex class: 12345678class complex &#123; double re, im; public: complex(double r, double i) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; // construct complex from two scalars complex(double r) :re&#123;r&#125;, im&#123;0&#125; &#123;&#125; // construct complex from one scalar complex() :re&#123;0&#125;, im&#123;0&#125; &#123;&#125; // default complex: &#123;0,0&#125;// ...&#125;; We could deal with the repetitiveness by considering one of the constructors “the real one” and forward to that (§17.4.3): 123complex(double r, double i) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; // construct complex from two scalarscomplex(double r) :complex&#123;2,0&#125; &#123;&#125; // construct complex from one scalarcomplex() :complex&#123;0,0&#125; &#123;&#125; // default complex: &#123;0,0&#125; However, this can be abbreviated further: 1complex(double r =&#123;&#125;, double i =&#123;&#125;) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; // construct complex from two scalars This makes it clear that if a user supplies fewer than the two arguments needed, the default is used. A default argument is type checked at the time of the function declaration and evaluated at the time of the call. (Default arguments that can change value are most often best avoided because they introduce subtle context dependencies.) 123456class X &#123;public: static int def_arg; void f(int =def_arg); // ...&#125;; Default arguments may be provided for trailing arguments only. 123int f(int, int =0, char* =nullptr);// OKint g(int =0, int =0, char*); // errorint h(int =0, int, char* =nullptr);// error A default argument cannot be repeated or changed in a subsequent declaration in the same scope. 1234567void f(int x = 7);void f(int = 7); // error: cannot repeat default argumentvoid f(int = 8); // error: different default argumentsvoid g() &#123; void f(int x = 9); // OK: this declaration hides the outer one // ...&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"FAQ","slug":"cpp/FAQ","date":"2018-07-27T15:53:36.000Z","updated":"2018-07-27T15:53:36.000Z","comments":true,"path":"cpp/FAQ.html","link":"","permalink":"https://guyong.xyz/cpp/FAQ.html","excerpt":"1 2 3 4 5 6 7 8 class B{} class D:public B{} //definition of class B and class D are omitted int main(){ B b; D d; return 0; } * How does the compiler resolve a function call ? In the following order: 1. name loopup(scope hiding) 2. type check(overload resolving) 3. check","text":"12345678class B&#123;&#125;class D:public B&#123;&#125;//definition of class B and class D are omittedint main()&#123; B b; D d; return 0;&#125; How does the compiler resolve a function call ? In the following order: name loopup(scope hiding) type check(overload resolving) check accessability check deleted status Are all data members static binded except for those inherited from virtual base classes ? YES. The binding depends only on the type of pointers (or references). Are virtual function tables of base class stored in objects of derived class ? YES. They are stored as data member of base class subobject. (Not accessable through virtual function mechanism of objects of derived class.) Is assignment operator binded staticly? YES. e.g. Assignment operator expects an argument of type const &amp;X 1234567b = d; // OK, slice. Because D can be converted to const&amp; Bd = b; // error. B can not be converted to const&amp; DD d1;D d2;B&amp; b_ref = d2;b_ref = d1; //assignment operator of A is binded.//d2 now contains a mixture of b1 and b2! Pointer to base class can be assigned with pointer to derived class. Vice versa? NO. Pointer to derived class can’t be assigned to pointer to base class object. e.g. 123B b;B *b_ptr = &amp;b;D *d = b_ptr; // error Does “this” in inherited member function pointer to base subobject? YES. “this” should be readjusted both for virtual and non-virtual function.","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"Building Process","slug":"cpp/building-Process-of-Cpp","date":"2018-07-27T15:53:15.000Z","updated":"2018-07-27T15:53:15.000Z","comments":true,"path":"cpp/building-Process-of-Cpp.html","link":"","permalink":"https://guyong.xyz/cpp/building-Process-of-Cpp.html","excerpt":"Building Process * Phases Of Translation * Other notes * 1. Preprocessor * Directives * Capabilities * 2. Linkage Generally, there are several output (not intermediate) targets to be built. The order in which they are built is specified manually. E.g. specified in","text":"Building Process Phases Of Translation Other notes 1. Preprocessor Directives Capabilities 2. Linkage Generally, there are several output (not intermediate) targets to be built. The order in which they are built is specified manually. E.g. specified in target dependencies in Xcode, in makefile for linux, etc. For each target, sources files (.c, .cpp) are translated to translation units in the order specified as above. (May be the order doesn’t make difference because there exists no dependencies) For details on xcode, refer to The Build Process For makefile, refer to: A Simple Makefile Tutorial GNU make Phases Of Translation A translation unit is the combination of a source files, included headers and source files less any source lines skipped by conditional inclusion preprocessor directive. The standard defines 9 phases in the translation. The first four correspond to preprocessing, the next three are the compilation (including assembly), the next one is the instantiation of templates (producing instantiation units) and the last one is the linking. In practice the eighth phase (the instantiation of templates) is often done during the compilation process but some compilers delay it to the linking phase and some spread it in the two. For detail, refer to: http://en.cppreference.com/w/cpp/language/translation_phases For clang, refer to Mach-O Executables (including details on sections in memory) Other notes 1. Preprocessor The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler. Directives The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format: # character preprocessing instruction (one of define, undef, include, if, ifdef, ifndef, else, elif, endif, line, error, pragma) [1] arguments (depends on the instruction) line break The null directive (# followed by a line break) is allowed and has no effect. Capabilities The preprocessor has the source file translation capabilities: conditionally compile of parts of source file (controlled by directive #if, #ifdef, #ifndef, #else, #elif and #endif). replace text macros while possibly concatenating or quoting identifiers (controlled by directives #define and #undef, and operators # and ##) include other files (controlled by directive #include and checked with __has_include (since C++17 )) cause an error (controlled by directive #error) The following aspects of the preprocessor can be controlled: implementation defined behavior (controlled by directive #pragma and operator _Pragma (since C++11)) file name and line information available to the preprocessor (controlled by directives #line) 2. Linkage Linkage of entity (variable, function, class, type ,template, namespace, etc.) decides whether it can be seen in other places (other translation units, other scopes of the same translation unit). There are there kinds of linkage: no linkage, internal linkage, external linkage. Internal and External Linkage in C++ ( by Peter Goldsborough ) These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or cause a compile-time error. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive #warning which emits a user-defined message during compilation. ↩︎","categories":[{"name":"cpp","slug":"cpp","permalink":"https://guyong.xyz/categories/cpp/"}],"tags":[]},{"title":"references","slug":"algorithms/references","date":"2018-07-27T15:52:52.000Z","updated":"2018-07-27T15:52:52.000Z","comments":true,"path":"algorithms/references.html","link":"","permalink":"https://guyong.xyz/algorithms/references.html","excerpt":"1. [Solutions] Introduction to algorithms, 3rd 2. hashing","text":"[Solutions] Introduction to algorithms, 3rd hashing","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://guyong.xyz/categories/algorithms/"}],"tags":[]},{"title":"CLRS Solutions","slug":"algorithms/CLRS solutions","date":"2018-07-27T15:50:26.000Z","updated":"2018-07-27T15:50:26.000Z","comments":true,"path":"algorithms/CLRS solutions.html","link":"","permalink":"https://guyong.xyz/algorithms/CLRS solutions.html","excerpt":"24.3-4 First check wheter $(d,\\pi)$ compose an $s$-rooted tree.(i.e. they satisfy properties 1 and 2 in page 647.) Then check that $d(s)=0$ and for all $v\\in V$, $d(v) = \\min_{u\\in N(v)}{d(u)+w(u,v)}$ and $\\pi(v)$ is the minimizer, where $N(v) = {u\\in V\\ |\\ (u,v)\\in E}$. If all are true, return true","text":"24.3-4 First check wheter $(d,\\pi)$ compose an $s$-rooted tree.(i.e. they satisfy properties 1 and 2 in page 647.) Then check that $d(s)=0$ and for all $v\\in V$, $d(v) = \\min_{u\\in N(v)}{d(u)+w(u,v)}$ and $\\pi(v)$ is the minimizer, where $N(v) = {u\\in V\\ |\\ (u,v)\\in E}$. If all are true, return true, otherwise return false. It can be easily seen that the total time is $O(m+n)$. Now to prove the correctness. For one direction, if $(d,\\pi)$ match one shortest-paths tree, our algorithm must output true. For the other direction, suppose $(d,\\pi)$ doesn’t match any such tree and the algorithm output true. Suppose $T’=(\\pi’,\\delta)$ is a shortest-paths tree. For all incorrect vertex $v$, we must have $d(v)&gt;\\delta(v)$ since we can really find a path of length $d(v)$ from $s$ to $v$ according to $\\pi$. There must be at least one incorrect vertex. Let $v$ be an incorrect vertex closest to $s$ in $T’$. Then $u_1=\\pi(v)$ and $u_2 = \\pi’(v)$ exist since $v$ can not be $s$. Therefore we have $d(u_1)+w(u_1,v)=d(v)&gt;\\delta(v)=d(u_2)+w(u_2,v)$ since $u_2$ is correct, which contradicts the fact that $u_1$ is the minimizer of $d(u)+w(u,v)$. It seems that this algorithm works for negative edges, doesn’t it?","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://guyong.xyz/categories/algorithms/"}],"tags":[]},{"title":"basics","slug":"algorithms/basics","date":"2018-07-27T15:50:14.000Z","updated":"2018-07-27T15:50:14.000Z","comments":true,"path":"algorithms/basics.html","link":"","permalink":"https://guyong.xyz/algorithms/basics.html","excerpt":"Disjoint Set Data Structure: Union-Find The problem We want to maintain a set of disjoint sets, in which elements are fixed. Only union is supported, while spliting is not. Sepcifically, we support following three operations. * MakeSet(u) * Find(u) * Union(u,v) Let $V$ donote the fixed set of e","text":"Disjoint Set Data Structure: Union-Find The problem We want to maintain a set of disjoint sets, in which elements are fixed. Only union is supported, while spliting is not. Sepcifically, we support following three operations. MakeSet(u) Find(u) Union(u,v) Let $V$ donote the fixed set of elements, whose size is $n$. Generally, we want to estimate the total time of a sequence of $m$ operations, in which the first $n$ operation is MakeSet for each element. Linked-list We can represent each set by a linked list, with each element additionally pointing to its head. The worst-case time for Union is $O(n)$, and we can find a sequence of $m$ operations which needs $O(n^2)$ time in total. a weighted-union heuristic We can improve it by a little trick. In the Union operation, we can rename the small set (say B) to the larger set (say A), i.e. make all the elements of B point to the head of A. The worst-case time of Union is stilll $O(n)$, while its amortized time becomes $O(\\log n)$. worst-case amortized MakeSet $O(1)$ $O(1)$ Find $O(1)$ $O(1)$ Union $O(n)$ $O(\\log n)$ Total $O(m\\log n)$ - Forest Wite rooted trees, Union costs $O(1)$, while Find may cost O(n) in worst-case. It can also be improved to $O(\\log n)$ using the same weighted-union heuristic: Union-by-rank. Actually, Union-by-size works as well. The total time is also $O(m\\log n)$ Using another heuristic “path compression”, we can amortize the time of Find and Union to $O(\\alpha(n))$, which results $O(m\\alpha(n))$ time in total. no heuristic weighted-union both(amortized) MakeSet $O(1)$ $O(1)$ $O(1)$ Find $O(n)$ $O(\\log n)$ $O(\\alpha(n))$ Union $O(1)$ $O(1)$ $O(\\alpha(n))$ Total $O(mn)$ $O(m\\log n)$ $O(m\\alpha(n))$","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://guyong.xyz/categories/algorithms/"}],"tags":[]},{"title":"","slug":"Collection/articles","date":"2018-07-27T15:49:54.000Z","updated":"2018-07-27T15:49:54.000Z","comments":true,"path":"Collection/articles.html","link":"","permalink":"https://guyong.xyz/Collection/articles.html","excerpt":"title:articles What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text I/O Models and event loop in javascript","text":"title:articles What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text I/O Models and event loop in javascript","categories":[{"name":"Collection","slug":"Collection","permalink":"https://guyong.xyz/categories/Collection/"}],"tags":[]},{"title":"Markdown","slug":"web/markdown","date":"2018-06-26T15:06:24.000Z","updated":"2018-06-26T15:06:24.000Z","comments":true,"path":"web/markdown.html","link":"","permalink":"https://guyong.xyz/web/markdown.html","excerpt":"1. Introduction Markdown is a plain text format for writing structured documents. The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s b","text":"1. Introduction Markdown is a plain text format for writing structured documents. The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. John Gruber’s canonical description of Markdown’s syntax does not specify the syntax unambiguously. A group of fans of Markdown propose a standard unambiguous syntax specification for Markdown: the CommonMark sepc. 2. Prlimilaries of CommonMark Below are some important points, for detail refer to http://spec.commonmark.org/ Blocks and inlines We can think of a document as a sequence of blocks—structural elements like paragraphs, block quotations, lists, headings, rules, and code blocks. Some blocks (like block quotes and list items) contain other blocks; others (like headings and paragraphs) contain inline content—text, links, emphasized text, images, code, and so on. Indicators of block structure always take precedence over indicators of inline structure. So, for example, the following is a list with two items, not a list with one item containing a code span: 12- `one- two` produces `one two` Blocks can be divided into two types: container blocks and leaf blocks. Leaf blocks includes: Thematic breaks ATX headings and setext headings Indented code blocks and Fenced code blocks Html blocks Link reference definitions Paragraphs Blank lines Container blocks includes: Block quotes List items Lists Inlines are parsed sequentially from the beginning of the character stream to the end (left to right, in left-to-right languages). It includes: Backslash escapes Entity and numeric character references Code spans: Code span backticks have higher precedence than any other inline constructs except HTML tags and autolinks. Emphasis and strong emphasis Links (inline links vs. reference links) Images Autolinks Raw HTML Hard line breaks (line break preceded by two or more spaces) Soft line breaks (regular line break) Textual content Parsing strategy Parsing has two phases: In the first phase, lines of input are consumed and the block structure of the document—its division into paragraphs, block quotes, list items, and so on—is constructed. Text is assigned to these blocks but not parsed. Link reference definitions are parsed and a map of links is constructed. In the second phase, the raw text contents of paragraphs and headings are parsed into sequences of Markdown inline elements (strings, code spans, links, emphasis, and so on), using the map of link references constructed in phase 1. At each point in processing, the document is represented as a tree of blocks. The root of the tree is a document block. The document may have any number of other blocks as children. These children may, in turn, have other blocks as children. In phase 1, the last child of a block is normally considered open, meaning that subsequent lines of input can alter its contents. (Blocks that are not open are closed.) Once all of the input has been parsed, all open blocks are closed. Then in phase 2, We “walk the tree,” visiting every node, and parse raw string contents of paragraphs and headings as inlines. Github flavored Markdown GFM info page GFM cheatsheet Below are some features not included in CommonMark spec. Strikethrough uses two tildes. Scratch this. Syntax highlighting (only support fenced code blocks) Tables Task list Finish my changes Push my commits to GitHub Open a pull request If a task list item description begins with a parenthesis, you’ll need to escape it with : (Optional) Open a followup issue Remarkable Refer to remarkable on github for details. Supports the CommonMark spec + syntax extensions + sugar (URL autolinking, typographer). Syntax extensions Enabled by default: Footnotes Tables (GFM) &lt;del&gt; (GFM strikethrough) - ~~deleted text~~ Disabled by default: &lt;sup&gt; - 19^th^ 19^th^ &lt;sub&gt; - H~2~O H~2~O abbreviations &lt;ins&gt; - ++inserted text++ (experimental) &lt;mark&gt; - ==marked text== (experimental) HEADS UP!: Experimental extensions can be changed later for something like Critic Markup, but you will still be able to use old-style rules via external plugins if you prefer. Markdown-preview-enhanced Refer to Markdown Preview Enhanced for details. This atom plugin uses remarkable to render markdown. Here is how it works: remarkable to convert markdown to html. KaTeX or MathJax to render math expressions. (KaTeX Supported functions/symbols) expression within $...$ will be rendered normally. expression within $$...$$ will be rendered in displayMode. if you want to enable math highlighting, try language-gfm-enhanced package. You can choose your math rendering method from settings panel. MathJax supports more symbols, but it has slower rendering speed compared to KaTeX. mermaid to render flowchart and sequence diagram. code block within {mermaid} notation will be rendered by mermaid check mermaid doc for more information about how to create flowchart and sequence diagram PlantUML to create multiple kinds of graph. (Java is required) You can install Graphviz (not required) to generate all diagram types. code block within {puml} or {plantuml} notation will be rendered by PlantUML. WaveDrom to create digital timing diagram. code block within {wavedrom} notation will be rendered by wavedrom. Viz.js to render dot language graph. code block within {viz} notation will be rendered by Viz.js. add engine:[engine_name] in the first line of code block with {viz} to choose different render engine reveal.js to render beautiful presentations. Click here to see the introduction. In addition, it fetaures: toc generation Task list (GFM) Front matter regex in c++ js regex -&gt; c++ regex 转换规则: 所有的\\变成\\，除了: \\u &quot;变成\\” 注意： c++ 不支持forward reference, nested reference, lookbehind 例如： JS regex中有12个特殊的转义字符(metacharacters) \\ ^ $ . | ? * + ( ) [ { 在表示literal字符时，要在前面加\\转义，相应的c++中则加\\ ] } / 等字符前面可加\\也可以不加，相应的c++中前面可加\\也可以不加 back reference中\\1，在c++中需要变成\\1","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]},{"title":"markdown cheatsheet","slug":"web/md_cheatsheet","date":"2017-08-19T12:08:15.000Z","updated":"2017-08-19T12:08:15.000Z","comments":true,"path":"web/md_cheatsheet.html","link":"","permalink":"https://guyong.xyz/web/md_cheatsheet.html","excerpt":"Markdown cheatsheet Blocks contains several lines while inlines are parts of a line. Inlines can also have nest. extension features tables (GFM) 1. table 2. tablerow 3. tablecell inlines 1. del deleted 2. html marked underline bold italy Container blocks 1. block quotes","text":"Markdown cheatsheet Blocks contains several lines while inlines are parts of a line. Inlines can also have nest. extension features tables (GFM) table tablerow tablecell inlines del deleted html marked underline bold italy Container blocks block quotes block quotes may contain: block quote, fence, hr, list, heading, htmlblock list items list items may contain: fence, blockquote, hr lists lists can contain list items Leaf blocks thematic breaks (---, ___, ***) ATX heading header Setext heading header indented code blocks class{ var a; } fenced code blocks html blocks link reference definition paragraphs Inlines code foo `bar` emphasis and strong emphasis emph, ***strong emph *** links inline links link reference links link [foo [bar]] images autolinks https://yongggu.me raw htmls","categories":[{"name":"web","slug":"web","permalink":"https://guyong.xyz/categories/web/"}],"tags":[]}]}