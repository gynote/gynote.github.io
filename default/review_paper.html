<h2>Review of “On Counting Oracles for Path Problems”</h2>
<p>----------- Overall evaluation -----------<br>
This paper presents algorithms for two oracles answering counting queries: the number of (shortest) paths between any pair of vertices. The first oracle answers the number of paths for a planar DAG; the second answers the number of shortest paths for a planar graph (directed or undirected) with positive edge weights. Both oracles take $O(n^{1.5})$  preprocessing time, $O(n^{1.5})$ space and $O(\sqrt{n})$ query time. The results can be extended to other graphs that admit small balanced separators. The first oracle can be used to improve the time of counting the number of minimum $(s,t)$-cuts in planar and bounded genus graphs  (the last paragraph of the main content).</p>
<p>For the first oracle, the algorithm works in a divide-and-conquer manner. It first computes a separator $(A,B,C)$ with no edges between $A$ and $B$ and only $O(\sqrt{n})$ vertices in $C$. Then all paths are divided into two classes: those intersecting $C$ and those don’t. The latter can be handled by recursion on $A$ and $B$. The former are divided according to the specific first intersecting vertex in $C$. The algorithm uses vertices in $C$ as intermediaries. For each $c\in C$, it computes and stores the cardinality of two sets: the set of $s-c$ paths which intersects $C$ first at $c$ and the set of $c-t$ paths. Then the number of $s-t$ paths intersecting $C$ first at $c$ is the product of those two cardinality because there is a bijection between the set of $s-t$ paths intersecting $C$ first at $c$ and the Cartesian product of those two sets (which is the main technical aspect of their contribution). Therefore, the number of $s-t$ paths intersecting $C$ can be computed by summing over all $c\in C$ in the query procedure.</p>
<p>The algorithm for the second oracle works similarly. It computes shortest paths instead of all paths, stores the weights of those paths as well as the number of them. In the query procedure, it counts only those paths having the shortest weights. Note that the similar bijection doesn’t hold for all those sub-paths, but holds for those achieving the shortest weights, which is exactly what the query procedure requires to count.</p>
<p>[Overall assessment]  This paper initiate the study on counting oracles for various paths. The first result can be used to improve the time of counting minimum $s-t$-cuts in planar and bounded genus graphs. It’s interesting to known whether there are other applications since the algorithms are sort of restricted.</p>
<hr>
<p>Some more specific comments:</p>
<ul>
<li>At the beginning of section 1.1, the first two works are only for planar graphs.</li>
<li>Algorithm 1 only applies to undirected graphs with positive edge weights. It applies to digraphs by a trivial modification.</li>
<li>In lemma 3, the time should be $T(n)+O(m)$, since the algorithm is not restricted to planar graphs. Section 5 has the same problem.</li>
<li>In section 5, the solutions to some recurrences are wrong.</li>
<li>There are a few typos such as:
<ol>
<li>“the separator” -&gt; “the separator C” in section 3</li>
<li>“CONSTRUCTORACLE” -&gt; “CONSTRUCTSHORTESTPATHORACLE” in Alg. 4.</li>
<li>“positive edge weights” and “shortest” should be added in Theorem 14</li>
</ol>
</li>
</ul>
<h2>2.</h2>
<p>Results apply to both undirected graphs and digraphs, can be extended to multigraphs.</p>
<p>Algorithm 1 only applies to “positively weighted undirected graphs”. It applies to directed graphs by removing the “else if” segment.</p>
<p>Lemma 3, the running time should be $T(n)+O(m)$, unless it’s restricted to plannar graphs.</p>
<p><code>CountPath(G,u)</code>: G is a DAG<br>
<code>CountShortestPath(G,u)</code>: G is positively weighted.</p>
<h2>3.</h2>
<p>Lemma 7, note that the condition “G is a DAG”, to be checked again.</p>
<p>The algorithm computes an oracle answering the number of paths between any two veritces in a plannar DAG. It takes $O(n^{1.5})$  time and $O(n^{1.5})$ space to construct and answers each query in time $O(\sqrt{n})$. The algorithm works in a divide-and-conquer manner. It first computes a balanced separator $(A,B,C)$. Then all paths are divided to two classes: those intersecting C and those don’t. The latter can be counted by recurrsion. It remains to count the former.</p>
<p>The former are divided according to the specific first intersecting vertex in C. For every pair $(s,t)$, the algorithm computes and stores for each $c\in C$ the number of simple paths from $s$ to $c$, which intersects $C$ first at $c$, and the number of simple paths from $c$ to $t$. Then the number of paths intersecting $C$ first at $c$ is the product of them. Therefore, the number of paths intersecting C can be computed by summing over all $c\in C$.</p>
<blockquote>
<p>In lemma 7, it’s G is DAG that makes the concatenation of $s-c$ sub-path and $c-t$ sub-path work, i.e. the resulted $s-c-t$ path is a “simple” path.</p>
</blockquote>
<h2>4.</h2>
<p>The second algorithm computes an oracle answering the number of shortest paths between any two vertices in a plannar graph (directed or undirected) with positive edge weights. The algorithms costs the same resources as the first one. It also works as similar as it with small modification. In the construction procedure, it computes and stores the number of shortest paths from $s$ to $c$ and from $c$ to $t$ instead of all the paths. Meanwhile, it also records the weights of those paths. In the query procedure, the algorithm examine each possible path and only count those having the shortest weight.</p>
<blockquote>
<p>The concatenated $s-c-t$ path is not necessarily simple, but the really counted $s-c-t$ in the query procedure must be simple.</p>
</blockquote>
