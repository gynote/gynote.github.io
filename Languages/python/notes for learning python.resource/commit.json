{"compress":true,"commitItems":[["a7a79bc3-2b84-46cf-b3db-700c25ace55d",1539613911342,"---\ntitle: Notes for Learning Python 5th\n---\n[[toc]]\n# Types and Operations\nObjects are pieces of memory, with values and sets of associated operations. Everything we process in Python programs is a kind of obj \n\nThe Python Conceptual Hierarchy:\n1. Programs are composed of modules.\n2. Modules contain statements.\n3. Statements contain expressions.\n4. Expressions create and process objects.\n\n![Table 4-1](../.pastes/2018-09-03-12-05-36.png)\nIn formal terms, this means that Python is dynamically typed , a model that keeps track of types for you automatically instead of requiring declaration code, but it is also strongly typed, a constraint that means you can perform on an object only operations that are valid for its type.\n\n## Core Types\nImmutable: number, string, tuple, bytes \nMutable: list, dictionary, set, bytearray\n\nPrimitive: number  \nCollection:\n* Sequence: string, tuple, bytes, list,  bytearray\n* Mapping: dictionary, set\n\nbytearray  is a distinct hybrid of immutable bytes  strings (whose b'...'  syntax is required in 3.X and optional in 2.X) and mutable lists  (coded and displayed in [] ).\n\ngeneric operations that span multiple types show up as built-in functions or expressions (e.g. `len(X)` , `X[0]` ), but type-specific operations are method calls (e.g., `aString.upper()` ).\n\nBoth `dir`  and `help`  also accept as arguments either a real object  (like our string S) , or the name of a data type  (like str , list , and dict ).\n\nAs a notable difference, Python 2.X allows its normal and Unicode strings to be mixed in expressions as long as the normal string is all ASCII; in contrast, Python 3.X has a tighter model that never  allows its normal and byte strings to mix without explicit conversion.\n\nNone of the string object’s own methods support pattern-based text processing.\n\nUnlike out-of-bounds assignments in lists, which are forbidden, assignments to new dictionary keys create those keys, fetching a nonexistent key is still a mistake. (Use the get() method)\n\nA file’s contents are always a string in your script, regardless of\nthe type of data the file contains:\n\n```python\n>>> for line in open('data.txt'): print(line)\n```\n\t\nText files represent content as normal str strings and perform\nUnicode encoding and decoding automatically when writing and reading data, while  binary files represent content as a special bytes string and allow you to access file content unaltered.\n\nSets are unordered collections of unique and immutable objects.\nDecimal, Fraction, booleans\n\nAs you’ll learn, in Python, we code to object interfaces (operations supported), not to types.\n\n## Numbers\n![Table 5-1](../.pastes/2018-09-03-12-09-34.png)\n\nFloating-point numbers are implemented as C “doubles” in standard CPython, and therefore get as much precision as the C compiler used to build the Python interpreter gives to doubles.\n\nbuilt-in calls: hex(I), oct(I), bin(I), int(str,base), X.bit_length(),round(X), X.as_integer_ratio()\n\nInternally, complex numbers are implemented as pairs of floating-point numbers\n\n![Table 5-2](../.pastes/2018-09-03-12-10-38.png)\n\nComparison operators may be chained: X < Y < Z  produces the same result as X < Y and Y < Z .\n```python\n>>> 1 == 2 < 3 # Same as: 1 == 2 and 2 < 3\nFalse    # Not same as: False < 3 (which means 0 < 3, which is true!)\n```\n\t\nIn recent Pythons, the slice expression X[I:J:K]  is equivalent to indexing with a slice object: X[slice(I, J, K)].\n\nIn Python 3.X, nonnumeric mixed-type magnitude comparisons are not allowed and raise exceptions; this includes sorts by proxy.\n\n* Operators lower in the table have higher precedence, and so bind more tightly in mixed expressions.\n* Operators in the same row in Table 5-2  generally group from left to right when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right).\n\nBesides mixing operators in expressions, you can also mix numeric types: \nin mixed-type numeric expressions, Python first converts operands up  to the type of the most complicated operand, and then performs the math on same-type operands. Python ranks the complexity of numeric types like so: integers are simpler than floating point numbers, which are simpler than complex numbers. \nIn general, Python does not convert across any other type boundaries automatically. Adding a string to an integer, for example, results in an error, unless you manually convert one or the other.\n\n In 3.X, the / now always performs  true division, returning a float result that includes any remainder, regardless of operand types. The // performs  floor division, which truncates the remainder and returns an integer for integer operands or a float if any operand is a float.\n\nThe // operator truncates the result down to its floor, which means the closest whole number below the true result.\n\nFrozenset\n\nInternally, the names True  and False  are instances of bool , which is in turn just a subclass (in the object oriented sense) of the built-in integer type int . True  and False  behave exactly like the integers 1 and 0, except that they have customized printing logic.\n```\n>>> True + 4 # (Hmmm)\n5\n```\n\t\nNumpy, Scipy\n\t\nThe dynamic typing\nA variable never has any type information or constraints associated with it. The notion of type lives with objects, not names. Variables are generic in nature; they always simply refer to a particular object at a particular point in time.\n\nVariables always link to objects and never to other variables, but larger objects may link to other objects (for instance, a list object has links to the objects it contains).\nThese links from variables to objects are called references  in Python—that is, a reference is a kind of association, implemented as a pointer in memory\n\nTechnically speaking, objects have more structure than just enough space to represent their values. Each object also has two standard header fields: a type designator  used to mark the type of the object, and a reference counter  used to determine when it’s OK to reclaim the object.\n\nreference counter, cyclic reference\n\tsys.getrefcount(X)\n\nIf a[:], a[k] appears in expression, they are copied. e.g. after b=a[:3], b refers to a new object.\nIf a[:], a[k] appears in left side of assignment, they referred to the original object. e.g.  after a=[0,1,2]   a[:] = [0,1], a becomes [0,1]\n\n Because everything  seems to work by assignment and references\nin Python, a basic understanding of this model is useful in many different contexts. As you’ll see, it works the same in assignment statements, function arguments, for  loop variables, module imports, class attributes, and more. The good news is that there is just one  assignment model in Python;\n\nweakref\n\n## String\n![](../.pastes/2018-09-03-12-13-34.png)\n\n![Table 7-1](../.pastes/2018-09-03-16-34-23.png)\nString literal forms:\n* Single quotes: 'spa\"m'\n* Double quotes: \"spa'm\"\n* Triple quotes: '''... spam ...''' , \"\"\"... spam ...\"\"\"\n* Escape sequences: \"s\\tp\\na\\0m\"\n* Raw strings: r\"C:\\new\\test.spm\"\n* Bytes literals in 3.X and 2.6+ (see Chapter 4 , Chapter 37 ): b'sp\\x01am'\n* Unicode literals in 2.X and 3.3+ (see Chapter 4 , Chapter 37 ): u'eggs\\u0020spam'\n\nIn fact, 3.X defines str strings formally as sequences of Unicode code\npoints, not bytes, to make this clear. There’s more on how strings are stored internally in Chapter 37 if you care to know.\n\n![Table 7-2](../.pastes/2018-09-03-12-14-52.png)\n\nSome escape sequences allow you to embed absolute binary values into the characters of a string.\n\nPython keeps both the string’s length and text in memory. In fact, no character terminates a string in Python\n\nNotice that Python displays nonprintable characters in hex, regardless of how they were specified.\n\nThat is, r\"...\\\" is not a valid string literal—a raw string cannot end in\nan odd number of backslashes. If you need to end a raw string with a\nsingle backslash, you can use two and slice off the second (r'1\\nb\\tc\\\\'[:-1]), tack one on manually (r'1\\nb\\tc' + '\\\\'), or skip the raw string syntax and just double up the backslashes in a normal string ('1\\\\nb\\\\tc\\\\').\n\n\n```\n>>> menu = \"\"\"spam # comments here added to string!\n... eggs # ditto\n... \"\"\"\n>>> menu\n'spam # comments here added to string!\\neggs # ditto\\n'\n>>> menu = (\n... \"spam\\n\" # comments here ignored\n... \"eggs\\n\" # but newlines not automatic\n... )\n>>> menu\n'spam\\neggs\\n'\n```\n\n\nbuilt-in tool: `ord()` `chr()`\n\nThe method call expression: object.method(arguments) is evaluated from left to right—Python will first fetch the method  of the object  and then\ncall it, passing in both object and the arguments\n\nstring formatting expressions and string formatting method calls\n Technically, the format  built-in runs the subject object’s `__format__`  method, which the str.format  method does internally for each formatted item.\nThe %  expressions tend to be a bit simpler and more concise; the format  method has a handful of advanced features that the %  expression does not, but even more involved formatting still seems to be essentially a draw in terms of complexity.\n```\n>>> from formats import commas, money\n```\nTypes Share Operation Sets by Categories:\n* numbers\n* sequences\n* mappings\n\n## Lists and Dictionaries\n\n![](../.pastes/2018-09-03-12-17-54.png)\n![Table 8-1](../.pastes/2018-09-03-16-35-48.png)\nSlice assignment, the last operation in the preceding example, replaces an entire section of a list in a single step. Because it can be a bit complex, it is perhaps best thought of as a combination of two steps:\n1. Deletion. The slice you specify to the left of the = is deleted.\n2. Insertion. The new items contained in the iterable object to the right of the = are inserted into the list on the left, at the place where the old slice was deleted.\nNote, L[2:5]=L[3:6], for instance, works fine because the value to be inserted is fetched before the deletion\nhappens on the left.\n```\n>>> L = [1]\n>>> L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front\n>>> L\n[2, 3, 4, 1]\n>>> L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end\n>>> L\n[2, 3, 4, 1, 5, 6, 7]\n>>> L.extend([8, 9, 10]) # Insert all at end, named method\n>>> L\n[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]\n```\n\t\nThe effect of `L.append(X)`  is similar to `L+[X]`, but while the former changes L  in place, the latter makes a new list.\n\nIn Python 3.X, this has changed: magnitude comparison of mixed types\nraises an exception instead of falling back on the fixed cross-type ordering.\n\nL.sort() vs. sorted\nbuilt-in tools: reversed\n\nLike lists, dictionaries store object references (not copies, unless you ask for them explicitly)\n\n![Table 8-2](../.pastes/2018-09-03-12-18-20.png)\n\nkeys  in 3.X returns an iterable  object, instead of a physical list\nUnlike lists, however, whenever you assign a new  dictionary key (one that hasn’t been assigned before) you create a new entry in the dictionary.\n\nIn 3.X the dictionary keys , values , and items  methods all return view objects , whereas in 2.X they return actual result lists. \nBesides being iterable, dictionary views also retain the original order of dictionary components, reflect future changes to the dictionary, and may support set operations. Unlike 2.X’s list results, though, dictionary views in 3.X are not carved in stone when created—they dynamically reflect future changes  made to the dictionary after the view object has been created:\n\n In set operations, views may be mixed with other views, sets, and dictionaries; dictionaries\nare treated the same as their keys  views in this context:\n```\n>>> D = {'a': 1, 'b': 2, 'c': 3}\n>>> D.keys() & D.keys() # Intersect keys views\n{'b', 'c', 'a'}\n>>> D.keys() & {'b'} # Intersect keys and set\n{'b'}\n>>> D.\n```\n\n```\n>>> Ks.sort()\nAttributeError: 'dict_keys' object has no attribute 'sort'\n```\nTo work around this, in 3.X you must either convert to a list manually or use the\nsorted call (introduced in Chapter 4 and covered in this chapter) on either a keys view\nor the dictionary itself:\n\nOrderedDict\n\n## Tuples, files and everything else\n![](../.pastes/2018-09-03-16-36-56.png)\n![Table 9-1](../.pastes/2018-09-03-12-18-57.png)\n\nAs you can see, named tuples are a tuple/class/dictionary hybrid\n (In short, named tuples build new classes that extend the tuple type, inserting a property  accessor method for each named field that maps the name to its position)\n \n![Table 9-2](../.pastes/2018-09-03-12-03-26.png)\n\nEmpty lines in the file come back as strings containing just a newline character, not as empty strings.\n```\n>>> myfile.readline() # Empty string: end-of-file\n''\n```\n\t\n* Text files  represent content as normal str  strings, perform Unicode encoding and decoding automatically, and perform end-of-line translation by default.\n* Binary files  represent content as a special bytes  string type and allow programs to access file content unaltered.\n\npickle, shelve, json, struct\n\n In fact, when nested objects are present, Python automatically\ntraverses data structures to apply comparisons from left to right, and as deeply as\nneeded.\n\n More specifically, Python compares types as follows:\n- Numbers  are compared by relative magnitude, after conversion to the common highest type if needed.\n- Strings  are compared lexicographically (by the character set code point values returned by `ord` ), and character by character until the end or first mismatch (\"abc\"< \"ac\" ).\n- Lists  and tuples  are compared by comparing each component from left to right, and recursively for nested structures, until the end or first mismatch ([2] > [1, 2] ).\n- Sets  are equal if both contain the same items (formally, if each is a subset of the other), and set relative magnitude comparisons apply subset and superset tests.\n- Dictionaries  compare as equal if their sorted (key, value)  lists are equal. Relative magnitude comparisons are not supported for dictionaries in Python 3.X, but they work in 2.X as though comparing sorted (key, value)  lists.\n- Nonnumeric mixed-type magnitude comparisons (e.g., 1 < 'spam' ) are errors in Python 3.X. They are allowed in Python 2.X, but use a fixed but arbitrary ordering rule based on type name string. By proxy, this also applies to sorts, which use comparisons internally: nonnumeric mixed-type collections cannot be sorted in 3.X.\n\nPython 3.X  disallows mixed-type magnitude testing, except numeric types.\n\nMore generally, the notions of true and false are intrinsic properties of every  object in Python—each object is either true or false, as follows:\n- Numbers are false if zero, and true otherwise.\n- Other objects are false if empty, and true otherwise.\n\n That is, *None*  is something, not nothing (despite its name!)—it is a real object and a real piece of memory that is created and given a built-in name by Python itself.\n\n In fact, even types themselves are an object type in Python.\n Calls to these names are really object constructor calls, not simply conversion functions, though you can treat them as simple functions for basic usage.\n\nFor classic classes in Python 2.X, all class instances are instead of the type “instance,” and we must compare instance `__class__` attributes to compare their types meaningfully.\n\nRepetition Adds One Level Deep\n```python\n>>> L = [4, 5, 6]\n>>> X = L * 4 # Like [4, 5, 6] + [4, 5, 6] + ...\n>>> Y = [L] * 4 # [L] + [L] + ... = [L, L,...]\n```\n\t\nIf you remember that repetition, concatenation, and slicing copy only the top level of their operand objects, these sorts of cases make much more sense\n\nBeware of Cyclic  Data Structure\n```python\n>>> L = ['grail'] # Append reference to same object\n>>> L.append(L) # Generates cycle in object: [...]\n>>> L\n['grail', [...]]\n```\n\n# Statements and Syntax\n## Assignments, Expressions, and Prints\n- Assignments create object references. (i.e. link a name with an object) They always create references to objects instead of copying the objects.\n- Names are created when first assigned.\n- Names must be assigned before referenced.\n\nModule imports, function and class definitions, for  loop variables, and function arguments are all implicit assignments.\n\n![Table 11-1](../.pastes/2018-09-03-13-40-51.png)\n\nsequence assignment—any sequence of names can be\nassigned to any sequence of values, and Python assigns the items one at a time by position. In fact, the original tuple and list assignment forms in Python have been generalized to accept any type of sequence (really, iterable) on the right as long as it is of the same length as the sequence on the left.\n\nMultiple-target assignment: Python assigns a reference to the same object (the object farthest to the right) to all the targets on the left.\n\nIn tuple/list assignment, Python creates a temporary tuple that saves the original values of the variables on the right before assigning.\n\nwe can even assign nested sequences, and Python unpacks their parts according to their shape, as expected. The sequence-nesting shape of the object on the left must match that of the object on the right.\n> This nested tuple (really, sequence) unpacking\nassignment form works for function argument lists in Python 2.X (though not in 3.X)\n\nIn short, a single starred name, *X, can be used in the assignment target in order to specify a more general matching against the sequence—the starred name is assigned a list, which collects all items in the sequence not assigned to other names. In fact, the starred name can appear anywhere in the target.\n> This is similar in spirit to slicing, but not exactly the same—a sequence unpacking assignment always returns a list for multiple matched items, whereas slicing returns a sequence of the same type as the object sliced\n```\n>>> a, *b = 'spam'\n>>> a, b\n('s', ['p', 'a', 'm'])\n>>> S[0], S[1:] # Slices are type-specific, * assignment always returns a list\n('s', 'pam')\n```\n\nFinally, errors can still be triggered if there is more than one starred name, if there are too few values and no star (as before), and if the starred name is not itself coded inside a sequence:\n```\n>>> *a = seq\nSyntaxError: starred assignment target must be in a list or tuple\n```\n\nFor augmented assignments, inplace operations may be applied for mutable objects as an optimization.\n```\n>>> L = [1, 2]\n>>> L = L + [3] # Concatenate: slower\n>>> L\n[1, 2, 3]\n>>> L.append(4) # Faster, but in place\n>>> L\n[1, 2, 3, 4]\n>>> L += [9, 10] # Mapped to L.extend([9, 10])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\nNote however, that because of this equivalence += for a list is not exactly the same as a + and = in all cases—for lists += allows arbitrary sequences (just like extend), but concatenation normally does not:\n```\n>>> L = []\n>>> L += 'spam' # += and extend allow any sequence, but + does not!\n>>> L\n['s', 'p', 'a', 'm']\n>>> L = L + 'spam'\nTypeError: can only concatenate list (not \"str\") to list\n```\n> Although Python now supports statements like X += Y, it still does not\nhave C’s auto-increment/decrement operators (e.g., X++, −−X).\n\n### Naming\nFor portability, case also matters in the names of imported module files, even on platforms where the filesystems are case-insensitive.\n\nTrue, False, and None, are somewhat unusual in meaning—they also appear in the built-in scope of Python described in Chapter 17, and they are technically names assigned to objects.\n\nNames that begin with a single underscore (_X) are not imported by a from module import * statement\n\nNames that begin with two underscores and do not end with two more (__X) are localized (“mangled”) to enclosing classes.\n\n### Expression Statements\nIn Python, you can use an expression as a statement, too. Expressions are commonly used as statements in two situations:\n- For calls to functions and methods\n- For printing values at the interactive prompt\n\nA statement that is not an expression must generally appear on a line all by itself, not nested in a larger syntactic structure. For example, Python doesn’t allow you to embed assignment statements (=) in other expressions. Besides, C assignments return the value assigned, but Python assignments are just statements, not expressions.\n\nExpression statements are often used to run list methods that change a list in place:\n```\n>>> L = L.append(4) # But append returns None, not L\n>>> print(L) # So we lose our list!\nNone\n```\n\nNormally, whether printed output is buffered in memory or not is determined by file; passing a true value to flush forcibly flushes the stream.\n\nBecause the print statement just sends text to the sys.stdout.write method, you can capture printed text in your programs by assigning sys.stdout to an object whose write method processes the text in arbitrary ways\n\n## if Tests and Syntax Rules\nThere is no switch or case statement in Python\n\n* Block and statement boundaries are detected automatically.\n* Compound statements = header + “:” + indented statements. \n* Blank lines, spaces, and comments are usually ignored.\n* Docstrings are ignored but are saved and displayed by tools.\n\nStatements may span multiple lines if you’re continuing an open syntactic\npair.\n\nBoolean operators stop evaluating (“short circuit”) as soon as a result is known. Boolean **and** and **or** operators return a true or false object in Python, not the values True or False\n\nFor `A = Y if X else Z`, Python runs expression Y only if X turns out to be true, and runs expression Z only if X turns out to be false.\n\nWhen defining classes, we can specify their Boolean nature with either the\n__bool__ or __len__ methods.\n\n\n\n##  while and for Loops\nThe optional **else** block run if didn't exit loop with **break**\n\nPython doesn’t have what some languages call a “do until” loop statement. Python has no \"go to\" statement.\n\nPython 3.X (but not 2.X) allows ellipses coded as ... (literally, three consecutive dots) to appear any place an expression can. Because ellipses do nothing by themselves, this can serve as an alternative to the pass statement,\n```\n>>> X = ... # Alternative to None\n>>> X\nEllipsis\n```\n\nAfter the **for** loop, this loop variable normally still refers to the last item visited, which is the last item in the sequence unless the loop exits with a break statement.\n\nEven nested structures may be automatically unpacked this way in a for:\n```\n>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)\n```\n\nIn fact, as a general rule, you should resist the temptation to count things in Python—its iteration tools automate much of the work you do to loop over collections in lower-level languages like C.\n\nbuilt-in tools: range, zip, enumerate\n\nThe zip function is more general than this example suggests. For instance,\nit accepts any type of sequence (really, any iterable object, including files), and it accepts more than two arguments. Moreover, zip truncates result tuples at the length of the shortest sequence when the argument lengths differ.\n\n## Iterations and Comprehensions\n* Iterator vs. Iterable  vs. Iteration tool/context\n* Single scan vs. multiple scan\n\nIn some cases these two objects are the same when only a single scan is supported (e.g., files), and the iterator object is often temporary, used internally by the iteration tool. Moreover, some objects are both an iteration context tool (they iterate) and an iterable object (their results are iterable)—including Chapter 20’s generator expressions, and map and zip in Python 3.X.\n\nWhen the for loop begins, it first obtains an iterator from the iterable object by passing it to the iter built-in function; the object returned by iter in turn has the required next method. The iter function internally runs the __iter__ method, much like `next` and `__next__`.\n\nFor comprehensions, their full syntax allows for any number of **for** clauses, each of which can have an optional associated **if** clause.\n\nKeep in mind, though, that every built-in tool that scans from left to right across objects uses the iteration protocol.\n\nNotice that, unlike map and others, sorted returns an actual list in Python 3.X\ninstead of an iterable.\n\nOne of the fundamental distinctions of Python 3.X is its stronger emphasis on iterators than 2.X. This, along with its Unicode model and mandated new-style classes, is one of 3.X’s most sweeping changes.\n\nUnlike **range**, **map**, **zip**, **filter** are their own iterators—after you step through their results once, they are exhausted.\n\nIn Python 3.X the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time.\n\n## Documentation Interlude\nThe PyDoc system covered here can render a module’s internal documentation as either plain text in a shell, or HTML in a web browser.\n\nThe **help** function: press the space bar to move to the next page, Enter to go to the next line, and Q to quit:\n\nSphinx\n\n# Functions and Generators\n## Function Basics\n* *def* is executable code. it’s legal (and even occasionally useful) to nest def statements inside if statements, while loops, and even other *def*s.\n* *def* creates an object and assigns it to a name. Function objects may also have arbitrary user-defined *attributes* attached to them to record data.\n\nNames are always looked up in *scopes*—places where variables are stored— and assignments bind names to scopes.\n\n>Files must generally be rewound (e.g., with a file.seek(0) or another\nopen) after they have been read to end-of-file once, and so are single-pass iterators\n\n## Scopes\nWhen we talk about the search for a name’s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name’s assignment in your source\ncode determines the scope of the name’s visibility to your code.\n\nBy default, all names assigned inside a function are associated with that function’s namespace, and no other.\n\nLexical scoping:\n- If a variable is assigned inside a def, it is local to that function.\n- If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n- If a variable is assigned outside all defs, it is global to the entire file.\n\nEach module is a global scope, the global scope spans a single file only.\n* Assigned names are local unless declared global or nonlocal\n* All other names are enclosing function locals, globals, or built-ins.\n* Each call to a function creates a new local scope.\n\n> Note `L=X` within a function will classify L as a local, but L.append(X) will not.\n\n### Name Resolution: The LEGB Rule\n- Name assignments create or change local names by default.\n- Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in.\n- Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively.\n\nNote that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup level.\n\nAlso keep in mind that these rules apply only to simple variable names (e.g., spam). Qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here.\n\nThere are technically three more scopes in Python—temporary loop variables in some comprehensions, exception reference variables in some try handlers, and local scopes in class statements\n\nIn 3.X, the loop variables are local to the expression itself in all comprehension forms: generator, list, set, and dictionary. In 2.X, they are local to generator expressions and set and dictionary compressions, but not to list comprehensions that map their names to the scope outside the expression. By contrast, for loop statements never localize their variables to the statement block in any Python.\n\nIn 3.X, exception reference variables are local to that except block, and in fact are removed when the block is exited (even if you’ve used it earlier in your code!).\n\nAlthough the LEGB rule is used to resolve\nnames used in both the top level of a class itself as well as the top level of method functions nested within it, classes themselves are skipped by scope lookups—their names must be fetched as object attributes.\n\n### The global/nonlocal Statement\nThe global statement consists of the keyword global, followed by one or more names separated by commas. All the listed names will be mapped to the enclosing module’s scope when assigned or referenced within the function body. \n```\nglobal x\n```\n\nThe name x do not need even exist in the enclosing module\nbefore the function runs; in this case, the first assignment in the function creates x in the module.\n\nIf, on the other hand, X is declared nonlocal within the function in 3.X (only), the assignment changes the name X in the closest enclosing function’s local scope. The name X must have been defined in at least one enclosing function.\n\n```\ndef f1():\nx = 88\ndef f2(x=x): # Remember enclosing scope X with defaults\nprint(x)\nf2()\nf1() # Prints 88\n```\nBecause the second x is evaluated before Python steps into the nested def, it still refers to the x in f1.\n```\ndef func():\nx = 4\naction = (lambda n, x=x: x ** n) # Pass x in manually\nreturn action\n```\nLoop variables may require defaults, not scopes, Compare\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Tries to remember each i\nacts.append(lambda x: i ** x) # But all remember same last i!\nreturn acts\n```\nwith\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Use defaults instead\nacts.append(lambda x, i=i: i ** x) # Remember current i\nreturn acts\n```\nBecause defaults are implemented as single objects attached to functions, mutable defaults retain state from call to call, rather than being initialized anew on each call.\n\nUnlike global, nonlocal names must already exist in the enclosing function’s scope when declared. In fact, they are checked at function definition time before either an enclosing or nested function is called.\n\nNonlocal both allows assignment to names in enclosing function scopes and limits scope lookups for such names to enclosing defs.\n\nPython uses naming conventions in both 2.X and 3.X that ensure that the arbitrary names you assign as function attributes won’t clash with names related to internal implementation.\n\nTo summarize: globals, nonlocals, classes, and function attributes all offer changeable state-retention options.\n\n## Arguments\nIn Python 2.X, it’s also possible to automatically unpack tuples in arguments passed to a function.\n```\ndef f((a,(b,c)))\n```\nThis def syntax is no longer supported in Python 3.X. Instead, code this function as:\n```\ndef f(T): (a, (b, c)) = T\n```\nTuple unpacking argument syntax is also disallowed by 3.X in lambda\nfunction argument lists. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.X for loops targets\n\nBy default, arguments are matched by position, from left to right, and you must pass exactly as many arguments as there are argument names in the function header.\n\n![Table 18-1](../.pastes/2018-09-04-20-04-02.png)\n\nIn a function call, arguments must appear in this order: any positional arguments or the  *iterable form, followed by any keyword arguments or the **dict form. If we see *iterable and **dict as being unpacked to positional arguments and keyword arguments, the order becomes: any positional arguments, followed by any keyword arguments. In a broad sense, there are only two arguments: positional and keyword.\n```\ndef foo(a,b,c,d,e,f,g):\n  print('ok')\nb=[2]\nx = {'d':4,'e':5}\ny = {'f':6}\nfoo(1,*b,3,**x,g=7,**y)  //ok\n```\n> In a function header, we use the term \"parameter\" instead of \"argument\"\n\nIn a function header, parameters must appear in this order: any normal parameter(name); followed by any default parameters (name=value); followed by the *name (or \\* in 3.X) form; followed by any name or name=value keyword-only arguments (in 3.X); followed by the **name form\n\nWe can use a * character by itself in the arguments list to indicate that a function does not accept a variable-length argument list but still expects all arguments following the * to be passed as keywords.\n\nThe *name=value* form has two meaning:\n- before the form *name, it's positional with default value\n- after the form *name, it's keyword-only with default value\n\nThere can be at most one *name parameter, which collects all remaining positional arguments (including those in *iterabe). Similarly, There can be at most one *\\*dict parameter, which collects all remaining keyword arguments (including those in *\\*dict arguments).\n\n```\ndef foo(a,b=3,*c,d,**e):\n    print(b,e)\nx = [3,4]\ny = {'d':5,'e':6,'f':7}\nfoo(1,2,*x,**y)   # 2 {'e': 6, 'f': 7}\n```\nThe steps that Python internally carries out to match arguments before\nassignment can roughly be described as follows:\n1. Assign nonkeyword arguments by position.\n2. Assign keyword arguments by matching names.\n3. Assign extra nonkeyword arguments to *name tuple.\n4. Assign extra keyword arguments to **name dictionary.\n5. Assign default values to unassigned arguments in header.\n\n> Note that in both function call and header, the *name = value* form are not assignments.\n\nThe default parameters are attached to function objects, if you code\na default to be a mutable object (e.g., def f(a=[])), the same, single\nmutable object is reused every time the function is later called—even if\nit is changed in place within the function.\n\nBelow is a tracer function example:\n```\ndef tracer(func, *pargs, **kargs): # Accept arbitrary arguments\n  print('calling:', func.__name__)\n  return func(*pargs, **kargs) # Pass along arbitrary arguments\n```\n\n## Advanced Function Topics\nIn fact, recursion is not used nearly as often in Python as in\nmore esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural.\n\nOn the other hand, recursion—or equivalent explicit stack-based algorithms we’ll meet shortly—can be required to traverse arbitrarily shaped structures.\n\nAlso note that standard Python limits the depth of its runtime call stack—crucial to recursive call programs—to trap infinite recursion errors. To expand it, use the **sys** module:\n```\n>>> sys.getrecursionlimit() # 1000 calls deep default\n1000\n>>> sys.setrecursionlimit(10000) # Allow deeper nesting\n>>> help(sys.setrecursionlimit) # Read more about it\n```\n\n### Function attributes and annotations\n```\n>>> func.__code__\n>>> func.__code__.co_varnames\n```\nPython’s own implementation-related data stored on functions follows naming conventions that prevent them from clashing with the more arbitrary attribute names you might assign yourself. In 3.X, all function internals’ names have leading and trailing double underscores (“_\\_X__”);\n\nAttributes are related to objects instead of scopes (and must be referenced through the function name within its code).\n\nPython provides special syntax for specifying annotations, but it doesn’t do anything with them itself; annotations are completely optional, and when present are simply attached to the function object’s __annotations__ attribute for use by other tools. Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values.\n```\n>>> def func(a: 'spam', b: (1, 10), c: float) -> int:\nreturn a + b + c\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'c': <class 'float'="">, 'b': (1, 10), 'a': 'spam', 'return': <class 'int'="">}\n```\n\nFinally, note that annotations work only in def statements, not lambda expressions.\n\n- **lambda** is an expression, not a statement.\n- lambda’s body is a single expression, not a block of statements.\n- Defaults work on lambda arguments, just like in a def.\n- The code in a lambda body also follows the same scope lookup rules as code inside a def. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule)\n\n```\n>>> ((lambda x: (lambda y: x + y))(99))(4)\n103\n```\n\nuseful library: functools, operator\n\n## Comprehensions and Generations\nmap calls can be twice as fast as equivalent for loops, and list comprehensions are often faster than map calls.\n\nGenerator function vs. Generator vs. Generator expression\n- *send* advances to the next item  \n- *yield* is now an expression form, it must be enclose in parentheses unless it's the only item on the right ride of the assignment statement.\n- methods: *throw*, *close*\n- *yield from*\n\nGenerator expressions may also run slightly slower than list comprehensions in practice, so they are probably best used only for very large result sets, or applications that cannot wait for full results generation.\n\nA subtle but important point: both generator functions and generator expressions are their own iterators and thus support just one active iteration.\n\nPython 3.X localizes loop variables in all four forms—temporary loop variable names in generator, set, dictionary, and list comprehensions are local to the expression.\n\nIn general, list comprehensions are usually the quickest of the bunch; map beats list comprehensions in Python only when all tools must call functions; for loops tend to be slower than comprehensions; and generator functions and expressions are slower than comprehensions by a constant factor. Under\n\n## The benchmarking Interlude\nTimeing modules: time, timer, profile, timeit, pystone.py\n\n#  Part V. Modules and Packages\nModules are processed with two statements and one important function:\n- import: Lets a client (importer) fetch a module as a whole\n- from: Allows clients to fetch particular names from a module\n- imp.reload (reload in 2.X): Provides a way to reload a module’s code without stopping Python\n\nIn Python, cross-file module linking is not resolved until such import statements are executed at runtime; their net effect is to assign module names—simple variables like b—to loaded module objects. In fact, the module name used in an import statement serves two purposes: it identifies the external file to be loaded, but it also becomes a variable assigned to the loaded module.\n\nSimilarly, objects defined by a module are also created at runtime, as the import is executing: import literally runs statements in the target file one at a time to create its contents.\n\nIn python, imports perform three distinct steps the first time a program imports a given file:\n1. Find the module’s file.\n2. Compile it to byte code (if needed).\n3. Run the module’s code to build the objects it defines.\n\nBear in mind that all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named **sys.mod** ules and checking there at the start of an import operation. If the module is not present, a three-step process begins. (see **imp.reload**)\n> Python keeps already imported modules in the built-in **sys.modules** dictionary so it can keep track of what’s been loaded.\n\nNotice that compilation happens when a file is being imported. Because of this, you will not usually see a .pyc byte code file for the top-level file of your program, unless it is also imported elsewhere—only imported files leave behind .pyc files on your machine.\n\n### The Module Search Path\nRoughly, Python’s module search path is composed of the concatenation of these major components, some of which are preset for you and some of which you can tailor to tell Python where to look:\n1. The home directory of the program (subdirectories not included)\n2. PYTHONPATH directories (if set)\n3. Standard library directories\n4. The contents of any .pth files (if present)\n5. The site-packages home of third-party extensions\n\nUltimately, the concatenation of these four components becomes **sys.path**, a mutable list of directory. The first and\nthird elements of the search path are defined automatically. Because Python searches the concatenation of these components from first to last, though, the second and fourth elements can be used to extend the path to include your own source code directories.\n\nBy modifying the sys.path list, you can modify the search path for all future imports made in a program’s run. Such changes last only for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path—the first per user, and the second per installation.\n\nPython automatically selects any type that matches a module’s name. For same names with different extensions, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations. \n\nBy using import hooks, archived files are automatically extracted at import time when a  .zip file is selected from the module import search path.\n\nFor details, see the builtin **importlib._\\_import__** function\n\nThird-party extensions for Python typically use the **distutils** tools in the standard library to automatically install themselves, so no path configuration is required to use their code.\n\nSystems that use distutils generally come with a setup.py script, which is run to install them; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\site-packages subdirectory of the Python install tree, wherever that resides on the target machine).\n\n## Module Coding Basics\n### Module Filenames\nThe .py is technically optional for top-level files that will be run but not imported.\n\nIn fact, both the names of module files and the names of directories used in\npackage imports (discussed in the next chapter) must conform to the rules for variable names presented.\n\n**import** fetches the module as a whole, so you\nmust qualify to fetch its names; in contrast, **from** fetches (or copies) specific names out of the module.\n\nIn Python 3.X, the from ...* statement form described here can be used\nonly at the top level of a module file, not within a function.\n\nJust like def, import and from are executable statements, not compile-time declarations. They may be nested in if tests, to select among options; appear in function defs, to be loaded only on calls (subject to the preceding note); be used in try statements, to provide defaults; and so on.\n```\n>>> from small import x, y # Copy two names out\n>>> x = 42 # Changes local x only\n>>> y[0] = 42 # Changes shared mutable in place\n```\n\nAt least conceptually, a from statement like this one:\n```\nfrom module import name1, name2 # Copy these two names out (only)\n```\nis equivalent to this statement sequence:\n\n```\nimport module # Fetch the module object\nname1 = module.name1 # Copy names out by assignment\nname2 = module.name2\ndel module # Get rid of the module name\n```\n\nThe **from** always imports the entire module into memory if it has not yet been imported, regardless of how many names it copies out of the file. There is no way to load just part of a module file.\n\nMoreover, the from module import * form really can corrupt namespaces and make names difficult to understand, especially when applied to more than one file.\n\nProbably the best real-world advice here is to generally prefer import to from for simple modules, to explicitly list the variables you want in most from statements, and to limit the from * form to just one import per file.\n\nThe **as** extension works in both import and from as a simple renaming tool.\n\nIn fact, internally, module namespaces are stored as dictionary objects.\n\nThe LEGB scope rule applies only to bare, unqualified names—it may be used for the leftmost name in a name path, but later names after dots search specific objects instead.\n\nlexical scoping notion—in Python, the scopes surrounding\na piece of code are completely determined by the code’s physical position in your file. Scopes are never influenced by function calls or module imports.\n\nimport operations never give upward visibility to code in imported files\n—an imported file cannot see names in the importing file. In some sense, although imports do not nest namespaces upward, they do nest downward.\n```\nprint(mod2.mod3.X) # Nested mod3's X\n```\n\n### Reloading Modules\nThe **reload** function forces an already loaded module’s code to be reloaded and rerun. Assignments in the file’s new code change the existing module object in place.\n\n> Note that reload currently only works on modules\nwritten in Python;\n\nBecause reload expects an object, a module must have been previously imported successfully before you can reload it.\n\nWhen you call reload, Python rereads the module file’s source code and reruns its toplevel statements. Perhaps the most important thing to know about reload is that it changes a module object in place; it does not delete and re-create the module object.\n- Reloads impact all clients that use **import** to fetch modules\n- Reloads impact future from clients only. Clients that used from to fetch attributes in the past won’t be affected by a reload; they’ll still have references to the old objects fetched before the reload.\n- Reloads apply to a single module only. You must run them on each module you wish to update, unless you use code or tools that apply reloads transitively.\n\n## Module Packages\nDotted package  \n**from package import item**: the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable.\n**import item.subitem.subitem**: each item except for the last must be a package; the last item can be a module or a package but can't be a class or function or variable defined in the previous item.\n\nTow kinds of imports:\n- absolute imports\n- relative imports\n\nIn sum, Python imports select between relative (in the containing directory) and absolute (in a directory on sys.path) resolutions as follows:\n- Dotted imports: from . import m  \nAre relative-only in both 2.X and 3.X\n- Nondotted imports: import m, from m import x  \nAre relative-then-absolute in 2.X, and absolute-only in 3.X\n\nNote that relative imports are based on the name of the current module. Since the name of the main module is always \"__main__\", modules intended for use as the main module of a Python application must always use absolute imports.\n\nPython 3.3 adds another flavor to modules: *namespace packages*.\n\nPackages are just a special kind of module. Specifically, any module that contains a `__path__` attribute is considered a package.\n\nTwo kinds of packages:\n* regular packages\n* namespace packages",[[1539613860644,["yonggu@yongs-MacBook-Air.local",[[-1,406,"...pastes/"]],[416,416],[406,406]]],[1539613861607,["yonggu@yongs-MacBook-Air.local",[[-1,406,""],[1,406,"R"],[-1,938," "],[1,939," "],[-1,979," "],[1,980," "],[-1,1002," "],[1,1003," "],[-1,1068," "],[1,1069," "],[-1,1302," "],[1,1303," "],[-1,1314," "],[1,1315," "],[-1,1361," "],[1,1362," "],[-1,1411," "],[1,1412," "],[-1,1643," "],[1,1644," "],[-1,2296," "],[1,2297," "],[-1,3117," "],[1,3118," "],[-1,3342," "],[1,3343," "],[-1,3681," "],[1,3682," "],[-1,3976," "],[1,3977," "],[-1,4414," "],[1,4415," "],[-1,4448," "],[1,4449," "],[-1,4563," "],[1,4564," "],[-1,4848," "],[1,4849," "],[-1,4859," "],[1,4860," "],[-1,4988," "],[1,4989," "],[-1,4999," "],[1,5000," "],[-1,5635," "],[1,5636," "],[-1,5896," "],[1,5897," "],[-1,5958," "],[1,5959," "],[-1,6264," "],[1,6265," "],[-1,6282," "],[1,6283," "],[-1,6315," "],[1,6316," "],[-1,6334," "],[1,6335," "],[-1,6546," "],[1,6547," "],[-1,6647," "],[1,6648," "],[-1,7557," "],[1,7558," "],[-1,8492," "],[1,8493," "],[-1,8507," "],[1,8508," "],[-1,8549," "],[1,8550," "],[-1,8634," "],[1,8635," "],[-1,8658," "],[1,8659," "],[-1,8707," "],[1,8708," "],[-1,8737," "],[1,8738," "],[-1,8792," "],[1,8793," "],[-1,8859," "],[1,8860," "],[-1,8913," "],[1,8914," "],[-1,10182," "],[1,10183," "],[-1,10237," "],[1,10238," "],[-1,10626," "],[1,10627," "],[-1,10654," "],[1,10655," "],[-1,10739," "],[1,10740," "],[-1,10885," "],[1,10886," "],[-1,11277," "],[1,11278," "],[-1,11343," "],[1,11344," "],[-1,11471," "],[1,11472," "],[-1,12143," "],[1,12144," "],[-1,12234," "],[1,12235," "],[-1,12309," "],[1,12310," "],[-1,12540," "],[1,12541," "],[-1,12573," "],[1,12574," "],[-1,12699," "],[1,12700," "],[-1,12737," "],[1,12738," "],[-1,12835," "],[1,12836," "],[-1,12992," "],[1,12993," "],[-1,13055," "],[1,13056," "],[-1,13157," "],[1,13158," "],[-1,13333," "],[1,13334," "],[-1,13345," "],[1,13346," "],[-1,13502," "],[1,13503," "],[-1,13677," "],[1,13678," "],[-1,13724," "],[1,13725," "],[-1,13884," "],[1,13885," "],[-1,14230," "],[1,14231," "],[-1,14374," "],[1,14375," "],[-1,14548," "],[1,14549," "],[-1,14564," "],[1,14565," "],[-1,14720," "],[1,14721," "],[-1,14782," "],[1,14783," "],[-1,15955," "],[1,15956," "]],[406,406],[407,407]]],[1539613862199,["yonggu@yongs-MacBook-Air.local",[[-1,406,"R"]],[407,407],[406,406]]],[1539613869838,["yonggu@yongs-MacBook-Air.local",[[1,406,"$Resources"]],[406,406],[416,416]]],[1539613895504,["yonggu@yongs-MacBook-Air.local",[[-1,407,"R"]],[408,408],[407,407]]],[1539613895732,["yonggu@yongs-MacBook-Air.local",[[1,407,"r"]],[407,407],[408,408]]],[1539613897890,["yonggu@yongs-MacBook-Air.local",[[-1,415,"s"]],[416,416],[415,415]]],[1539613910728,["yonggu@yongs-MacBook-Air.local",[[-1,2626,"../.pastes"],[1,2636,"$resource"]],[2626,2636],[2635,2635]]],[1539613916826,["yonggu@yongs-MacBook-Air.local",[[-1,3042,"../.pastes"],[1,3052,"$resource"]],[3042,3052],[3051,3051]]],[1539613925835,["yonggu@yongs-MacBook-Air.local",[[-1,6708,"../.pastes"],[1,6718,"$resource"]],[6708,6718],[6717,6717]]],[1539613931854,["yonggu@yongs-MacBook-Air.local",[[-1,6757,"../.pastes"],[1,6767,"$resource"]],[6757,6767],[6766,6766]]],[1539613947676,["yonggu@yongs-MacBook-Air.local",[[-1,9189,"../.pastes"],[1,9199,"$resource"]],[9189,9199],[9198,9198]]],[1539614003816,["yonggu@yongs-MacBook-Air.local",[[-1,10589,"../.pastes"],[1,10599,"$resource"]],[10589,10599],[10589,10598]]],[1539614005118,["yonggu@yongs-MacBook-Air.local",[[-1,11995,"../.pastes"],[1,12005,"$resource"]],[11995,12005],[11995,12004]]],[1539614006339,["yonggu@yongs-MacBook-Air.local",[[-1,12043,"../.pastes"],[1,12053,"$resource"]],[12043,12053],[12043,12052]]],[1539614007260,["yonggu@yongs-MacBook-Air.local",[[-1,12325,"../.pastes"],[1,12335,"$resource"]],[12325,12335],[12325,12334]]],[1539614008351,["yonggu@yongs-MacBook-Air.local",[[-1,16041,"../.pastes"],[1,16051,"$resource"]],[16041,16051],[16041,16050]]],[1539614009775,["yonggu@yongs-MacBook-Air.local",[[-1,30749,"../.pastes"],[1,30759,"$resource"]],[30749,30759],[30749,30758]]],[1539614011118,["yonggu@yongs-MacBook-Air.local",[[-1,7358,"../.pastes"],[1,7368,"$resource"]],[7358,7368],[7358,7367]]],[1539614012452,["yonggu@yongs-MacBook-Air.local",[[-1,9236,"../.pastes"],[1,9246,"$resource"]],[9236,9246],[9236,9245]]]],null,"yonggu@yongs-MacBook-Air.local"],["1e8a7d55-55f9-4183-ab64-20984d1ef037",1565834637276,"---\ntitle: Notes for Learning Python 5th\n---\n[[toc]]\n# Types and Operations\nObjects are pieces of memory, with values and sets of associated operations. Everything we process in Python programs is a kind of obj \n\nThe Python Conceptual Hierarchy:\n1. Programs are composed of modules.\n2. Modules contain statements.\n3. Statements contain expressions.\n4. Expressions create and process objects.\n\n![Table 4-1]($resource/2018-09-03-12-05-36.png)\nIn formal terms, this means that Python is dynamically typed , a model that keeps track of types for you automatically instead of requiring declaration code, but it is also strongly typed, a constraint that means you can perform on an object only operations that are valid for its type.\n\n## Core Types\nImmutable: number, string, tuple, bytes \nMutable: list, dictionary, set, bytearray\n\nPrimitive: number  \nCollection:\n* Sequence: string, tuple, bytes, list,  bytearray\n* Mapping: dictionary, set\n\nbytearray  is a distinct hybrid of immutable bytes  strings (whose b'...'  syntax is required in 3.X and optional in 2.X) and mutable lists  (coded and displayed in [] ).\n\ngeneric operations that span multiple types show up as built-in functions or expressions (e.g. `len(X)` , `X[0]` ), but type-specific operations are method calls (e.g., `aString.upper()` ).\n\nBoth `dir`  and `help`  also accept as arguments either a real object  (like our string S) , or the name of a data type  (like str , list , and dict ).\n\nAs a notable difference, Python 2.X allows its normal and Unicode strings to be mixed in expressions as long as the normal string is all ASCII; in contrast, Python 3.X has a tighter model that never  allows its normal and byte strings to mix without explicit conversion.\n\nNone of the string object’s own methods support pattern-based text processing.\n\nUnlike out-of-bounds assignments in lists, which are forbidden, assignments to new dictionary keys create those keys, fetching a nonexistent key is still a mistake. (Use the get() method)\n\nA file’s contents are always a string in your script, regardless of\nthe type of data the file contains:\n\n```python\n>>> for line in open('data.txt'): print(line)\n```\n\t\nText files represent content as normal str strings and perform\nUnicode encoding and decoding automatically when writing and reading data, while  binary files represent content as a special bytes string and allow you to access file content unaltered.\n\nSets are unordered collections of unique and immutable objects.\nDecimal, Fraction, booleans\n\nAs you’ll learn, in Python, we code to object interfaces (operations supported), not to types.\n\n## Numbers\n![Table 5-1]($resource/2018-09-03-12-09-34.png)\n\nFloating-point numbers are implemented as C “doubles” in standard CPython, and therefore get as much precision as the C compiler used to build the Python interpreter gives to doubles.\n\nbuilt-in calls: hex(I), oct(I), bin(I), int(str,base), X.bit_length(),round(X), X.as_integer_ratio()\n\nInternally, complex numbers are implemented as pairs of floating-point numbers\n\n![Table 5-2]($resource/2018-09-03-12-10-38.png)\n\nComparison operators may be chained: X < Y < Z  produces the same result as X < Y and Y < Z .\n```python\n>>> 1 == 2 < 3 # Same as: 1 == 2 and 2 < 3\nFalse    # Not same as: False < 3 (which means 0 < 3, which is true!)\n```\n\t\nIn recent Pythons, the slice expression X[I:J:K]  is equivalent to indexing with a slice object: X[slice(I, J, K)].\n\nIn Python 3.X, nonnumeric mixed-type magnitude comparisons are not allowed and raise exceptions; this includes sorts by proxy.\n\n* Operators lower in the table have higher precedence, and so bind more tightly in mixed expressions.\n* Operators in the same row in Table 5-2  generally group from left to right when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right).\n\nBesides mixing operators in expressions, you can also mix numeric types: \nin mixed-type numeric expressions, Python first converts operands up  to the type of the most complicated operand, and then performs the math on same-type operands. Python ranks the complexity of numeric types like so: integers are simpler than floating point numbers, which are simpler than complex numbers. \nIn general, Python does not convert across any other type boundaries automatically. Adding a string to an integer, for example, results in an error, unless you manually convert one or the other.\n\n In 3.X, the / now always performs  true division, returning a float result that includes any remainder, regardless of operand types. The // performs  floor division, which truncates the remainder and returns an integer for integer operands or a float if any operand is a float.\n\nThe // operator truncates the result down to its floor, which means the closest whole number below the true result.\n\nFrozenset\n\nInternally, the names True  and False  are instances of bool , which is in turn just a subclass (in the object oriented sense) of the built-in integer type int . True  and False  behave exactly like the integers 1 and 0, except that they have customized printing logic.\n```\n>>> True + 4 # (Hmmm)\n5\n```\n\t\nNumpy, Scipy\n\t\nThe dynamic typing\nA variable never has any type information or constraints associated with it. The notion of type lives with objects, not names. Variables are generic in nature; they always simply refer to a particular object at a particular point in time.\n\nVariables always link to objects and never to other variables, but larger objects may link to other objects (for instance, a list object has links to the objects it contains).\nThese links from variables to objects are called references  in Python—that is, a reference is a kind of association, implemented as a pointer in memory\n\nTechnically speaking, objects have more structure than just enough space to represent their values. Each object also has two standard header fields: a type designator  used to mark the type of the object, and a reference counter  used to determine when it’s OK to reclaim the object.\n\nreference counter, cyclic reference\n\tsys.getrefcount(X)\n\nIf a[:], a[k] appears in expression, they are copied. e.g. after b=a[:3], b refers to a new object.\nIf a[:], a[k] appears in left side of assignment, they referred to the original object. e.g.  after a=[0,1,2]   a[:] = [0,1], a becomes [0,1]\n\n Because everything  seems to work by assignment and references\nin Python, a basic understanding of this model is useful in many different contexts. As you’ll see, it works the same in assignment statements, function arguments, for  loop variables, module imports, class attributes, and more. The good news is that there is just one  assignment model in Python;\n\nweakref\n\n## String\n![]($resource/2018-09-03-12-13-34.png)\n\n![Table 7-1]($resource/2018-09-03-16-34-23.png)\nString literal forms:\n* Single quotes: 'spa\"m'\n* Double quotes: \"spa'm\"\n* Triple quotes: '''... spam ...''' , \"\"\"... spam ...\"\"\"\n* Escape sequences: \"s\\tp\\na\\0m\"\n* Raw strings: r\"C:\\new\\test.spm\"\n* Bytes literals in 3.X and 2.6+ (see Chapter 4 , Chapter 37 ): b'sp\\x01am'\n* Unicode literals in 2.X and 3.3+ (see Chapter 4 , Chapter 37 ): u'eggs\\u0020spam'\n\nIn fact, 3.X defines str strings formally as sequences of Unicode code\npoints, not bytes, to make this clear. There’s more on how strings are stored internally in Chapter 37 if you care to know.\n\n![Table 7-2]($resource/2018-09-03-12-14-52.png)\n\nSome escape sequences allow you to embed absolute binary values into the characters of a string.\n\nPython keeps both the string’s length and text in memory. In fact, no character terminates a string in Python\n\nNotice that Python displays nonprintable characters in hex, regardless of how they were specified.\n\nThat is, r\"...\\\" is not a valid string literal—a raw string cannot end in\nan odd number of backslashes. If you need to end a raw string with a\nsingle backslash, you can use two and slice off the second (r'1\\nb\\tc\\\\'[:-1]), tack one on manually (r'1\\nb\\tc' + '\\\\'), or skip the raw string syntax and just double up the backslashes in a normal string ('1\\\\nb\\\\tc\\\\').\n\n\n```\n>>> menu = \"\"\"spam # comments here added to string!\n... eggs # ditto\n... \"\"\"\n>>> menu\n'spam # comments here added to string!\\neggs # ditto\\n'\n>>> menu = (\n... \"spam\\n\" # comments here ignored\n... \"eggs\\n\" # but newlines not automatic\n... )\n>>> menu\n'spam\\neggs\\n'\n```\n\n\nbuilt-in tool: `ord()` `chr()`\n\nThe method call expression: object.method(arguments) is evaluated from left to right—Python will first fetch the method  of the object  and then\ncall it, passing in both object and the arguments\n\nstring formatting expressions and string formatting method calls\n Technically, the format  built-in runs the subject object’s `__format__`  method, which the str.format  method does internally for each formatted item.\nThe %  expressions tend to be a bit simpler and more concise; the format  method has a handful of advanced features that the %  expression does not, but even more involved formatting still seems to be essentially a draw in terms of complexity.\n```\n>>> from formats import commas, money\n```\nTypes Share Operation Sets by Categories:\n* numbers\n* sequences\n* mappings\n\n## Lists and Dictionaries\n\n![]($resource/2018-09-03-12-17-54.png)\n![Table 8-1]($resource/2018-09-03-16-35-48.png)\nSlice assignment, the last operation in the preceding example, replaces an entire section of a list in a single step. Because it can be a bit complex, it is perhaps best thought of as a combination of two steps:\n1. Deletion. The slice you specify to the left of the = is deleted.\n2. Insertion. The new items contained in the iterable object to the right of the = are inserted into the list on the left, at the place where the old slice was deleted.\nNote, L[2:5]=L[3:6], for instance, works fine because the value to be inserted is fetched before the deletion\nhappens on the left.\n```\n>>> L = [1]\n>>> L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front\n>>> L\n[2, 3, 4, 1]\n>>> L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end\n>>> L\n[2, 3, 4, 1, 5, 6, 7]\n>>> L.extend([8, 9, 10]) # Insert all at end, named method\n>>> L\n[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]\n```\n\t\nThe effect of `L.append(X)`  is similar to `L+[X]`, but while the former changes L  in place, the latter makes a new list.\n\nIn Python 3.X, this has changed: magnitude comparison of mixed types\nraises an exception instead of falling back on the fixed cross-type ordering.\n\nL.sort() vs. sorted\nbuilt-in tools: reversed\n\nLike lists, dictionaries store object references (not copies, unless you ask for them explicitly)\n\n![Table 8-2]($resource/2018-09-03-12-18-20.png)\n\nkeys  in 3.X returns an iterable  object, instead of a physical list\nUnlike lists, however, whenever you assign a new  dictionary key (one that hasn’t been assigned before) you create a new entry in the dictionary.\n\nIn 3.X the dictionary keys , values , and items  methods all return view objects , whereas in 2.X they return actual result lists. \nBesides being iterable, dictionary views also retain the original order of dictionary components, reflect future changes to the dictionary, and may support set operations. Unlike 2.X’s list results, though, dictionary views in 3.X are not carved in stone when created—they dynamically reflect future changes  made to the dictionary after the view object has been created:\n\n In set operations, views may be mixed with other views, sets, and dictionaries; dictionaries\nare treated the same as their keys  views in this context:\n```\n>>> D = {'a': 1, 'b': 2, 'c': 3}\n>>> D.keys() & D.keys() # Intersect keys views\n{'b', 'c', 'a'}\n>>> D.keys() & {'b'} # Intersect keys and set\n{'b'}\n>>> D.\n```\n\n```\n>>> Ks.sort()\nAttributeError: 'dict_keys' object has no attribute 'sort'\n```\nTo work around this, in 3.X you must either convert to a list manually or use the\nsorted call (introduced in Chapter 4 and covered in this chapter) on either a keys view\nor the dictionary itself:\n\nOrderedDict\n\n## Tuples, files and everything else\n![]($resource/2018-09-03-16-36-56.png)\n![Table 9-1]($resource/2018-09-03-12-18-57.png)\n\nAs you can see, named tuples are a tuple/class/dictionary hybrid\n (In short, named tuples build new classes that extend the tuple type, inserting a property  accessor method for each named field that maps the name to its position)\n \n![Table 9-2]($resource/2018-09-03-12-03-26.png)\n\nEmpty lines in the file come back as strings containing just a newline character, not as empty strings.\n```\n>>> myfile.readline() # Empty string: end-of-file\n''\n```\n\t\n* Text files  represent content as normal str  strings, perform Unicode encoding and decoding automatically, and perform end-of-line translation by default.\n* Binary files  represent content as a special bytes  string type and allow programs to access file content unaltered.\n\npickle, shelve, json, struct\n\n In fact, when nested objects are present, Python automatically\ntraverses data structures to apply comparisons from left to right, and as deeply as\nneeded.\n\n More specifically, Python compares types as follows:\n- Numbers  are compared by relative magnitude, after conversion to the common highest type if needed.\n- Strings  are compared lexicographically (by the character set code point values returned by `ord` ), and character by character until the end or first mismatch (\"abc\"< \"ac\" ).\n- Lists  and tuples  are compared by comparing each component from left to right, and recursively for nested structures, until the end or first mismatch ([2] > [1, 2] ).\n- Sets  are equal if both contain the same items (formally, if each is a subset of the other), and set relative magnitude comparisons apply subset and superset tests.\n- Dictionaries  compare as equal if their sorted (key, value)  lists are equal. Relative magnitude comparisons are not supported for dictionaries in Python 3.X, but they work in 2.X as though comparing sorted (key, value)  lists.\n- Nonnumeric mixed-type magnitude comparisons (e.g., 1 < 'spam' ) are errors in Python 3.X. They are allowed in Python 2.X, but use a fixed but arbitrary ordering rule based on type name string. By proxy, this also applies to sorts, which use comparisons internally: nonnumeric mixed-type collections cannot be sorted in 3.X.\n\nPython 3.X  disallows mixed-type magnitude testing, except numeric types.\n\nMore generally, the notions of true and false are intrinsic properties of every  object in Python—each object is either true or false, as follows:\n- Numbers are false if zero, and true otherwise.\n- Other objects are false if empty, and true otherwise.\n\n That is, *None*  is something, not nothing (despite its name!)—it is a real object and a real piece of memory that is created and given a built-in name by Python itself.\n\n In fact, even types themselves are an object type in Python.\n Calls to these names are really object constructor calls, not simply conversion functions, though you can treat them as simple functions for basic usage.\n\nFor classic classes in Python 2.X, all class instances are instead of the type “instance,” and we must compare instance `__class__` attributes to compare their types meaningfully.\n\nRepetition Adds One Level Deep\n```python\n>>> L = [4, 5, 6]\n>>> X = L * 4 # Like [4, 5, 6] + [4, 5, 6] + ...\n>>> Y = [L] * 4 # [L] + [L] + ... = [L, L,...]\n```\n\t\nIf you remember that repetition, concatenation, and slicing copy only the top level of their operand objects, these sorts of cases make much more sense\n\nBeware of Cyclic  Data Structure\n```python\n>>> L = ['grail'] # Append reference to same object\n>>> L.append(L) # Generates cycle in object: [...]\n>>> L\n['grail', [...]]\n```\n\n# Statements and Syntax\n## Assignments, Expressions, and Prints\n- Assignments create object references. (i.e. link a name with an object) They always create references to objects instead of copying the objects.\n- Names are created when first assigned.\n- Names must be assigned before referenced.\n\nModule imports, function and class definitions, for  loop variables, and function arguments are all implicit assignments.\n\n![Table 11-1]($resource/2018-09-03-13-40-51.png)\n\nsequence assignment—any sequence of names can be\nassigned to any sequence of values, and Python assigns the items one at a time by position. In fact, the original tuple and list assignment forms in Python have been generalized to accept any type of sequence (really, iterable) on the right as long as it is of the same length as the sequence on the left.\n\nMultiple-target assignment: Python assigns a reference to the same object (the object farthest to the right) to all the targets on the left.\n\nIn tuple/list assignment, Python creates a temporary tuple that saves the original values of the variables on the right before assigning.\n\nwe can even assign nested sequences, and Python unpacks their parts according to their shape, as expected. The sequence-nesting shape of the object on the left must match that of the object on the right.\n> This nested tuple (really, sequence) unpacking\nassignment form works for function argument lists in Python 2.X (though not in 3.X)\n\nIn short, a single starred name, *X, can be used in the assignment target in order to specify a more general matching against the sequence—the starred name is assigned a list, which collects all items in the sequence not assigned to other names. In fact, the starred name can appear anywhere in the target.\n> This is similar in spirit to slicing, but not exactly the same—a sequence unpacking assignment always returns a list for multiple matched items, whereas slicing returns a sequence of the same type as the object sliced\n```\n>>> a, *b = 'spam'\n>>> a, b\n('s', ['p', 'a', 'm'])\n>>> S[0], S[1:] # Slices are type-specific, * assignment always returns a list\n('s', 'pam')\n```\n\nFinally, errors can still be triggered if there is more than one starred name, if there are too few values and no star (as before), and if the starred name is not itself coded inside a sequence:\n```\n>>> *a = seq\nSyntaxError: starred assignment target must be in a list or tuple\n```\n\nFor augmented assignments, inplace operations may be applied for mutable objects as an optimization.\n```\n>>> L = [1, 2]\n>>> L = L + [3] # Concatenate: slower\n>>> L\n[1, 2, 3]\n>>> L.append(4) # Faster, but in place\n>>> L\n[1, 2, 3, 4]\n>>> L += [9, 10] # Mapped to L.extend([9, 10])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\nNote however, that because of this equivalence += for a list is not exactly the same as a + and = in all cases—for lists += allows arbitrary sequences (just like extend), but concatenation normally does not:\n```\n>>> L = []\n>>> L += 'spam' # += and extend allow any sequence, but + does not!\n>>> L\n['s', 'p', 'a', 'm']\n>>> L = L + 'spam'\nTypeError: can only concatenate list (not \"str\") to list\n```\n> Although Python now supports statements like X += Y, it still does not\nhave C’s auto-increment/decrement operators (e.g., X++, −−X).\n\n### Naming\nFor portability, case also matters in the names of imported module files, even on platforms where the filesystems are case-insensitive.\n\nTrue, False, and None, are somewhat unusual in meaning—they also appear in the built-in scope of Python described in Chapter 17, and they are technically names assigned to objects.\n\nNames that begin with a single underscore (_X) are not imported by a from module import * statement\n\nNames that begin with two underscores and do not end with two more (__X) are localized (“mangled”) to enclosing classes.\n\n### Expression Statements\nIn Python, you can use an expression as a statement, too. Expressions are commonly used as statements in two situations:\n- For calls to functions and methods\n- For printing values at the interactive prompt\n\nA statement that is not an expression must generally appear on a line all by itself, not nested in a larger syntactic structure. For example, Python doesn’t allow you to embed assignment statements (=) in other expressions. Besides, C assignments return the value assigned, but Python assignments are just statements, not expressions.\n\nExpression statements are often used to run list methods that change a list in place:\n```\n>>> L = L.append(4) # But append returns None, not L\n>>> print(L) # So we lose our list!\nNone\n```\n\nNormally, whether printed output is buffered in memory or not is determined by file; passing a true value to flush forcibly flushes the stream.\n\nBecause the print statement just sends text to the sys.stdout.write method, you can capture printed text in your programs by assigning sys.stdout to an object whose write method processes the text in arbitrary ways\n\n## if Tests and Syntax Rules\nThere is no switch or case statement in Python\n\n* Block and statement boundaries are detected automatically.\n* Compound statements = header + “:” + indented statements. \n* Blank lines, spaces, and comments are usually ignored.\n* Docstrings are ignored but are saved and displayed by tools.\n\nStatements may span multiple lines if you’re continuing an open syntactic\npair.\n\nBoolean operators stop evaluating (“short circuit”) as soon as a result is known. Boolean **and** and **or** operators return a true or false object in Python, not the values True or False\n\nFor `A = Y if X else Z`, Python runs expression Y only if X turns out to be true, and runs expression Z only if X turns out to be false.\n\nWhen defining classes, we can specify their Boolean nature with either the\n__bool__ or __len__ methods.\n\n\n\n##  while and for Loops\nThe optional **else** block run if didn't exit loop with **break**\n\nPython doesn’t have what some languages call a “do until” loop statement. Python has no \"go to\" statement.\n\nPython 3.X (but not 2.X) allows ellipses coded as ... (literally, three consecutive dots) to appear any place an expression can. Because ellipses do nothing by themselves, this can serve as an alternative to the pass statement,\n```\n>>> X = ... # Alternative to None\n>>> X\nEllipsis\n```\n\nAfter the **for** loop, this loop variable normally still refers to the last item visited, which is the last item in the sequence unless the loop exits with a break statement.\n\nEven nested structures may be automatically unpacked this way in a for:\n```\n>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)\n```\n\nIn fact, as a general rule, you should resist the temptation to count things in Python—its iteration tools automate much of the work you do to loop over collections in lower-level languages like C.\n\nbuilt-in tools: range, zip, enumerate\n\nThe zip function is more general than this example suggests. For instance,\nit accepts any type of sequence (really, any iterable object, including files), and it accepts more than two arguments. Moreover, zip truncates result tuples at the length of the shortest sequence when the argument lengths differ.\n\n## Iterations and Comprehensions\n* Iterator vs. Iterable  vs. Iteration tool/context\n* Single scan vs. multiple scan\n\nIn some cases these two objects are the same when only a single scan is supported (e.g., files), and the iterator object is often temporary, used internally by the iteration tool. Moreover, some objects are both an iteration context tool (they iterate) and an iterable object (their results are iterable)—including Chapter 20’s generator expressions, and map and zip in Python 3.X.\n\nWhen the for loop begins, it first obtains an iterator from the iterable object by passing it to the iter built-in function; the object returned by iter in turn has the required next method. The iter function internally runs the __iter__ method, much like `next` and `__next__`.\n\nFor comprehensions, their full syntax allows for any number of **for** clauses, each of which can have an optional associated **if** clause.\n\nKeep in mind, though, that every built-in tool that scans from left to right across objects uses the iteration protocol.\n\nNotice that, unlike map and others, sorted returns an actual list in Python 3.X\ninstead of an iterable.\n\nOne of the fundamental distinctions of Python 3.X is its stronger emphasis on iterators than 2.X. This, along with its Unicode model and mandated new-style classes, is one of 3.X’s most sweeping changes.\n\nUnlike **range**, **map**, **zip**, **filter** are their own iterators—after you step through their results once, they are exhausted.\n\nIn Python 3.X the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time.\n\n## Documentation Interlude\nThe PyDoc system covered here can render a module’s internal documentation as either plain text in a shell, or HTML in a web browser.\n\nThe **help** function: press the space bar to move to the next page, Enter to go to the next line, and Q to quit:\n\nSphinx\n\n# Functions and Generators\n## Function Basics\n* *def* is executable code. it’s legal (and even occasionally useful) to nest def statements inside if statements, while loops, and even other *def*s.\n* *def* creates an object and assigns it to a name. Function objects may also have arbitrary user-defined *attributes* attached to them to record data.\n\nNames are always looked up in *scopes*—places where variables are stored— and assignments bind names to scopes.\n\n>Files must generally be rewound (e.g., with a file.seek(0) or another\nopen) after they have been read to end-of-file once, and so are single-pass iterators\n\n## Scopes\nWhen we talk about the search for a name’s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name’s assignment in your source\ncode determines the scope of the name’s visibility to your code.\n\nBy default, all names assigned inside a function are associated with that function’s namespace, and no other.\n\nLexical scoping:\n- If a variable is assigned inside a def, it is local to that function.\n- If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n- If a variable is assigned outside all defs, it is global to the entire file.\n\nEach module is a global scope, the global scope spans a single file only.\n* Assigned names are local unless declared global or nonlocal\n* All other names are enclosing function locals, globals, or built-ins.\n* Each call to a function creates a new local scope.\n\n> Note `L=X` within a function will classify L as a local, but L.append(X) will not.\n\n### Name Resolution: The LEGB Rule\n- Name assignments create or change local names by default.\n- Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in.\n- Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively.\n\nNote that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup level.\n\nAlso keep in mind that these rules apply only to simple variable names (e.g., spam). Qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here.\n\nThere are technically three more scopes in Python—temporary loop variables in some comprehensions, exception reference variables in some try handlers, and local scopes in class statements\n\nIn 3.X, the loop variables are local to the expression itself in all comprehension forms: generator, list, set, and dictionary. In 2.X, they are local to generator expressions and set and dictionary compressions, but not to list comprehensions that map their names to the scope outside the expression. By contrast, for loop statements never localize their variables to the statement block in any Python.\n\nIn 3.X, exception reference variables are local to that except block, and in fact are removed when the block is exited (even if you’ve used it earlier in your code!).\n\nAlthough the LEGB rule is used to resolve\nnames used in both the top level of a class itself as well as the top level of method functions nested within it, classes themselves are skipped by scope lookups—their names must be fetched as object attributes.\n\n### The global/nonlocal Statement\nThe global statement consists of the keyword global, followed by one or more names separated by commas. All the listed names will be mapped to the enclosing module’s scope when assigned or referenced within the function body. \n```\nglobal x\n```\n\nThe name x do not need even exist in the enclosing module\nbefore the function runs; in this case, the first assignment in the function creates x in the module.\n\nIf, on the other hand, X is declared nonlocal within the function in 3.X (only), the assignment changes the name X in the closest enclosing function’s local scope. The name X must have been defined in at least one enclosing function.\n\n```\ndef f1():\nx = 88\ndef f2(x=x): # Remember enclosing scope X with defaults\nprint(x)\nf2()\nf1() # Prints 88\n```\nBecause the second x is evaluated before Python steps into the nested def, it still refers to the x in f1.\n```\ndef func():\nx = 4\naction = (lambda n, x=x: x ** n) # Pass x in manually\nreturn action\n```\nLoop variables may require defaults, not scopes, Compare\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Tries to remember each i\nacts.append(lambda x: i ** x) # But all remember same last i!\nreturn acts\n```\nwith\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Use defaults instead\nacts.append(lambda x, i=i: i ** x) # Remember current i\nreturn acts\n```\nBecause defaults are implemented as single objects attached to functions, mutable defaults retain state from call to call, rather than being initialized anew on each call.\n\nUnlike global, nonlocal names must already exist in the enclosing function’s scope when declared. In fact, they are checked at function definition time before either an enclosing or nested function is called.\n\nNonlocal both allows assignment to names in enclosing function scopes and limits scope lookups for such names to enclosing defs.\n\nPython uses naming conventions in both 2.X and 3.X that ensure that the arbitrary names you assign as function attributes won’t clash with names related to internal implementation.\n\nTo summarize: globals, nonlocals, classes, and function attributes all offer changeable state-retention options.\n\n## Arguments\nIn Python 2.X, it’s also possible to automatically unpack tuples in arguments passed to a function.\n```\ndef f((a,(b,c)))\n```\nThis def syntax is no longer supported in Python 3.X. Instead, code this function as:\n```\ndef f(T): (a, (b, c)) = T\n```\nTuple unpacking argument syntax is also disallowed by 3.X in lambda\nfunction argument lists. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.X for loops targets\n\nBy default, arguments are matched by position, from left to right, and you must pass exactly as many arguments as there are argument names in the function header.\n\n![Table 18-1]($resource/2018-09-04-20-04-02.png)\n\nIn a function call, arguments must appear in this order: any positional arguments or the  *iterable form, followed by any keyword arguments or the **dict form. If we see *iterable and **dict as being unpacked to positional arguments and keyword arguments, the order becomes: any positional arguments, followed by any keyword arguments. In a broad sense, there are only two arguments: positional and keyword.\n```\ndef foo(a,b,c,d,e,f,g):\n  print('ok')\nb=[2]\nx = {'d':4,'e':5}\ny = {'f':6}\nfoo(1,*b,3,**x,g=7,**y)  //ok\n```\n> In a function header, we use the term \"parameter\" instead of \"argument\"\n\nIn a function header, parameters must appear in this order: any normal parameter(name); followed by any default parameters (name=value); followed by the *name (or \\* in 3.X) form; followed by any name or name=value keyword-only arguments (in 3.X); followed by the **name form\n\nWe can use a * character by itself in the arguments list to indicate that a function does not accept a variable-length argument list but still expects all arguments following the * to be passed as keywords.\n\nThe *name=value* form has two meaning:\n- before the form *name, it's positional with default value\n- after the form *name, it's keyword-only with default value\n\nThere can be at most one *name parameter, which collects all remaining positional arguments (including those in *iterabe). Similarly, There can be at most one *\\*dict parameter, which collects all remaining keyword arguments (including those in *\\*dict arguments).\n\n```\ndef foo(a,b=3,*c,d,**e):\n    print(b,e)\nx = [3,4]\ny = {'d':5,'e':6,'f':7}\nfoo(1,2,*x,**y)   # 2 {'e': 6, 'f': 7}\n```\nThe steps that Python internally carries out to match arguments before\nassignment can roughly be described as follows:\n1. Assign nonkeyword arguments by position.\n2. Assign keyword arguments by matching names.\n3. Assign extra nonkeyword arguments to *name tuple.\n4. Assign extra keyword arguments to **name dictionary.\n5. Assign default values to unassigned arguments in header.\n\n> Note that in both function call and header, the *name = value* form are not assignments.\n\nThe default parameters are attached to function objects, if you code\na default to be a mutable object (e.g., def f(a=[])), the same, single\nmutable object is reused every time the function is later called—even if\nit is changed in place within the function.\n\nBelow is a tracer function example:\n```\ndef tracer(func, *pargs, **kargs): # Accept arbitrary arguments\n  print('calling:', func.__name__)\n  return func(*pargs, **kargs) # Pass along arbitrary arguments\n```\n\n## Advanced Function Topics\nIn fact, recursion is not used nearly as often in Python as in\nmore esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural.\n\nOn the other hand, recursion—or equivalent explicit stack-based algorithms we’ll meet shortly—can be required to traverse arbitrarily shaped structures.\n\nAlso note that standard Python limits the depth of its runtime call stack—crucial to recursive call programs—to trap infinite recursion errors. To expand it, use the **sys** module:\n```\n>>> sys.getrecursionlimit() # 1000 calls deep default\n1000\n>>> sys.setrecursionlimit(10000) # Allow deeper nesting\n>>> help(sys.setrecursionlimit) # Read more about it\n```\n\n### Function attributes and annotations\n```\n>>> func.__code__\n>>> func.__code__.co_varnames\n```\nPython’s own implementation-related data stored on functions follows naming conventions that prevent them from clashing with the more arbitrary attribute names you might assign yourself. In 3.X, all function internals’ names have leading and trailing double underscores (“_\\_X__”);\n\nAttributes are related to objects instead of scopes (and must be referenced through the function name within its code).\n\nPython provides special syntax for specifying annotations, but it doesn’t do anything with them itself; annotations are completely optional, and when present are simply attached to the function object’s __annotations__ attribute for use by other tools. Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values.\n```\n>>> def func(a: 'spam', b: (1, 10), c: float) -> int:\nreturn a + b + c\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'c': <class 'float'="">, 'b': (1, 10), 'a': 'spam', 'return': <class 'int'="">}\n```\n\nFinally, note that annotations work only in def statements, not lambda expressions.\n\n- **lambda** is an expression, not a statement.\n- lambda’s body is a single expression, not a block of statements.\n- Defaults work on lambda arguments, just like in a def.\n- The code in a lambda body also follows the same scope lookup rules as code inside a def. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule)\n\n```\n>>> ((lambda x: (lambda y: x + y))(99))(4)\n103\n```\n\nuseful library: functools, operator\n\n## Comprehensions and Generations\nmap calls can be twice as fast as equivalent for loops, and list comprehensions are often faster than map calls.\n\nGenerator function vs. Generator vs. Generator expression\n- *send* advances to the next item  \n- *yield* is now an expression form, it must be enclose in parentheses unless it's the only item on the right ride of the assignment statement.\n- methods: *throw*, *close*\n- *yield from*\n\nGenerator expressions may also run slightly slower than list comprehensions in practice, so they are probably best used only for very large result sets, or applications that cannot wait for full results generation.\n\nA subtle but important point: both generator functions and generator expressions are their own iterators and thus support just one active iteration.\n\nPython 3.X localizes loop variables in all four forms—temporary loop variable names in generator, set, dictionary, and list comprehensions are local to the expression.\n\nIn general, list comprehensions are usually the quickest of the bunch; map beats list comprehensions in Python only when all tools must call functions; for loops tend to be slower than comprehensions; and generator functions and expressions are slower than comprehensions by a constant factor. Under\n\n## The benchmarking Interlude\nTimeing modules: time, timer, profile, timeit, pystone.py\n\n#  Part V. Modules and Packages\nModules are processed with two statements and one important function:\n- import: Lets a client (importer) fetch a module as a whole\n- from: Allows clients to fetch particular names from a module\n- imp.reload (reload in 2.X): Provides a way to reload a module’s code without stopping Python\n\nIn Python, cross-file module linking is not resolved until such import statements are executed at runtime; their net effect is to assign module names—simple variables like b—to loaded module objects. In fact, the module name used in an import statement serves two purposes: it identifies the external file to be loaded, but it also becomes a variable assigned to the loaded module.\n\nSimilarly, objects defined by a module are also created at runtime, as the import is executing: import literally runs statements in the target file one at a time to create its contents.\n\nIn python, imports perform three distinct steps the first time a program imports a given file:\n1. Find the module’s file.\n2. Compile it to byte code (if needed).\n3. Run the module’s code to build the objects it defines.\n\nBear in mind that all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named **sys.mod** ules and checking there at the start of an import operation. If the module is not present, a three-step process begins. (see **imp.reload**)\n> Python keeps already imported modules in the built-in **sys.modules** dictionary so it can keep track of what’s been loaded.\n\nNotice that compilation happens when a file is being imported. Because of this, you will not usually see a .pyc byte code file for the top-level file of your program, unless it is also imported elsewhere—only imported files leave behind .pyc files on your machine.\n\n### The Module Search Path\nRoughly, Python’s module search path is composed of the concatenation of these major components, some of which are preset for you and some of which you can tailor to tell Python where to look:\n1. The home directory of the program (subdirectories not included)\n2. PYTHONPATH directories (if set)\n3. Standard library directories\n4. The contents of any .pth files (if present)\n5. The site-packages home of third-party extensions\n\nUltimately, the concatenation of these four components becomes **sys.path**, a mutable list of directory. The first and\nthird elements of the search path are defined automatically. Because Python searches the concatenation of these components from first to last, though, the second and fourth elements can be used to extend the path to include your own source code directories.\n\nBy modifying the sys.path list, you can modify the search path for all future imports made in a program’s run. Such changes last only for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path—the first per user, and the second per installation.\n\nPython automatically selects any type that matches a module’s name. For same names with different extensions, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations. \n\nBy using import hooks, archived files are automatically extracted at import time when a  .zip file is selected from the module import search path.\n\nFor details, see the builtin **importlib._\\_import__** function\n\nThird-party extensions for Python typically use the **distutils** tools in the standard library to automatically install themselves, so no path configuration is required to use their code.\n\nSystems that use distutils generally come with a setup.py script, which is run to install them; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\site-packages subdirectory of the Python install tree, wherever that resides on the target machine).\n\n## Module Coding Basics\n### Module Filenames\nThe .py is technically optional for top-level files that will be run but not imported.\n\nIn fact, both the names of module files and the names of directories used in\npackage imports (discussed in the next chapter) must conform to the rules for variable names presented.\n\n**import** fetches the module as a whole, so you\nmust qualify to fetch its names; in contrast, **from** fetches (or copies) specific names out of the module.\n\nIn Python 3.X, the from ...* statement form described here can be used\nonly at the top level of a module file, not within a function.\n\nJust like def, import and from are executable statements, not compile-time declarations. They may be nested in if tests, to select among options; appear in function defs, to be loaded only on calls (subject to the preceding note); be used in try statements, to provide defaults; and so on.\n```\n>>> from small import x, y # Copy two names out\n>>> x = 42 # Changes local x only\n>>> y[0] = 42 # Changes shared mutable in place\n```\n\nAt least conceptually, a from statement like this one:\n```\nfrom module import name1, name2 # Copy these two names out (only)\n```\nis equivalent to this statement sequence:\n\n```\nimport module # Fetch the module object\nname1 = module.name1 # Copy names out by assignment\nname2 = module.name2\ndel module # Get rid of the module name\n```\n\nThe **from** always imports the entire module into memory if it has not yet been imported, regardless of how many names it copies out of the file. There is no way to load just part of a module file.\n\nMoreover, the from module import * form really can corrupt namespaces and make names difficult to understand, especially when applied to more than one file.\n\nProbably the best real-world advice here is to generally prefer import to from for simple modules, to explicitly list the variables you want in most from statements, and to limit the from * form to just one import per file.\n\nThe **as** extension works in both import and from as a simple renaming tool.\n\nIn fact, internally, module namespaces are stored as dictionary objects.\n\nThe LEGB scope rule applies only to bare, unqualified names—it may be used for the leftmost name in a name path, but later names after dots search specific objects instead.\n\nlexical scoping notion—in Python, the scopes surrounding\na piece of code are completely determined by the code’s physical position in your file. Scopes are never influenced by function calls or module imports.\n\nimport operations never give upward visibility to code in imported files\n—an imported file cannot see names in the importing file. In some sense, although imports do not nest namespaces upward, they do nest downward.\n```\nprint(mod2.mod3.X) # Nested mod3's X\n```\n\n### Reloading Modules\nThe **reload** function forces an already loaded module’s code to be reloaded and rerun. Assignments in the file’s new code change the existing module object in place.\n\n> Note that reload currently only works on modules\nwritten in Python;\n\nBecause reload expects an object, a module must have been previously imported successfully before you can reload it.\n\nWhen you call reload, Python rereads the module file’s source code and reruns its toplevel statements. Perhaps the most important thing to know about reload is that it changes a module object in place; it does not delete and re-create the module object.\n- Reloads impact all clients that use **import** to fetch modules\n- Reloads impact future from clients only. Clients that used from to fetch attributes in the past won’t be affected by a reload; they’ll still have references to the old objects fetched before the reload.\n- Reloads apply to a single module only. You must run them on each module you wish to update, unless you use code or tools that apply reloads transitively.\n\n## Module Packages\nDotted package  \n**from package import item**: the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable.\n**import item.subitem.subitem**: each item except for the last must be a package; the last item can be a module or a package but can't be a class or function or variable defined in the previous item.\n\nTow kinds of imports:\n- absolute imports\n- relative imports\n\nIn sum, Python imports select between relative (in the containing directory) and absolute (in a directory on sys.path) resolutions as follows:\n- Dotted imports: from . import m  \nAre relative-only in both 2.X and 3.X\n- Nondotted imports: import m, from m import x  \nAre relative-then-absolute in 2.X, and absolute-only in 3.X\n\nNote that relative imports are based on the name of the current module. Since the name of the main module is always \"__main__\", modules intended for use as the main module of a Python application must always use absolute imports.\n\nPython 3.3 adds another flavor to modules: *namespace packages*.\n\nPackages are just a special kind of module. Specifically, any module that contains a `__path__` attribute is considered a package.\n\nTwo kinds of packages:\n* regular packages\n* namespace packages",[[1565834601947,["yonggu@yongs-MacBook-Air.local",[[-1,51,"]"]],[52,52],[51,51]]],[1565834604050,["yonggu@yongs-MacBook-Air.local",[[-1,46,"["]],[46,46],[45,45]]],[1565835324292,["yonggu@yongs-MacBook-Air.local",[[-1,1108,"g"]],[1109,1109],[1108,1108]]],[1565835324919,["yonggu@yongs-MacBook-Air.local",[[1,1108,"G"]],[1108,1108],[1109,1109]]],[1565835330841,["yonggu@yongs-MacBook-Air.local",[[-1,2060,"\n"]],[2061,2061],[2060,2060]]],[1565835331568,["yonggu@yongs-MacBook-Air.local",[[1,2060," "]],[2060,2060],[2061,2061]]],[1565835338282,["yonggu@yongs-MacBook-Air.local",[[-1,2222,"\n"]],[2223,2223],[2222,2222]]],[1565835338925,["yonggu@yongs-MacBook-Air.local",[[1,2222," "]],[2222,2222],[2223,2223]]],[1565835341040,["yonggu@yongs-MacBook-Air.local",[[-1,2223,"U"]],[2224,2224],[2223,2223]]],[1565835341636,["yonggu@yongs-MacBook-Air.local",[[1,2223,"u"]],[2223,2223],[2224,2224]]],[1565835463147,["yonggu@yongs-MacBook-Air.local",[[1,2905,"\\"]],[2905,2905],[2906,2906]]],[1565835469809,["yonggu@yongs-MacBook-Air.local",[[-1,2905,"\\"]],[2906,2906],[2905,2905]]],[1565835479914,["yonggu@yongs-MacBook-Air.local",[[1,2915," "]],[2915,2915],[2916,2916]]],[1565835488131,["yonggu@yongs-MacBook-Air.local",[[1,2900,"`"]],[2900,2900],[2901,2901]]],[1565835490364,["yonggu@yongs-MacBook-Air.local",[[1,2915,"`"]],[2915,2915],[2916,2916]]],[1565835516153,["yonggu@yongs-MacBook-Air.local",[[1,2918,"`"]],[2918,2918],[2919,2919]]],[1565835518165,["yonggu@yongs-MacBook-Air.local",[[1,2927,"`"]],[2927,2927],[2928,2928]]],[1565835521596,["yonggu@yongs-MacBook-Air.local",[[1,2930,"`"]],[2930,2930],[2931,2931]]],[1565835523942,["yonggu@yongs-MacBook-Air.local",[[1,2951,"`"]],[2951,2951],[2952,2952]]],[1565835526051,["yonggu@yongs-MacBook-Air.local",[[1,2861,"`"]],[2861,2861],[2862,2862]]],[1565835527702,["yonggu@yongs-MacBook-Air.local",[[1,2868,"`"]],[2868,2868],[2869,2869]]],[1565835529573,["yonggu@yongs-MacBook-Air.local",[[1,2871,"`"]],[2871,2871],[2872,2872]]],[1565835531442,["yonggu@yongs-MacBook-Air.local",[[1,2878,"`"]],[2878,2878],[2879,2879]]],[1565835532832,["yonggu@yongs-MacBook-Air.local",[[1,2881,"`"]],[2881,2881],[2882,2882]]],[1565835534712,["yonggu@yongs-MacBook-Air.local",[[1,2888,"`"]],[2888,2888],[2889,2889]]],[1565835537188,["yonggu@yongs-MacBook-Air.local",[[1,2891,"`"]],[2891,2891],[2892,2892]]],[1565835539268,["yonggu@yongs-MacBook-Air.local",[[1,2905,"`"]],[2905,2905],[2906,2906]]]],null,"yonggu@yongs-MacBook-Air.local"],["5b5aa73b-b522-4113-8d79-648910cec1cb",1565836055772,"---\ntitle: Notes for Learning Python 5th\n---\n[toc]\n# Types and Operations\nObjects are pieces of memory, with values and sets of associated operations. Everything we process in Python programs is a kind of obj \n\nThe Python Conceptual Hierarchy:\n1. Programs are composed of modules.\n2. Modules contain statements.\n3. Statements contain expressions.\n4. Expressions create and process objects.\n\n![Table 4-1]($resource/2018-09-03-12-05-36.png)\nIn formal terms, this means that Python is dynamically typed , a model that keeps track of types for you automatically instead of requiring declaration code, but it is also strongly typed, a constraint that means you can perform on an object only operations that are valid for its type.\n\n## Core Types\nImmutable: number, string, tuple, bytes \nMutable: list, dictionary, set, bytearray\n\nPrimitive: number  \nCollection:\n* Sequence: string, tuple, bytes, list,  bytearray\n* Mapping: dictionary, set\n\nbytearray  is a distinct hybrid of immutable bytes  strings (whose b'...'  syntax is required in 3.X and optional in 2.X) and mutable lists  (coded and displayed in [] ).\n\nGeneric operations that span multiple types show up as built-in functions or expressions (e.g. `len(X)` , `X[0]` ), but type-specific operations are method calls (e.g., `aString.upper()` ).\n\nBoth `dir`  and `help`  also accept as arguments either a real object  (like our string S) , or the name of a data type  (like str , list , and dict ).\n\nAs a notable difference, Python 2.X allows its normal and Unicode strings to be mixed in expressions as long as the normal string is all ASCII; in contrast, Python 3.X has a tighter model that never  allows its normal and byte strings to mix without explicit conversion.\n\nNone of the string object’s own methods support pattern-based text processing.\n\nUnlike out-of-bounds assignments in lists, which are forbidden, assignments to new dictionary keys create those keys, fetching a nonexistent key is still a mistake. (Use the get() method)\n\nA file’s contents are always a string in your script, regardless of the type of data the file contains:\n\n```python\n>>> for line in open('data.txt'): print(line)\n```\n\t\nText files represent content as normal str strings and perform unicode encoding and decoding automatically when writing and reading data, while  binary files represent content as a special bytes string and allow you to access file content unaltered.\n\nSets are unordered collections of unique and immutable objects.\nDecimal, Fraction, booleans\n\nAs you’ll learn, in Python, we code to object interfaces (operations supported), not to types.\n\n## Numbers\n![Table 5-1]($resource/2018-09-03-12-09-34.png)\n\nFloating-point numbers are implemented as C “doubles” in standard CPython, and therefore get as much precision as the C compiler used to build the Python interpreter gives to doubles.\n\nbuilt-in calls: `hex(I)`, `oct(I)`, `bin(I)`, `int(str,base)`, `X.bit_length()`, `round(X)`, `X.as_integer_ratio()`\n\nInternally, complex numbers are implemented as pairs of floating-point numbers\n\n![Table 5-2]($resource/2018-09-03-12-10-38.png)\n\nComparison operators may be chained: X < Y < Z  produces the same result as X < Y and Y < Z .\n```python\n>>> 1 == 2 < 3 # Same as: 1 == 2 and 2 < 3\nFalse    # Not same as: False < 3 (which means 0 < 3, which is true!)\n```\n\t\nIn recent Pythons, the slice expression X[I:J:K]  is equivalent to indexing with a slice object: X[slice(I, J, K)].\n\nIn Python 3.X, nonnumeric mixed-type magnitude comparisons are not allowed and raise exceptions; this includes sorts by proxy.\n\n* Operators lower in the table have higher precedence, and so bind more tightly in mixed expressions.\n* Operators in the same row in Table 5-2  generally group from left to right when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right).\n\nBesides mixing operators in expressions, you can also mix numeric types: \nin mixed-type numeric expressions, Python first converts operands up  to the type of the most complicated operand, and then performs the math on same-type operands. Python ranks the complexity of numeric types like so: integers are simpler than floating point numbers, which are simpler than complex numbers. \nIn general, Python does not convert across any other type boundaries automatically. Adding a string to an integer, for example, results in an error, unless you manually convert one or the other.\n\n In 3.X, the / now always performs  true division, returning a float result that includes any remainder, regardless of operand types. The // performs  floor division, which truncates the remainder and returns an integer for integer operands or a float if any operand is a float.\n\nThe // operator truncates the result down to its floor, which means the closest whole number below the true result.\n\nFrozenset\n\nInternally, the names True  and False  are instances of bool , which is in turn just a subclass (in the object oriented sense) of the built-in integer type int . True  and False  behave exactly like the integers 1 and 0, except that they have customized printing logic.\n```\n>>> True + 4 # (Hmmm)\n5\n```\n\t\nNumpy, Scipy\n\t\nThe dynamic typing\nA variable never has any type information or constraints associated with it. The notion of type lives with objects, not names. Variables are generic in nature; they always simply refer to a particular object at a particular point in time.\n\nVariables always link to objects and never to other variables, but larger objects may link to other objects (for instance, a list object has links to the objects it contains).\nThese links from variables to objects are called references  in Python—that is, a reference is a kind of association, implemented as a pointer in memory\n\nTechnically speaking, objects have more structure than just enough space to represent their values. Each object also has two standard header fields: a type designator  used to mark the type of the object, and a reference counter  used to determine when it’s OK to reclaim the object.\n\nreference counter, cyclic reference\n\tsys.getrefcount(X)\n\nIf a[:], a[k] appears in expression, they are copied. e.g. after b=a[:3], b refers to a new object.\nIf a[:], a[k] appears in left side of assignment, they referred to the original object. e.g.  after a=[0,1,2]   a[:] = [0,1], a becomes [0,1]\n\n Because everything  seems to work by assignment and references\nin Python, a basic understanding of this model is useful in many different contexts. As you’ll see, it works the same in assignment statements, function arguments, for  loop variables, module imports, class attributes, and more. The good news is that there is just one  assignment model in Python;\n\nweakref\n\n## String\n![]($resource/2018-09-03-12-13-34.png)\n\n![Table 7-1]($resource/2018-09-03-16-34-23.png)\nString literal forms:\n* Single quotes: 'spa\"m'\n* Double quotes: \"spa'm\"\n* Triple quotes: '''... spam ...''' , \"\"\"... spam ...\"\"\"\n* Escape sequences: \"s\\tp\\na\\0m\"\n* Raw strings: r\"C:\\new\\test.spm\"\n* Bytes literals in 3.X and 2.6+ (see Chapter 4 , Chapter 37 ): b'sp\\x01am'\n* Unicode literals in 2.X and 3.3+ (see Chapter 4 , Chapter 37 ): u'eggs\\u0020spam'\n\nIn fact, 3.X defines str strings formally as sequences of Unicode code\npoints, not bytes, to make this clear. There’s more on how strings are stored internally in Chapter 37 if you care to know.\n\n![Table 7-2]($resource/2018-09-03-12-14-52.png)\n\nSome escape sequences allow you to embed absolute binary values into the characters of a string.\n\nPython keeps both the string’s length and text in memory. In fact, no character terminates a string in Python\n\nNotice that Python displays nonprintable characters in hex, regardless of how they were specified.\n\nThat is, r\"...\\\" is not a valid string literal—a raw string cannot end in\nan odd number of backslashes. If you need to end a raw string with a\nsingle backslash, you can use two and slice off the second (r'1\\nb\\tc\\\\'[:-1]), tack one on manually (r'1\\nb\\tc' + '\\\\'), or skip the raw string syntax and just double up the backslashes in a normal string ('1\\\\nb\\\\tc\\\\').\n\n\n```\n>>> menu = \"\"\"spam # comments here added to string!\n... eggs # ditto\n... \"\"\"\n>>> menu\n'spam # comments here added to string!\\neggs # ditto\\n'\n>>> menu = (\n... \"spam\\n\" # comments here ignored\n... \"eggs\\n\" # but newlines not automatic\n... )\n>>> menu\n'spam\\neggs\\n'\n```\n\n\nbuilt-in tool: `ord()` `chr()`\n\nThe method call expression: object.method(arguments) is evaluated from left to right—Python will first fetch the method  of the object  and then\ncall it, passing in both object and the arguments\n\nstring formatting expressions and string formatting method calls\n Technically, the format  built-in runs the subject object’s `__format__`  method, which the str.format  method does internally for each formatted item.\nThe %  expressions tend to be a bit simpler and more concise; the format  method has a handful of advanced features that the %  expression does not, but even more involved formatting still seems to be essentially a draw in terms of complexity.\n```\n>>> from formats import commas, money\n```\nTypes Share Operation Sets by Categories:\n* numbers\n* sequences\n* mappings\n\n## Lists and Dictionaries\n\n![]($resource/2018-09-03-12-17-54.png)\n![Table 8-1]($resource/2018-09-03-16-35-48.png)\nSlice assignment, the last operation in the preceding example, replaces an entire section of a list in a single step. Because it can be a bit complex, it is perhaps best thought of as a combination of two steps:\n1. Deletion. The slice you specify to the left of the = is deleted.\n2. Insertion. The new items contained in the iterable object to the right of the = are inserted into the list on the left, at the place where the old slice was deleted.\nNote, L[2:5]=L[3:6], for instance, works fine because the value to be inserted is fetched before the deletion\nhappens on the left.\n```\n>>> L = [1]\n>>> L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front\n>>> L\n[2, 3, 4, 1]\n>>> L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end\n>>> L\n[2, 3, 4, 1, 5, 6, 7]\n>>> L.extend([8, 9, 10]) # Insert all at end, named method\n>>> L\n[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]\n```\n\t\nThe effect of `L.append(X)`  is similar to `L+[X]`, but while the former changes L  in place, the latter makes a new list.\n\nIn Python 3.X, this has changed: magnitude comparison of mixed types\nraises an exception instead of falling back on the fixed cross-type ordering.\n\nL.sort() vs. sorted\nbuilt-in tools: reversed\n\nLike lists, dictionaries store object references (not copies, unless you ask for them explicitly)\n\n![Table 8-2]($resource/2018-09-03-12-18-20.png)\n\nkeys  in 3.X returns an iterable  object, instead of a physical list\nUnlike lists, however, whenever you assign a new  dictionary key (one that hasn’t been assigned before) you create a new entry in the dictionary.\n\nIn 3.X the dictionary keys , values , and items  methods all return view objects , whereas in 2.X they return actual result lists. \nBesides being iterable, dictionary views also retain the original order of dictionary components, reflect future changes to the dictionary, and may support set operations. Unlike 2.X’s list results, though, dictionary views in 3.X are not carved in stone when created—they dynamically reflect future changes  made to the dictionary after the view object has been created:\n\n In set operations, views may be mixed with other views, sets, and dictionaries; dictionaries\nare treated the same as their keys  views in this context:\n```\n>>> D = {'a': 1, 'b': 2, 'c': 3}\n>>> D.keys() & D.keys() # Intersect keys views\n{'b', 'c', 'a'}\n>>> D.keys() & {'b'} # Intersect keys and set\n{'b'}\n>>> D.\n```\n\n```\n>>> Ks.sort()\nAttributeError: 'dict_keys' object has no attribute 'sort'\n```\nTo work around this, in 3.X you must either convert to a list manually or use the\nsorted call (introduced in Chapter 4 and covered in this chapter) on either a keys view\nor the dictionary itself:\n\nOrderedDict\n\n## Tuples, files and everything else\n![]($resource/2018-09-03-16-36-56.png)\n![Table 9-1]($resource/2018-09-03-12-18-57.png)\n\nAs you can see, named tuples are a tuple/class/dictionary hybrid\n (In short, named tuples build new classes that extend the tuple type, inserting a property  accessor method for each named field that maps the name to its position)\n \n![Table 9-2]($resource/2018-09-03-12-03-26.png)\n\nEmpty lines in the file come back as strings containing just a newline character, not as empty strings.\n```\n>>> myfile.readline() # Empty string: end-of-file\n''\n```\n\t\n* Text files  represent content as normal str  strings, perform Unicode encoding and decoding automatically, and perform end-of-line translation by default.\n* Binary files  represent content as a special bytes  string type and allow programs to access file content unaltered.\n\npickle, shelve, json, struct\n\n In fact, when nested objects are present, Python automatically\ntraverses data structures to apply comparisons from left to right, and as deeply as\nneeded.\n\n More specifically, Python compares types as follows:\n- Numbers  are compared by relative magnitude, after conversion to the common highest type if needed.\n- Strings  are compared lexicographically (by the character set code point values returned by `ord` ), and character by character until the end or first mismatch (\"abc\"< \"ac\" ).\n- Lists  and tuples  are compared by comparing each component from left to right, and recursively for nested structures, until the end or first mismatch ([2] > [1, 2] ).\n- Sets  are equal if both contain the same items (formally, if each is a subset of the other), and set relative magnitude comparisons apply subset and superset tests.\n- Dictionaries  compare as equal if their sorted (key, value)  lists are equal. Relative magnitude comparisons are not supported for dictionaries in Python 3.X, but they work in 2.X as though comparing sorted (key, value)  lists.\n- Nonnumeric mixed-type magnitude comparisons (e.g., 1 < 'spam' ) are errors in Python 3.X. They are allowed in Python 2.X, but use a fixed but arbitrary ordering rule based on type name string. By proxy, this also applies to sorts, which use comparisons internally: nonnumeric mixed-type collections cannot be sorted in 3.X.\n\nPython 3.X  disallows mixed-type magnitude testing, except numeric types.\n\nMore generally, the notions of true and false are intrinsic properties of every  object in Python—each object is either true or false, as follows:\n- Numbers are false if zero, and true otherwise.\n- Other objects are false if empty, and true otherwise.\n\n That is, *None*  is something, not nothing (despite its name!)—it is a real object and a real piece of memory that is created and given a built-in name by Python itself.\n\n In fact, even types themselves are an object type in Python.\n Calls to these names are really object constructor calls, not simply conversion functions, though you can treat them as simple functions for basic usage.\n\nFor classic classes in Python 2.X, all class instances are instead of the type “instance,” and we must compare instance `__class__` attributes to compare their types meaningfully.\n\nRepetition Adds One Level Deep\n```python\n>>> L = [4, 5, 6]\n>>> X = L * 4 # Like [4, 5, 6] + [4, 5, 6] + ...\n>>> Y = [L] * 4 # [L] + [L] + ... = [L, L,...]\n```\n\t\nIf you remember that repetition, concatenation, and slicing copy only the top level of their operand objects, these sorts of cases make much more sense\n\nBeware of Cyclic  Data Structure\n```python\n>>> L = ['grail'] # Append reference to same object\n>>> L.append(L) # Generates cycle in object: [...]\n>>> L\n['grail', [...]]\n```\n\n# Statements and Syntax\n## Assignments, Expressions, and Prints\n- Assignments create object references. (i.e. link a name with an object) They always create references to objects instead of copying the objects.\n- Names are created when first assigned.\n- Names must be assigned before referenced.\n\nModule imports, function and class definitions, for  loop variables, and function arguments are all implicit assignments.\n\n![Table 11-1]($resource/2018-09-03-13-40-51.png)\n\nsequence assignment—any sequence of names can be\nassigned to any sequence of values, and Python assigns the items one at a time by position. In fact, the original tuple and list assignment forms in Python have been generalized to accept any type of sequence (really, iterable) on the right as long as it is of the same length as the sequence on the left.\n\nMultiple-target assignment: Python assigns a reference to the same object (the object farthest to the right) to all the targets on the left.\n\nIn tuple/list assignment, Python creates a temporary tuple that saves the original values of the variables on the right before assigning.\n\nwe can even assign nested sequences, and Python unpacks their parts according to their shape, as expected. The sequence-nesting shape of the object on the left must match that of the object on the right.\n> This nested tuple (really, sequence) unpacking\nassignment form works for function argument lists in Python 2.X (though not in 3.X)\n\nIn short, a single starred name, *X, can be used in the assignment target in order to specify a more general matching against the sequence—the starred name is assigned a list, which collects all items in the sequence not assigned to other names. In fact, the starred name can appear anywhere in the target.\n> This is similar in spirit to slicing, but not exactly the same—a sequence unpacking assignment always returns a list for multiple matched items, whereas slicing returns a sequence of the same type as the object sliced\n```\n>>> a, *b = 'spam'\n>>> a, b\n('s', ['p', 'a', 'm'])\n>>> S[0], S[1:] # Slices are type-specific, * assignment always returns a list\n('s', 'pam')\n```\n\nFinally, errors can still be triggered if there is more than one starred name, if there are too few values and no star (as before), and if the starred name is not itself coded inside a sequence:\n```\n>>> *a = seq\nSyntaxError: starred assignment target must be in a list or tuple\n```\n\nFor augmented assignments, inplace operations may be applied for mutable objects as an optimization.\n```\n>>> L = [1, 2]\n>>> L = L + [3] # Concatenate: slower\n>>> L\n[1, 2, 3]\n>>> L.append(4) # Faster, but in place\n>>> L\n[1, 2, 3, 4]\n>>> L += [9, 10] # Mapped to L.extend([9, 10])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\nNote however, that because of this equivalence += for a list is not exactly the same as a + and = in all cases—for lists += allows arbitrary sequences (just like extend), but concatenation normally does not:\n```\n>>> L = []\n>>> L += 'spam' # += and extend allow any sequence, but + does not!\n>>> L\n['s', 'p', 'a', 'm']\n>>> L = L + 'spam'\nTypeError: can only concatenate list (not \"str\") to list\n```\n> Although Python now supports statements like X += Y, it still does not\nhave C’s auto-increment/decrement operators (e.g., X++, −−X).\n\n### Naming\nFor portability, case also matters in the names of imported module files, even on platforms where the filesystems are case-insensitive.\n\nTrue, False, and None, are somewhat unusual in meaning—they also appear in the built-in scope of Python described in Chapter 17, and they are technically names assigned to objects.\n\nNames that begin with a single underscore (_X) are not imported by a from module import * statement\n\nNames that begin with two underscores and do not end with two more (__X) are localized (“mangled”) to enclosing classes.\n\n### Expression Statements\nIn Python, you can use an expression as a statement, too. Expressions are commonly used as statements in two situations:\n- For calls to functions and methods\n- For printing values at the interactive prompt\n\nA statement that is not an expression must generally appear on a line all by itself, not nested in a larger syntactic structure. For example, Python doesn’t allow you to embed assignment statements (=) in other expressions. Besides, C assignments return the value assigned, but Python assignments are just statements, not expressions.\n\nExpression statements are often used to run list methods that change a list in place:\n```\n>>> L = L.append(4) # But append returns None, not L\n>>> print(L) # So we lose our list!\nNone\n```\n\nNormally, whether printed output is buffered in memory or not is determined by file; passing a true value to flush forcibly flushes the stream.\n\nBecause the print statement just sends text to the sys.stdout.write method, you can capture printed text in your programs by assigning sys.stdout to an object whose write method processes the text in arbitrary ways\n\n## if Tests and Syntax Rules\nThere is no switch or case statement in Python\n\n* Block and statement boundaries are detected automatically.\n* Compound statements = header + “:” + indented statements. \n* Blank lines, spaces, and comments are usually ignored.\n* Docstrings are ignored but are saved and displayed by tools.\n\nStatements may span multiple lines if you’re continuing an open syntactic\npair.\n\nBoolean operators stop evaluating (“short circuit”) as soon as a result is known. Boolean **and** and **or** operators return a true or false object in Python, not the values True or False\n\nFor `A = Y if X else Z`, Python runs expression Y only if X turns out to be true, and runs expression Z only if X turns out to be false.\n\nWhen defining classes, we can specify their Boolean nature with either the\n__bool__ or __len__ methods.\n\n\n\n##  while and for Loops\nThe optional **else** block run if didn't exit loop with **break**\n\nPython doesn’t have what some languages call a “do until” loop statement. Python has no \"go to\" statement.\n\nPython 3.X (but not 2.X) allows ellipses coded as ... (literally, three consecutive dots) to appear any place an expression can. Because ellipses do nothing by themselves, this can serve as an alternative to the pass statement,\n```\n>>> X = ... # Alternative to None\n>>> X\nEllipsis\n```\n\nAfter the **for** loop, this loop variable normally still refers to the last item visited, which is the last item in the sequence unless the loop exits with a break statement.\n\nEven nested structures may be automatically unpacked this way in a for:\n```\n>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)\n```\n\nIn fact, as a general rule, you should resist the temptation to count things in Python—its iteration tools automate much of the work you do to loop over collections in lower-level languages like C.\n\nbuilt-in tools: range, zip, enumerate\n\nThe zip function is more general than this example suggests. For instance,\nit accepts any type of sequence (really, any iterable object, including files), and it accepts more than two arguments. Moreover, zip truncates result tuples at the length of the shortest sequence when the argument lengths differ.\n\n## Iterations and Comprehensions\n* Iterator vs. Iterable  vs. Iteration tool/context\n* Single scan vs. multiple scan\n\nIn some cases these two objects are the same when only a single scan is supported (e.g., files), and the iterator object is often temporary, used internally by the iteration tool. Moreover, some objects are both an iteration context tool (they iterate) and an iterable object (their results are iterable)—including Chapter 20’s generator expressions, and map and zip in Python 3.X.\n\nWhen the for loop begins, it first obtains an iterator from the iterable object by passing it to the iter built-in function; the object returned by iter in turn has the required next method. The iter function internally runs the __iter__ method, much like `next` and `__next__`.\n\nFor comprehensions, their full syntax allows for any number of **for** clauses, each of which can have an optional associated **if** clause.\n\nKeep in mind, though, that every built-in tool that scans from left to right across objects uses the iteration protocol.\n\nNotice that, unlike map and others, sorted returns an actual list in Python 3.X\ninstead of an iterable.\n\nOne of the fundamental distinctions of Python 3.X is its stronger emphasis on iterators than 2.X. This, along with its Unicode model and mandated new-style classes, is one of 3.X’s most sweeping changes.\n\nUnlike **range**, **map**, **zip**, **filter** are their own iterators—after you step through their results once, they are exhausted.\n\nIn Python 3.X the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time.\n\n## Documentation Interlude\nThe PyDoc system covered here can render a module’s internal documentation as either plain text in a shell, or HTML in a web browser.\n\nThe **help** function: press the space bar to move to the next page, Enter to go to the next line, and Q to quit:\n\nSphinx\n\n# Functions and Generators\n## Function Basics\n* *def* is executable code. it’s legal (and even occasionally useful) to nest def statements inside if statements, while loops, and even other *def*s.\n* *def* creates an object and assigns it to a name. Function objects may also have arbitrary user-defined *attributes* attached to them to record data.\n\nNames are always looked up in *scopes*—places where variables are stored— and assignments bind names to scopes.\n\n>Files must generally be rewound (e.g., with a file.seek(0) or another\nopen) after they have been read to end-of-file once, and so are single-pass iterators\n\n## Scopes\nWhen we talk about the search for a name’s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name’s assignment in your source\ncode determines the scope of the name’s visibility to your code.\n\nBy default, all names assigned inside a function are associated with that function’s namespace, and no other.\n\nLexical scoping:\n- If a variable is assigned inside a def, it is local to that function.\n- If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n- If a variable is assigned outside all defs, it is global to the entire file.\n\nEach module is a global scope, the global scope spans a single file only.\n* Assigned names are local unless declared global or nonlocal\n* All other names are enclosing function locals, globals, or built-ins.\n* Each call to a function creates a new local scope.\n\n> Note `L=X` within a function will classify L as a local, but L.append(X) will not.\n\n### Name Resolution: The LEGB Rule\n- Name assignments create or change local names by default.\n- Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in.\n- Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively.\n\nNote that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup level.\n\nAlso keep in mind that these rules apply only to simple variable names (e.g., spam). Qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here.\n\nThere are technically three more scopes in Python—temporary loop variables in some comprehensions, exception reference variables in some try handlers, and local scopes in class statements\n\nIn 3.X, the loop variables are local to the expression itself in all comprehension forms: generator, list, set, and dictionary. In 2.X, they are local to generator expressions and set and dictionary compressions, but not to list comprehensions that map their names to the scope outside the expression. By contrast, for loop statements never localize their variables to the statement block in any Python.\n\nIn 3.X, exception reference variables are local to that except block, and in fact are removed when the block is exited (even if you’ve used it earlier in your code!).\n\nAlthough the LEGB rule is used to resolve\nnames used in both the top level of a class itself as well as the top level of method functions nested within it, classes themselves are skipped by scope lookups—their names must be fetched as object attributes.\n\n### The global/nonlocal Statement\nThe global statement consists of the keyword global, followed by one or more names separated by commas. All the listed names will be mapped to the enclosing module’s scope when assigned or referenced within the function body. \n```\nglobal x\n```\n\nThe name x do not need even exist in the enclosing module\nbefore the function runs; in this case, the first assignment in the function creates x in the module.\n\nIf, on the other hand, X is declared nonlocal within the function in 3.X (only), the assignment changes the name X in the closest enclosing function’s local scope. The name X must have been defined in at least one enclosing function.\n\n```\ndef f1():\nx = 88\ndef f2(x=x): # Remember enclosing scope X with defaults\nprint(x)\nf2()\nf1() # Prints 88\n```\nBecause the second x is evaluated before Python steps into the nested def, it still refers to the x in f1.\n```\ndef func():\nx = 4\naction = (lambda n, x=x: x ** n) # Pass x in manually\nreturn action\n```\nLoop variables may require defaults, not scopes, Compare\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Tries to remember each i\nacts.append(lambda x: i ** x) # But all remember same last i!\nreturn acts\n```\nwith\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Use defaults instead\nacts.append(lambda x, i=i: i ** x) # Remember current i\nreturn acts\n```\nBecause defaults are implemented as single objects attached to functions, mutable defaults retain state from call to call, rather than being initialized anew on each call.\n\nUnlike global, nonlocal names must already exist in the enclosing function’s scope when declared. In fact, they are checked at function definition time before either an enclosing or nested function is called.\n\nNonlocal both allows assignment to names in enclosing function scopes and limits scope lookups for such names to enclosing defs.\n\nPython uses naming conventions in both 2.X and 3.X that ensure that the arbitrary names you assign as function attributes won’t clash with names related to internal implementation.\n\nTo summarize: globals, nonlocals, classes, and function attributes all offer changeable state-retention options.\n\n## Arguments\nIn Python 2.X, it’s also possible to automatically unpack tuples in arguments passed to a function.\n```\ndef f((a,(b,c)))\n```\nThis def syntax is no longer supported in Python 3.X. Instead, code this function as:\n```\ndef f(T): (a, (b, c)) = T\n```\nTuple unpacking argument syntax is also disallowed by 3.X in lambda\nfunction argument lists. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.X for loops targets\n\nBy default, arguments are matched by position, from left to right, and you must pass exactly as many arguments as there are argument names in the function header.\n\n![Table 18-1]($resource/2018-09-04-20-04-02.png)\n\nIn a function call, arguments must appear in this order: any positional arguments or the  *iterable form, followed by any keyword arguments or the **dict form. If we see *iterable and **dict as being unpacked to positional arguments and keyword arguments, the order becomes: any positional arguments, followed by any keyword arguments. In a broad sense, there are only two arguments: positional and keyword.\n```\ndef foo(a,b,c,d,e,f,g):\n  print('ok')\nb=[2]\nx = {'d':4,'e':5}\ny = {'f':6}\nfoo(1,*b,3,**x,g=7,**y)  //ok\n```\n> In a function header, we use the term \"parameter\" instead of \"argument\"\n\nIn a function header, parameters must appear in this order: any normal parameter(name); followed by any default parameters (name=value); followed by the *name (or \\* in 3.X) form; followed by any name or name=value keyword-only arguments (in 3.X); followed by the **name form\n\nWe can use a * character by itself in the arguments list to indicate that a function does not accept a variable-length argument list but still expects all arguments following the * to be passed as keywords.\n\nThe *name=value* form has two meaning:\n- before the form *name, it's positional with default value\n- after the form *name, it's keyword-only with default value\n\nThere can be at most one *name parameter, which collects all remaining positional arguments (including those in *iterabe). Similarly, There can be at most one *\\*dict parameter, which collects all remaining keyword arguments (including those in *\\*dict arguments).\n\n```\ndef foo(a,b=3,*c,d,**e):\n    print(b,e)\nx = [3,4]\ny = {'d':5,'e':6,'f':7}\nfoo(1,2,*x,**y)   # 2 {'e': 6, 'f': 7}\n```\nThe steps that Python internally carries out to match arguments before\nassignment can roughly be described as follows:\n1. Assign nonkeyword arguments by position.\n2. Assign keyword arguments by matching names.\n3. Assign extra nonkeyword arguments to *name tuple.\n4. Assign extra keyword arguments to **name dictionary.\n5. Assign default values to unassigned arguments in header.\n\n> Note that in both function call and header, the *name = value* form are not assignments.\n\nThe default parameters are attached to function objects, if you code\na default to be a mutable object (e.g., def f(a=[])), the same, single\nmutable object is reused every time the function is later called—even if\nit is changed in place within the function.\n\nBelow is a tracer function example:\n```\ndef tracer(func, *pargs, **kargs): # Accept arbitrary arguments\n  print('calling:', func.__name__)\n  return func(*pargs, **kargs) # Pass along arbitrary arguments\n```\n\n## Advanced Function Topics\nIn fact, recursion is not used nearly as often in Python as in\nmore esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural.\n\nOn the other hand, recursion—or equivalent explicit stack-based algorithms we’ll meet shortly—can be required to traverse arbitrarily shaped structures.\n\nAlso note that standard Python limits the depth of its runtime call stack—crucial to recursive call programs—to trap infinite recursion errors. To expand it, use the **sys** module:\n```\n>>> sys.getrecursionlimit() # 1000 calls deep default\n1000\n>>> sys.setrecursionlimit(10000) # Allow deeper nesting\n>>> help(sys.setrecursionlimit) # Read more about it\n```\n\n### Function attributes and annotations\n```\n>>> func.__code__\n>>> func.__code__.co_varnames\n```\nPython’s own implementation-related data stored on functions follows naming conventions that prevent them from clashing with the more arbitrary attribute names you might assign yourself. In 3.X, all function internals’ names have leading and trailing double underscores (“_\\_X__”);\n\nAttributes are related to objects instead of scopes (and must be referenced through the function name within its code).\n\nPython provides special syntax for specifying annotations, but it doesn’t do anything with them itself; annotations are completely optional, and when present are simply attached to the function object’s __annotations__ attribute for use by other tools. Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values.\n```\n>>> def func(a: 'spam', b: (1, 10), c: float) -> int:\nreturn a + b + c\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'c': <class 'float'="">, 'b': (1, 10), 'a': 'spam', 'return': <class 'int'="">}\n```\n\nFinally, note that annotations work only in def statements, not lambda expressions.\n\n- **lambda** is an expression, not a statement.\n- lambda’s body is a single expression, not a block of statements.\n- Defaults work on lambda arguments, just like in a def.\n- The code in a lambda body also follows the same scope lookup rules as code inside a def. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule)\n\n```\n>>> ((lambda x: (lambda y: x + y))(99))(4)\n103\n```\n\nuseful library: functools, operator\n\n## Comprehensions and Generations\nmap calls can be twice as fast as equivalent for loops, and list comprehensions are often faster than map calls.\n\nGenerator function vs. Generator vs. Generator expression\n- *send* advances to the next item  \n- *yield* is now an expression form, it must be enclose in parentheses unless it's the only item on the right ride of the assignment statement.\n- methods: *throw*, *close*\n- *yield from*\n\nGenerator expressions may also run slightly slower than list comprehensions in practice, so they are probably best used only for very large result sets, or applications that cannot wait for full results generation.\n\nA subtle but important point: both generator functions and generator expressions are their own iterators and thus support just one active iteration.\n\nPython 3.X localizes loop variables in all four forms—temporary loop variable names in generator, set, dictionary, and list comprehensions are local to the expression.\n\nIn general, list comprehensions are usually the quickest of the bunch; map beats list comprehensions in Python only when all tools must call functions; for loops tend to be slower than comprehensions; and generator functions and expressions are slower than comprehensions by a constant factor. Under\n\n## The benchmarking Interlude\nTimeing modules: time, timer, profile, timeit, pystone.py\n\n#  Part V. Modules and Packages\nModules are processed with two statements and one important function:\n- import: Lets a client (importer) fetch a module as a whole\n- from: Allows clients to fetch particular names from a module\n- imp.reload (reload in 2.X): Provides a way to reload a module’s code without stopping Python\n\nIn Python, cross-file module linking is not resolved until such import statements are executed at runtime; their net effect is to assign module names—simple variables like b—to loaded module objects. In fact, the module name used in an import statement serves two purposes: it identifies the external file to be loaded, but it also becomes a variable assigned to the loaded module.\n\nSimilarly, objects defined by a module are also created at runtime, as the import is executing: import literally runs statements in the target file one at a time to create its contents.\n\nIn python, imports perform three distinct steps the first time a program imports a given file:\n1. Find the module’s file.\n2. Compile it to byte code (if needed).\n3. Run the module’s code to build the objects it defines.\n\nBear in mind that all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named **sys.mod** ules and checking there at the start of an import operation. If the module is not present, a three-step process begins. (see **imp.reload**)\n> Python keeps already imported modules in the built-in **sys.modules** dictionary so it can keep track of what’s been loaded.\n\nNotice that compilation happens when a file is being imported. Because of this, you will not usually see a .pyc byte code file for the top-level file of your program, unless it is also imported elsewhere—only imported files leave behind .pyc files on your machine.\n\n### The Module Search Path\nRoughly, Python’s module search path is composed of the concatenation of these major components, some of which are preset for you and some of which you can tailor to tell Python where to look:\n1. The home directory of the program (subdirectories not included)\n2. PYTHONPATH directories (if set)\n3. Standard library directories\n4. The contents of any .pth files (if present)\n5. The site-packages home of third-party extensions\n\nUltimately, the concatenation of these four components becomes **sys.path**, a mutable list of directory. The first and\nthird elements of the search path are defined automatically. Because Python searches the concatenation of these components from first to last, though, the second and fourth elements can be used to extend the path to include your own source code directories.\n\nBy modifying the sys.path list, you can modify the search path for all future imports made in a program’s run. Such changes last only for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path—the first per user, and the second per installation.\n\nPython automatically selects any type that matches a module’s name. For same names with different extensions, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations. \n\nBy using import hooks, archived files are automatically extracted at import time when a  .zip file is selected from the module import search path.\n\nFor details, see the builtin **importlib._\\_import__** function\n\nThird-party extensions for Python typically use the **distutils** tools in the standard library to automatically install themselves, so no path configuration is required to use their code.\n\nSystems that use distutils generally come with a setup.py script, which is run to install them; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\site-packages subdirectory of the Python install tree, wherever that resides on the target machine).\n\n## Module Coding Basics\n### Module Filenames\nThe .py is technically optional for top-level files that will be run but not imported.\n\nIn fact, both the names of module files and the names of directories used in\npackage imports (discussed in the next chapter) must conform to the rules for variable names presented.\n\n**import** fetches the module as a whole, so you\nmust qualify to fetch its names; in contrast, **from** fetches (or copies) specific names out of the module.\n\nIn Python 3.X, the from ...* statement form described here can be used\nonly at the top level of a module file, not within a function.\n\nJust like def, import and from are executable statements, not compile-time declarations. They may be nested in if tests, to select among options; appear in function defs, to be loaded only on calls (subject to the preceding note); be used in try statements, to provide defaults; and so on.\n```\n>>> from small import x, y # Copy two names out\n>>> x = 42 # Changes local x only\n>>> y[0] = 42 # Changes shared mutable in place\n```\n\nAt least conceptually, a from statement like this one:\n```\nfrom module import name1, name2 # Copy these two names out (only)\n```\nis equivalent to this statement sequence:\n\n```\nimport module # Fetch the module object\nname1 = module.name1 # Copy names out by assignment\nname2 = module.name2\ndel module # Get rid of the module name\n```\n\nThe **from** always imports the entire module into memory if it has not yet been imported, regardless of how many names it copies out of the file. There is no way to load just part of a module file.\n\nMoreover, the from module import * form really can corrupt namespaces and make names difficult to understand, especially when applied to more than one file.\n\nProbably the best real-world advice here is to generally prefer import to from for simple modules, to explicitly list the variables you want in most from statements, and to limit the from * form to just one import per file.\n\nThe **as** extension works in both import and from as a simple renaming tool.\n\nIn fact, internally, module namespaces are stored as dictionary objects.\n\nThe LEGB scope rule applies only to bare, unqualified names—it may be used for the leftmost name in a name path, but later names after dots search specific objects instead.\n\nlexical scoping notion—in Python, the scopes surrounding\na piece of code are completely determined by the code’s physical position in your file. Scopes are never influenced by function calls or module imports.\n\nimport operations never give upward visibility to code in imported files\n—an imported file cannot see names in the importing file. In some sense, although imports do not nest namespaces upward, they do nest downward.\n```\nprint(mod2.mod3.X) # Nested mod3's X\n```\n\n### Reloading Modules\nThe **reload** function forces an already loaded module’s code to be reloaded and rerun. Assignments in the file’s new code change the existing module object in place.\n\n> Note that reload currently only works on modules\nwritten in Python;\n\nBecause reload expects an object, a module must have been previously imported successfully before you can reload it.\n\nWhen you call reload, Python rereads the module file’s source code and reruns its toplevel statements. Perhaps the most important thing to know about reload is that it changes a module object in place; it does not delete and re-create the module object.\n- Reloads impact all clients that use **import** to fetch modules\n- Reloads impact future from clients only. Clients that used from to fetch attributes in the past won’t be affected by a reload; they’ll still have references to the old objects fetched before the reload.\n- Reloads apply to a single module only. You must run them on each module you wish to update, unless you use code or tools that apply reloads transitively.\n\n## Module Packages\nDotted package  \n**from package import item**: the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable.\n**import item.subitem.subitem**: each item except for the last must be a package; the last item can be a module or a package but can't be a class or function or variable defined in the previous item.\n\nTow kinds of imports:\n- absolute imports\n- relative imports\n\nIn sum, Python imports select between relative (in the containing directory) and absolute (in a directory on sys.path) resolutions as follows:\n- Dotted imports: from . import m  \nAre relative-only in both 2.X and 3.X\n- Nondotted imports: import m, from m import x  \nAre relative-then-absolute in 2.X, and absolute-only in 3.X\n\nNote that relative imports are based on the name of the current module. Since the name of the main module is always \"__main__\", modules intended for use as the main module of a Python application must always use absolute imports.\n\nPython 3.3 adds another flavor to modules: *namespace packages*.\n\nPackages are just a special kind of module. Specifically, any module that contains a `__path__` attribute is considered a package.\n\nTwo kinds of packages:\n* regular packages\n* namespace packages",[[1565836016767,["yonggu@yongs-MacBook-Air.local",[[1,4238,"\n"]],[4237,4237],[4238,4238]]],[1565836026215,["yonggu@yongs-MacBook-Air.local",[[-1,3927,"\n"]],[3928,3928],[3927,3927]]],[1565836028795,["yonggu@yongs-MacBook-Air.local",[[1,3927," "]],[3927,3927],[3928,3928]]],[1565836030139,["yonggu@yongs-MacBook-Air.local",[[-1,3927," "]],[3928,3928],[3927,3927]]],[1565837113060,["yonggu@yongs-MacBook-Air.local",[[-1,5519," "]],[5520,5520],[5519,5519]]],[1565837113839,["yonggu@yongs-MacBook-Air.local",[[1,5519," "]],[5519,5519],[5520,5520]]],[1565837164790,["yonggu@yongs-MacBook-Air.local",[[1,6072,"`"]],[6072,6072],[6073,6073]]],[1565837167488,["yonggu@yongs-MacBook-Air.local",[[1,6091,"`"]],[6091,6091],[6092,6092]]],[1565837214217,["yonggu@yongs-MacBook-Air.local",[[-1,6400,"\n"]],[6401,6401],[6400,6400]]],[1565837214875,["yonggu@yongs-MacBook-Air.local",[[1,6400," "]],[6400,6400],[6401,6401]]],[1565837239112,["yonggu@yongs-MacBook-Air.local",[[-1,6569," "]],[6570,6570],[6569,6569]]],[1565837295715,["yonggu@yongs-MacBook-Air.local",[[-1,0,"---\ntitle: Notes for Learning Python 5th\n---"]],[0,44],[0,0]]],[1565837297153,["yonggu@yongs-MacBook-Air.local",[[-1,0,"\n"]],[1,1],[0,0]]],[1565837301090,["yonggu@yongs-MacBook-Air.local",[[-1,0,"[toc]"]],[5,5],[0,0]]],[1565837303366,["yonggu@yongs-MacBook-Air.local",[[-1,0,"\n"]],[1,1],[0,0]]],[1565837305142,["yonggu@yongs-MacBook-Air.local",[[1,0,"\n"]],[0,0],[1,1]]],[1565837307752,["yonggu@yongs-MacBook-Air.local",[[1,0,"THis"]],[0,0],[4,4]]],[1565837308449,["yonggu@yongs-MacBook-Air.local",[[-1,1,"His"]],[4,4],[1,1]]],[1565837314827,["yonggu@yongs-MacBook-Air.local",[[1,1,"his is my notes for "]],[1,1],[21,21]]],[1565837316179,["yonggu@yongs-MacBook-Air.local",[[1,21,"\""]],[21,21],[22,22]]],[1565837316262,["yonggu@yongs-MacBook-Air.local",[[-1,21,"\""],[1,22,"“"]],[22,22],[22,22]]],[1565837324986,["yonggu@yongs-MacBook-Air.local",[[1,22,"Learning Ptyhon(5th)"]],[22,22],[42,42]]],[1565837326642,["yonggu@yongs-MacBook-Air.local",[[1,37," "]],[37,37],[38,38]]],[1565837328323,["yonggu@yongs-MacBook-Air.local",[[1,43,"\""]],[43,43],[44,44]]],[1565837328476,["yonggu@yongs-MacBook-Air.local",[[-1,43,"\""],[1,44,"”"]],[44,44],[44,44]]],[1565837335990,["yonggu@yongs-MacBook-Air.local",[[1,44,"."]],[44,44],[45,45]]],[1565837336628,["yonggu@yongs-MacBook-Air.local",[[1,46,"\n"]],[45,45],[46,46]]],[1565841230903,["yonggu@yongs-MacBook-Air.local",[[1,48,"#"]],[48,48],[49,49]]],[1565841250288,["yonggu@yongs-MacBook-Air.local",[[1,726,"#"]],[726,726],[727,727]]],[1565841252723,["yonggu@yongs-MacBook-Air.local",[[-1,726,"#"]],[727,727],[726,726]]],[1565841254965,["yonggu@yongs-MacBook-Air.local",[[-1,48,"#"]],[48,48],[47,47]]],[1565841256155,["yonggu@yongs-MacBook-Air.local",[[1,47,"\n"]],[46,46],[47,47]]],[1565841262614,["yonggu@yongs-MacBook-Air.local",[[1,47,"# Introduction"]],[47,47],[61,61]]],[1565841266442,["yonggu@yongs-MacBook-Air.local",[[-1,47,"# Introduction"]],[61,61],[47,47]]],[1565841269956,["yonggu@yongs-MacBook-Air.local",[[1,47,"# Prelima"]],[47,47],[56,56]]],[1565841270473,["yonggu@yongs-MacBook-Air.local",[[-1,55,"a"]],[56,56],[55,55]]],[1565841273875,["yonggu@yongs-MacBook-Air.local",[[1,55,"inaries"]],[55,55],[62,62]]],[1565841274989,["yonggu@yongs-MacBook-Air.local",[[1,63,"\n"]],[62,62],[63,63]]],[1565841276905,["yonggu@yongs-MacBook-Air.local",[[1,64,"\n"]],[63,63],[64,64]]],[1565841278239,["yonggu@yongs-MacBook-Air.local",[[-1,64,"\n"]],[64,64],[63,63]]],[1565841281145,["yonggu@yongs-MacBook-Air.local",[[1,63,"```"]],[63,63],[66,66]]],[1565841281792,["yonggu@yongs-MacBook-Air.local",[[1,67,"\n"]],[66,66],[67,67]]],[1565841283492,["yonggu@yongs-MacBook-Air.local",[[1,67,"```"]],[67,67],[70,70]]],[1565841284136,["yonggu@yongs-MacBook-Air.local",[[1,67,"\n"]],[66,66],[67,67]]],[1565841286164,["yonggu@yongs-MacBook-Air.local",[[1,67,"d"]],[67,67],[68,68]]],[1565841286884,["yonggu@yongs-MacBook-Air.local",[[-1,67,"d"]],[68,68],[67,67]]],[1565841290143,["yonggu@yongs-MacBook-Air.local",[[1,67,">>> dir()"]],[67,67],[76,76]]],[1565841291814,["yonggu@yongs-MacBook-Air.local",[[1,77,"\n"]],[76,76],[77,77]]],[1565841296619,["yonggu@yongs-MacBook-Air.local",[[1,77,">>> dir(S)"]],[77,77],[87,87]]],[1565841301873,["yonggu@yongs-MacBook-Air.local",[[1,76," # no argument"]],[76,76],[90,90]]],[1565841304106,["yonggu@yongs-MacBook-Air.local",[[1,101," "]],[101,101],[102,102]]],[1565841309733,["yonggu@yongs-MacBook-Air.local",[[1,107,"\n"]],[106,106],[107,107]]],[1565841310670,["yonggu@yongs-MacBook-Air.local",[[1,108,"\n"]],[107,107],[108,108]]],[1565841313295,["yonggu@yongs-MacBook-Air.local",[[1,63,"\n"]],[62,62],[63,63]]],[1565841533409,["yonggu@yongs-MacBook-Air.local",[[1,68,"\n"]],[67,67],[68,68]]],[1565841539491,["yonggu@yongs-MacBook-Air.local",[[1,68,">>> S = 'span"]],[68,68],[81,81]]],[1565841539807,["yonggu@yongs-MacBook-Air.local",[[-1,80,"n"]],[81,81],[80,80]]],[1565841542168,["yonggu@yongs-MacBook-Air.local",[[1,80,"m'"]],[80,80],[82,82]]],[1565841544654,["yonggu@yongs-MacBook-Air.local",[[1,117,"\n"]],[117,117],[118,118]]],[1565841545703,["yonggu@yongs-MacBook-Air.local",[[1,118,">>>"]],[118,118],[121,121]]],[1565841546107,["yonggu@yongs-MacBook-Air.local",[[1,122," "]],[121,121],[122,122]]],[1565841550578,["yonggu@yongs-MacBook-Air.local",[[1,122,"help(S.replace)O"]],[122,122],[138,138]]],[1565841551689,["yonggu@yongs-MacBook-Air.local",[[-1,137,"O"]],[138,138],[137,137]]],[1566088513864,["yonggu@yongs-MacBook-Air.local",[[1,144,"For lists, "]],[144,144],[155,155]]],[1566088659255,["yonggu@yongs-MacBook-Air.local",[[1,155,"if `a[:}, "]],[155,155],[165,165]]],[1566088660154,["yonggu@yongs-MacBook-Air.local",[[-1,162,"}, "]],[165,165],[162,162]]],[1566088663633,["yonggu@yongs-MacBook-Air.local",[[1,162,"], akk"]],[162,162],[168,168]]],[1566088664355,["yonggu@yongs-MacBook-Air.local",[[-1,166,"kk"]],[168,168],[166,166]]],[1566088682050,["yonggu@yongs-MacBook-Air.local",[[1,166,"[k]` appear in expresion, they are copied"]],[166,166],[207,207]]],[1566088699508,["yonggu@yongs-MacBook-Air.local",[[1,207,". "]],[207,207],[209,209]]],[1566088702941,["yonggu@yongs-MacBook-Air.local",[[-1,207,". "]],[209,209],[207,207]]],[1566088731532,["yonggu@yongs-MacBook-Air.local",[[1,207,", e.g. after b = a[:3], b refers to a new object. If `a[:}"]],[207,207],[265,265]]],[1566088732199,["yonggu@yongs-MacBook-Air.local",[[-1,264,"}"]],[265,265],[264,264]]],[1566088738899,["yonggu@yongs-MacBook-Air.local",[[1,264,"],a[k]`appear i"]],[264,264],[279,279]]],[1566088740593,["yonggu@yongs-MacBook-Air.local",[[-1,278,"i"]],[279,279],[278,278]]],[1566088741340,["yonggu@yongs-MacBook-Air.local",[[1,278,"i"]],[278,278],[279,279]]],[1566088741974,["yonggu@yongs-MacBook-Air.local",[[-1,278,"i"]],[279,279],[278,278]]],[1566088742590,["yonggu@yongs-MacBook-Air.local",[[1,278,"a"]],[278,278],[279,279]]],[1566088743656,["yonggu@yongs-MacBook-Air.local",[[-1,278,"a"]],[279,279],[278,278]]],[1566088752348,["yonggu@yongs-MacBook-Air.local",[[1,278,"on the left side of assignment, thr"]],[278,278],[313,313]]],[1566088753069,["yonggu@yongs-MacBook-Air.local",[[-1,312,"r"]],[313,313],[312,312]]],[1566088756603,["yonggu@yongs-MacBook-Air.local",[[1,312,"ey refer"]],[312,312],[320,320]]],[1566088778456,["yonggu@yongs-MacBook-Air.local",[[1,321,"ed to the original object, e.g. after `a=[0,1,2]1"]],[321,321],[370,370]]],[1566088779472,["yonggu@yongs-MacBook-Air.local",[[-1,369,"1"]],[370,370],[369,369]]],[1566088781627,["yonggu@yongs-MacBook-Air.local",[[1,369,", a["]],[369,369],[373,373]]],[1566088783211,["yonggu@yongs-MacBook-Air.local",[[-1,369,", a["]],[373,373],[369,369]]],[1566088795147,["yonggu@yongs-MacBook-Air.local",[[1,369," a[:]=[0,1],"]],[369,369],[381,381]]],[1566088795765,["yonggu@yongs-MacBook-Air.local",[[-1,380,","]],[381,381],[380,380]]],[1566088803830,["yonggu@yongs-MacBook-Air.local",[[1,380,"`, a becomes `[0,1]`"]],[380,380],[400,400]]],[1566088807251,["yonggu@yongs-MacBook-Air.local",[[1,220,"`"]],[220,220],[221,221]]],[1566088809074,["yonggu@yongs-MacBook-Air.local",[[1,230,"`"]],[230,230],[231,231]]],[1566088814964,["yonggu@yongs-MacBook-Air.local",[[1,402,"."]],[402,402],[403,403]]],[1566088815286,["yonggu@yongs-MacBook-Air.local",[[1,404,"\n"]],[403,403],[404,404]]],[1566088816964,["yonggu@yongs-MacBook-Air.local",[[1,404,"```"]],[404,404],[407,407]]],[1566088877392,[null,[[-1,322,"\n"],[1,323,"r"],[-1,403,"#"],[1,404,"\n"],[1,408,"#"]],[322,322],[409,409]]],[1566088877393,[null,[[1,322,"\n"],[-1,322,"r"],[1,403,"#"],[-1,403,"\n"],[-1,408,"#"]],[409,409],[322,322]]],[1566088818407,["yonggu@yongs-MacBook-Air.local",[[1,408,">>> a = [0,[1,2],3]\n\n>>> b=a[1]\n\n>>> b[0] = 0\n\n>>> a\n\n[0, [0, 2], 3]"]],[408,408],[476,476]]],[1566088818976,["yonggu@yongs-MacBook-Air.local",[[1,477,"\n"]],[476,476],[477,477]]],[1566088820287,["yonggu@yongs-MacBook-Air.local",[[1,477,"```"]],[477,477],[480,480]]],[1566089057451,[null,[[-1,322,"\n"],[1,323,"r"],[-1,403,"#"],[1,404,"\n"],[-1,476," "],[1,477,"\n"],[1,481,"# "]],[322,322],[483,483]]],[1566089057451,[null,[[1,322,"\n"],[-1,322,"r"],[1,403,"#"],[-1,403,"\n"],[1,476," "],[-1,476,"\n"],[-1,481,"# "]],[483,483],[322,322]]],[1566088999728,["yonggu@yongs-MacBook-Air.local",[[1,403," "]],[403,403],[404,404]]],[1566089004190,["yonggu@yongs-MacBook-Air.local",[[1,405,"\n"]],[404,404],[405,405]]],[1566089007961,["yonggu@yongs-MacBook-Air.local",[[1,405,"Wehn "]],[405,405],[410,410]]],[1566089009247,["yonggu@yongs-MacBook-Air.local",[[-1,405,"Wehn "]],[410,410],[405,405]]],[1566089021894,["yonggu@yongs-MacBook-Air.local",[[1,405,"When we say copy, we mean shallow copy."]],[405,405],[444,444]]],[1566089297449,[null,[[-1,322,"\n"],[1,323,"r"],[-1,404,"#"],[1,405,"\n"],[-1,517," "],[1,518,"\n"],[1,522,"# "]],[322,322],[524,524]]],[1566089297449,[null,[[1,322,"\n"],[-1,322,"r"],[1,404,"#"],[-1,404,"\n"],[1,517," "],[-1,517,"\n"],[-1,522,"# "]],[524,524],[322,322]]],[1566089281300,["yonggu@yongs-MacBook-Air.local",[[1,522,"\n"]],[521,521],[522,522]]],[1566089282262,["yonggu@yongs-MacBook-Air.local",[[1,523,"\n"]],[522,522],[523,523]]],[1566089286186,["yonggu@yongs-MacBook-Air.local",[[1,523,"\\"]],[523,523],[524,524]]],[1566089286970,["yonggu@yongs-MacBook-Air.local",[[-1,523,"\\"]],[524,524],[523,523]]],[1566089287565,["yonggu@yongs-MacBook-Air.local",[[-1,523,"\n"]],[523,523],[522,522]]],[1566089296398,["yonggu@yongs-MacBook-Air.local",[[1,522,"Rule: `exp1 = exp2"]],[522,522],[540,540]]],[1566089357440,[null,[[-1,322,"\n"],[1,323,"r"],[-1,404,"#"],[1,405,"\n"],[-1,517," "],[1,518,"\n"],[1,541,"# "]],[322,322],[543,543]]],[1566089357440,[null,[[1,322,"\n"],[-1,322,"r"],[1,404,"#"],[-1,404,"\n"],[1,517," "],[-1,517,"\n"],[-1,541,"# "]],[543,543],[322,322]]],[1566089297498,["yonggu@yongs-MacBook-Air.local",[[1,540,"`"]],[540,540],[541,541]]],[1566089303073,["yonggu@yongs-MacBook-Air.local",[[1,540,", exp2 = exp3"]],[540,540],[553,553]]],[1566089310823,["yonggu@yongs-MacBook-Air.local",[[1,554," then exp1"]],[554,554],[564,564]]],[1566089313488,["yonggu@yongs-MacBook-Air.local",[[1,561,"`"]],[561,561],[562,562]]],[1566089314556,["yonggu@yongs-MacBook-Air.local",[[-1,561,"`"]],[562,562],[561,561]]],[1566089315161,["yonggu@yongs-MacBook-Air.local",[[1,560,"`"]],[560,560],[561,561]]],[1566089325924,["yonggu@yongs-MacBook-Air.local",[[1,565," != exp3`"]],[565,565],[574,574]]],[1566089477651,[null,[[-1,322,"\n"],[1,323,"r"],[-1,404,"#"],[1,405,"\n"],[-1,517," "],[1,518,"\n"],[1,575,"# "]],[322,322],[577,577]]],[1566089477651,[null,[[1,322,"\n"],[-1,322,"r"],[1,404,"#"],[-1,404,"\n"],[1,517," "],[-1,517,"\n"],[-1,575,"# "]],[577,577],[322,322]]],[1566089434506,["yonggu@yongs-MacBook-Air.local",[[-1,571,"p3`"]],[574,574],[571,571]]],[1566089436150,["yonggu@yongs-MacBook-Air.local",[[1,571,"p"]],[571,571],[572,572]]],[1566089449627,["yonggu@yongs-MacBook-Air.local",[[-1,522,"Rule: `exp1 = exp2, exp2 = exp3` then `exp1 != exp"]],[572,572],[522,522]]],[1566089451039,["yonggu@yongs-MacBook-Air.local",[[1,523,"\n"]],[522,522],[523,523]]],[1566089466998,["yonggu@yongs-MacBook-Air.local",[[1,523,"In sum, `exp1 = exp2`"]],[523,523],[544,544]]],[1566089470773,["yonggu@yongs-MacBook-Air.local",[[1,531,"after "]],[531,531],[537,537]]],[1566089477238,["yonggu@yongs-MacBook-Air.local",[[1,550,", exp1 points to "]],[550,550],[567,567]]],[1566089537664,[null,[[-1,322,"\n"],[1,323,"r"],[-1,404,"#"],[1,405,"\n"],[-1,517," "],[1,518,"\n"],[1,568,"# "]],[322,322],[570,570]]],[1566089537664,[null,[[1,322,"\n"],[-1,322,"r"],[1,404,"#"],[-1,404,"\n"],[1,517," "],[-1,517,"\n"],[-1,568,"# "]],[570,570],[322,322]]],[1566089497841,["yonggu@yongs-MacBook-Air.local",[[1,567,"the same place as exp2."]],[567,567],[590,590]]],[1566089823518,[null,[[-1,322,"\n"],[1,323,"r"],[-1,404,"#"],[1,405,"\n"],[-1,517," "],[1,518,"\n"],[1,591,"# "]],[322,322],[593,593]]],[1566089823518,[null,[[1,322,"\n"],[-1,322,"r"],[1,404,"#"],[-1,404,"\n"],[1,517," "],[-1,517,"\n"],[-1,591,"# "]],[593,593],[322,322]]],[1566089817108,["yonggu@yongs-MacBook-Air.local",[[1,590," Python always follows a reference to an object whenever the reference is usi"]],[590,590],[667,667]]],[1566089817791,["yonggu@yongs-MacBook-Air.local",[[-1,666,"i"]],[667,667],[666,666]]],[1566089818295,["yonggu@yongs-MacBook-Air.local",[[1,666,"ed."]],[666,666],[669,669]]]],null,"yonggu@yongs-MacBook-Air.local"],["f7abbe78-103a-478a-83d7-d836e93eeb3d",1566089895157,"This is my notes for “Learning Ptyhon (5th)”.\n\n# Preliminaries\n\n```\n>>> S = 'spam'\n>>> dir() # no argument\n>>> dir(S)\n>>> help(S.replace) \n```\n\nFor lists, if `a[:], a[k]` appear in expresion, they are copied, e.g. after `b = a[:3]`, b refers to a new object. If `a[:],a[k]`appear on the left side of assignment, they referred to the original object, e.g. after `a=[0,1,2] a[:]=[0,1]`, a becomes `[0,1]`. \nWhen we say copy, we mean shallow copy.\n```\n>>> a = [0,[1,2],3]\n\n>>> b=a[1]\n\n>>> b[0] = 0\n\n>>> a\n\n[0, [0, 2], 3]\n```\n\nIn sum, after `exp1 = exp2`, exp1 points to the same place as exp2. Python always follows a reference to an object whenever the reference is used.\n# Types and Operations\nObjects are pieces of memory, with values and sets of associated operations. Everything we process in Python programs is a kind of obj \n\nThe Python Conceptual Hierarchy:\n1. Programs are composed of modules.\n2. Modules contain statements.\n3. Statements contain expressions.\n4. Expressions create and process objects.\n\n![Table 4-1]($resource/2018-09-03-12-05-36.png)\nIn formal terms, this means that Python is dynamically typed , a model that keeps track of types for you automatically instead of requiring declaration code, but it is also strongly typed, a constraint that means you can perform on an object only operations that are valid for its type.\n\n## Core Types\nImmutable: number, string, tuple, bytes \nMutable: list, dictionary, set, bytearray\n\nPrimitive: number  \nCollection:\n* Sequence: string, tuple, bytes, list,  bytearray\n* Mapping: dictionary, set\n\nbytearray  is a distinct hybrid of immutable bytes  strings (whose b'...'  syntax is required in 3.X and optional in 2.X) and mutable lists  (coded and displayed in [] ).\n\nGeneric operations that span multiple types show up as built-in functions or expressions (e.g. `len(X)` , `X[0]` ), but type-specific operations are method calls (e.g., `aString.upper()` ).\n\nBoth `dir`  and `help`  also accept as arguments either a real object  (like our string S) , or the name of a data type  (like str , list , and dict ).\n\nAs a notable difference, Python 2.X allows its normal and Unicode strings to be mixed in expressions as long as the normal string is all ASCII; in contrast, Python 3.X has a tighter model that never  allows its normal and byte strings to mix without explicit conversion.\n\nNone of the string object’s own methods support pattern-based text processing.\n\nUnlike out-of-bounds assignments in lists, which are forbidden, assignments to new dictionary keys create those keys, fetching a nonexistent key is still a mistake. (Use the get() method)\n\nA file’s contents are always a string in your script, regardless of the type of data the file contains:\n\n```python\n>>> for line in open('data.txt'): print(line)\n```\n\t\nText files represent content as normal str strings and perform unicode encoding and decoding automatically when writing and reading data, while  binary files represent content as a special bytes string and allow you to access file content unaltered.\n\nSets are unordered collections of unique and immutable objects.\nDecimal, Fraction, booleans\n\nAs you’ll learn, in Python, we code to object interfaces (operations supported), not to types.\n\n## Numbers\n![Table 5-1]($resource/2018-09-03-12-09-34.png)\n\nFloating-point numbers are implemented as C “doubles” in standard CPython, and therefore get as much precision as the C compiler used to build the Python interpreter gives to doubles.\n\nbuilt-in calls: `hex(I)`, `oct(I)`, `bin(I)`, `int(str,base)`, `X.bit_length()`, `round(X)`, `X.as_integer_ratio()`\n\nInternally, complex numbers are implemented as pairs of floating-point numbers\n\n![Table 5-2]($resource/2018-09-03-12-10-38.png)\n\nComparison operators may be chained: X < Y < Z  produces the same result as X < Y and Y < Z .\n```python\n>>> 1 == 2 < 3 # Same as: 1 == 2 and 2 < 3\nFalse    # Not same as: False < 3 (which means 0 < 3, which is true!)\n```\n\t\nIn recent Pythons, the slice expression X[I:J:K]  is equivalent to indexing with a slice object: X[slice(I, J, K)].\n\nIn Python 3.X, nonnumeric mixed-type magnitude comparisons are not allowed and raise exceptions; this includes sorts by proxy.\n\n* Operators lower in the table have higher precedence, and so bind more tightly in mixed expressions.\n* Operators in the same row in Table 5-2  generally group from left to right when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right).\n\nBesides mixing operators in expressions, you can also mix numeric types: in mixed-type numeric expressions, Python first converts operands up  to the type of the most complicated operand, and then performs the math on same-type operands. Python ranks the complexity of numeric types like so: integers are simpler than floating point numbers, which are simpler than complex numbers. \n\nIn general, Python does not convert across any other type boundaries automatically. Adding a string to an integer, for example, results in an error, unless you manually convert one or the other.\n\n In 3.X, the / now always performs  true division, returning a float result that includes any remainder, regardless of operand types. The // performs  floor division, which truncates the remainder and returns an integer for integer operands or a float if any operand is a float.\n\nThe // operator truncates the result down to its floor, which means the closest whole number below the true result.\n\nFrozenset\n\nInternally, the names True  and False  are instances of bool , which is in turn just a subclass (in the object oriented sense) of the built-in integer type int . True  and False  behave exactly like the integers 1 and 0, except that they have customized printing logic.\n```\n>>> True + 4 # (Hmmm)\n5\n```\n\t\nNumpy, Scipy\n\t\nThe dynamic typing\nA variable never has any type information or constraints associated with it. The notion of type lives with objects, not names. Variables are generic in nature; they always simply refer to a particular object at a particular point in time.\n\nVariables always link to objects and never to other variables, but larger objects may link to other objects (for instance, a list object has links to the objects it contains).\nThese links from variables to objects are called references  in Python—that is, a reference is a kind of association, implemented as a pointer in memory\n\nTechnically speaking, objects have more structure than just enough space to represent their values. Each object also has two standard header fields: a type designator  used to mark the type of the object, and a reference counter  used to determine when it’s OK to reclaim the object.\n\nreference counter, cyclic reference\n\t`sys.getrefcount(X)`\n\nIf a[:], a[k] appears in expression, they are copied. e.g. after b=a[:3], b refers to a new object.\nIf a[:], a[k] appears in left side of assignment, they referred to the original object. e.g.  after a=[0,1,2]   a[:] = [0,1], a becomes [0,1]\n\n Because everything  seems to work by assignment and references in Python, a basic understanding of this model is useful in many different contexts. As you’ll see, it works the same in assignment statements, function arguments, for loop variables, module imports, class attributes, and more. The good news is that there is just one  assignment model in Python;\n\nweakref\n\n## String\n![]($resource/2018-09-03-12-13-34.png)\n\n![Table 7-1]($resource/2018-09-03-16-34-23.png)\nString literal forms:\n* Single quotes: 'spa\"m'\n* Double quotes: \"spa'm\"\n* Triple quotes: '''... spam ...''' , \"\"\"... spam ...\"\"\"\n* Escape sequences: \"s\\tp\\na\\0m\"\n* Raw strings: r\"C:\\new\\test.spm\"\n* Bytes literals in 3.X and 2.6+ (see Chapter 4 , Chapter 37 ): b'sp\\x01am'\n* Unicode literals in 2.X and 3.3+ (see Chapter 4 , Chapter 37 ): u'eggs\\u0020spam'\n\nIn fact, 3.X defines str strings formally as sequences of Unicode code\npoints, not bytes, to make this clear. There’s more on how strings are stored internally in Chapter 37 if you care to know.\n\n![Table 7-2]($resource/2018-09-03-12-14-52.png)\n\nSome escape sequences allow you to embed absolute binary values into the characters of a string.\n\nPython keeps both the string’s length and text in memory. In fact, no character terminates a string in Python\n\nNotice that Python displays nonprintable characters in hex, regardless of how they were specified.\n\nThat is, r\"...\\\" is not a valid string literal—a raw string cannot end in\nan odd number of backslashes. If you need to end a raw string with a\nsingle backslash, you can use two and slice off the second (r'1\\nb\\tc\\\\'[:-1]), tack one on manually (r'1\\nb\\tc' + '\\\\'), or skip the raw string syntax and just double up the backslashes in a normal string ('1\\\\nb\\\\tc\\\\').\n\n\n```\n>>> menu = \"\"\"spam # comments here added to string!\n... eggs # ditto\n... \"\"\"\n>>> menu\n'spam # comments here added to string!\\neggs # ditto\\n'\n>>> menu = (\n... \"spam\\n\" # comments here ignored\n... \"eggs\\n\" # but newlines not automatic\n... )\n>>> menu\n'spam\\neggs\\n'\n```\n\n\nbuilt-in tool: `ord()` `chr()`\n\nThe method call expression: object.method(arguments) is evaluated from left to right—Python will first fetch the method  of the object  and then\ncall it, passing in both object and the arguments\n\nstring formatting expressions and string formatting method calls\n Technically, the format  built-in runs the subject object’s `__format__`  method, which the str.format  method does internally for each formatted item.\nThe %  expressions tend to be a bit simpler and more concise; the format  method has a handful of advanced features that the %  expression does not, but even more involved formatting still seems to be essentially a draw in terms of complexity.\n```\n>>> from formats import commas, money\n```\nTypes Share Operation Sets by Categories:\n* numbers\n* sequences\n* mappings\n\n## Lists and Dictionaries\n\n![]($resource/2018-09-03-12-17-54.png)\n![Table 8-1]($resource/2018-09-03-16-35-48.png)\nSlice assignment, the last operation in the preceding example, replaces an entire section of a list in a single step. Because it can be a bit complex, it is perhaps best thought of as a combination of two steps:\n1. Deletion. The slice you specify to the left of the = is deleted.\n2. Insertion. The new items contained in the iterable object to the right of the = are inserted into the list on the left, at the place where the old slice was deleted.\nNote, L[2:5]=L[3:6], for instance, works fine because the value to be inserted is fetched before the deletion\nhappens on the left.\n```\n>>> L = [1]\n>>> L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front\n>>> L\n[2, 3, 4, 1]\n>>> L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end\n>>> L\n[2, 3, 4, 1, 5, 6, 7]\n>>> L.extend([8, 9, 10]) # Insert all at end, named method\n>>> L\n[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]\n```\n\t\nThe effect of `L.append(X)`  is similar to `L+[X]`, but while the former changes L  in place, the latter makes a new list.\n\nIn Python 3.X, this has changed: magnitude comparison of mixed types\nraises an exception instead of falling back on the fixed cross-type ordering.\n\nL.sort() vs. sorted\nbuilt-in tools: reversed\n\nLike lists, dictionaries store object references (not copies, unless you ask for them explicitly)\n\n![Table 8-2]($resource/2018-09-03-12-18-20.png)\n\nkeys  in 3.X returns an iterable  object, instead of a physical list\nUnlike lists, however, whenever you assign a new  dictionary key (one that hasn’t been assigned before) you create a new entry in the dictionary.\n\nIn 3.X the dictionary keys , values , and items  methods all return view objects , whereas in 2.X they return actual result lists. \nBesides being iterable, dictionary views also retain the original order of dictionary components, reflect future changes to the dictionary, and may support set operations. Unlike 2.X’s list results, though, dictionary views in 3.X are not carved in stone when created—they dynamically reflect future changes  made to the dictionary after the view object has been created:\n\n In set operations, views may be mixed with other views, sets, and dictionaries; dictionaries\nare treated the same as their keys  views in this context:\n```\n>>> D = {'a': 1, 'b': 2, 'c': 3}\n>>> D.keys() & D.keys() # Intersect keys views\n{'b', 'c', 'a'}\n>>> D.keys() & {'b'} # Intersect keys and set\n{'b'}\n>>> D.\n```\n\n```\n>>> Ks.sort()\nAttributeError: 'dict_keys' object has no attribute 'sort'\n```\nTo work around this, in 3.X you must either convert to a list manually or use the\nsorted call (introduced in Chapter 4 and covered in this chapter) on either a keys view\nor the dictionary itself:\n\nOrderedDict\n\n## Tuples, files and everything else\n![]($resource/2018-09-03-16-36-56.png)\n![Table 9-1]($resource/2018-09-03-12-18-57.png)\n\nAs you can see, named tuples are a tuple/class/dictionary hybrid\n (In short, named tuples build new classes that extend the tuple type, inserting a property  accessor method for each named field that maps the name to its position)\n \n![Table 9-2]($resource/2018-09-03-12-03-26.png)\n\nEmpty lines in the file come back as strings containing just a newline character, not as empty strings.\n```\n>>> myfile.readline() # Empty string: end-of-file\n''\n```\n\t\n* Text files  represent content as normal str  strings, perform Unicode encoding and decoding automatically, and perform end-of-line translation by default.\n* Binary files  represent content as a special bytes  string type and allow programs to access file content unaltered.\n\npickle, shelve, json, struct\n\n In fact, when nested objects are present, Python automatically\ntraverses data structures to apply comparisons from left to right, and as deeply as\nneeded.\n\n More specifically, Python compares types as follows:\n- Numbers  are compared by relative magnitude, after conversion to the common highest type if needed.\n- Strings  are compared lexicographically (by the character set code point values returned by `ord` ), and character by character until the end or first mismatch (\"abc\"< \"ac\" ).\n- Lists  and tuples  are compared by comparing each component from left to right, and recursively for nested structures, until the end or first mismatch ([2] > [1, 2] ).\n- Sets  are equal if both contain the same items (formally, if each is a subset of the other), and set relative magnitude comparisons apply subset and superset tests.\n- Dictionaries  compare as equal if their sorted (key, value)  lists are equal. Relative magnitude comparisons are not supported for dictionaries in Python 3.X, but they work in 2.X as though comparing sorted (key, value)  lists.\n- Nonnumeric mixed-type magnitude comparisons (e.g., 1 < 'spam' ) are errors in Python 3.X. They are allowed in Python 2.X, but use a fixed but arbitrary ordering rule based on type name string. By proxy, this also applies to sorts, which use comparisons internally: nonnumeric mixed-type collections cannot be sorted in 3.X.\n\nPython 3.X  disallows mixed-type magnitude testing, except numeric types.\n\nMore generally, the notions of true and false are intrinsic properties of every  object in Python—each object is either true or false, as follows:\n- Numbers are false if zero, and true otherwise.\n- Other objects are false if empty, and true otherwise.\n\n That is, *None*  is something, not nothing (despite its name!)—it is a real object and a real piece of memory that is created and given a built-in name by Python itself.\n\n In fact, even types themselves are an object type in Python.\n Calls to these names are really object constructor calls, not simply conversion functions, though you can treat them as simple functions for basic usage.\n\nFor classic classes in Python 2.X, all class instances are instead of the type “instance,” and we must compare instance `__class__` attributes to compare their types meaningfully.\n\nRepetition Adds One Level Deep\n```python\n>>> L = [4, 5, 6]\n>>> X = L * 4 # Like [4, 5, 6] + [4, 5, 6] + ...\n>>> Y = [L] * 4 # [L] + [L] + ... = [L, L,...]\n```\n\t\nIf you remember that repetition, concatenation, and slicing copy only the top level of their operand objects, these sorts of cases make much more sense\n\nBeware of Cyclic  Data Structure\n```python\n>>> L = ['grail'] # Append reference to same object\n>>> L.append(L) # Generates cycle in object: [...]\n>>> L\n['grail', [...]]\n```\n\n# Statements and Syntax\n## Assignments, Expressions, and Prints\n- Assignments create object references. (i.e. link a name with an object) They always create references to objects instead of copying the objects.\n- Names are created when first assigned.\n- Names must be assigned before referenced.\n\nModule imports, function and class definitions, for  loop variables, and function arguments are all implicit assignments.\n\n![Table 11-1]($resource/2018-09-03-13-40-51.png)\n\nsequence assignment—any sequence of names can be\nassigned to any sequence of values, and Python assigns the items one at a time by position. In fact, the original tuple and list assignment forms in Python have been generalized to accept any type of sequence (really, iterable) on the right as long as it is of the same length as the sequence on the left.\n\nMultiple-target assignment: Python assigns a reference to the same object (the object farthest to the right) to all the targets on the left.\n\nIn tuple/list assignment, Python creates a temporary tuple that saves the original values of the variables on the right before assigning.\n\nwe can even assign nested sequences, and Python unpacks their parts according to their shape, as expected. The sequence-nesting shape of the object on the left must match that of the object on the right.\n> This nested tuple (really, sequence) unpacking\nassignment form works for function argument lists in Python 2.X (though not in 3.X)\n\nIn short, a single starred name, *X, can be used in the assignment target in order to specify a more general matching against the sequence—the starred name is assigned a list, which collects all items in the sequence not assigned to other names. In fact, the starred name can appear anywhere in the target.\n> This is similar in spirit to slicing, but not exactly the same—a sequence unpacking assignment always returns a list for multiple matched items, whereas slicing returns a sequence of the same type as the object sliced\n```\n>>> a, *b = 'spam'\n>>> a, b\n('s', ['p', 'a', 'm'])\n>>> S[0], S[1:] # Slices are type-specific, * assignment always returns a list\n('s', 'pam')\n```\n\nFinally, errors can still be triggered if there is more than one starred name, if there are too few values and no star (as before), and if the starred name is not itself coded inside a sequence:\n```\n>>> *a = seq\nSyntaxError: starred assignment target must be in a list or tuple\n```\n\nFor augmented assignments, inplace operations may be applied for mutable objects as an optimization.\n```\n>>> L = [1, 2]\n>>> L = L + [3] # Concatenate: slower\n>>> L\n[1, 2, 3]\n>>> L.append(4) # Faster, but in place\n>>> L\n[1, 2, 3, 4]\n>>> L += [9, 10] # Mapped to L.extend([9, 10])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\nNote however, that because of this equivalence += for a list is not exactly the same as a + and = in all cases—for lists += allows arbitrary sequences (just like extend), but concatenation normally does not:\n```\n>>> L = []\n>>> L += 'spam' # += and extend allow any sequence, but + does not!\n>>> L\n['s', 'p', 'a', 'm']\n>>> L = L + 'spam'\nTypeError: can only concatenate list (not \"str\") to list\n```\n> Although Python now supports statements like X += Y, it still does not\nhave C’s auto-increment/decrement operators (e.g., X++, −−X).\n\n### Naming\nFor portability, case also matters in the names of imported module files, even on platforms where the filesystems are case-insensitive.\n\nTrue, False, and None, are somewhat unusual in meaning—they also appear in the built-in scope of Python described in Chapter 17, and they are technically names assigned to objects.\n\nNames that begin with a single underscore (_X) are not imported by a from module import * statement\n\nNames that begin with two underscores and do not end with two more (__X) are localized (“mangled”) to enclosing classes.\n\n### Expression Statements\nIn Python, you can use an expression as a statement, too. Expressions are commonly used as statements in two situations:\n- For calls to functions and methods\n- For printing values at the interactive prompt\n\nA statement that is not an expression must generally appear on a line all by itself, not nested in a larger syntactic structure. For example, Python doesn’t allow you to embed assignment statements (=) in other expressions. Besides, C assignments return the value assigned, but Python assignments are just statements, not expressions.\n\nExpression statements are often used to run list methods that change a list in place:\n```\n>>> L = L.append(4) # But append returns None, not L\n>>> print(L) # So we lose our list!\nNone\n```\n\nNormally, whether printed output is buffered in memory or not is determined by file; passing a true value to flush forcibly flushes the stream.\n\nBecause the print statement just sends text to the sys.stdout.write method, you can capture printed text in your programs by assigning sys.stdout to an object whose write method processes the text in arbitrary ways\n\n## if Tests and Syntax Rules\nThere is no switch or case statement in Python\n\n* Block and statement boundaries are detected automatically.\n* Compound statements = header + “:” + indented statements. \n* Blank lines, spaces, and comments are usually ignored.\n* Docstrings are ignored but are saved and displayed by tools.\n\nStatements may span multiple lines if you’re continuing an open syntactic\npair.\n\nBoolean operators stop evaluating (“short circuit”) as soon as a result is known. Boolean **and** and **or** operators return a true or false object in Python, not the values True or False\n\nFor `A = Y if X else Z`, Python runs expression Y only if X turns out to be true, and runs expression Z only if X turns out to be false.\n\nWhen defining classes, we can specify their Boolean nature with either the\n__bool__ or __len__ methods.\n\n\n\n##  while and for Loops\nThe optional **else** block run if didn't exit loop with **break**\n\nPython doesn’t have what some languages call a “do until” loop statement. Python has no \"go to\" statement.\n\nPython 3.X (but not 2.X) allows ellipses coded as ... (literally, three consecutive dots) to appear any place an expression can. Because ellipses do nothing by themselves, this can serve as an alternative to the pass statement,\n```\n>>> X = ... # Alternative to None\n>>> X\nEllipsis\n```\n\nAfter the **for** loop, this loop variable normally still refers to the last item visited, which is the last item in the sequence unless the loop exits with a break statement.\n\nEven nested structures may be automatically unpacked this way in a for:\n```\n>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)\n```\n\nIn fact, as a general rule, you should resist the temptation to count things in Python—its iteration tools automate much of the work you do to loop over collections in lower-level languages like C.\n\nbuilt-in tools: range, zip, enumerate\n\nThe zip function is more general than this example suggests. For instance,\nit accepts any type of sequence (really, any iterable object, including files), and it accepts more than two arguments. Moreover, zip truncates result tuples at the length of the shortest sequence when the argument lengths differ.\n\n## Iterations and Comprehensions\n* Iterator vs. Iterable  vs. Iteration tool/context\n* Single scan vs. multiple scan\n\nIn some cases these two objects are the same when only a single scan is supported (e.g., files), and the iterator object is often temporary, used internally by the iteration tool. Moreover, some objects are both an iteration context tool (they iterate) and an iterable object (their results are iterable)—including Chapter 20’s generator expressions, and map and zip in Python 3.X.\n\nWhen the for loop begins, it first obtains an iterator from the iterable object by passing it to the iter built-in function; the object returned by iter in turn has the required next method. The iter function internally runs the __iter__ method, much like `next` and `__next__`.\n\nFor comprehensions, their full syntax allows for any number of **for** clauses, each of which can have an optional associated **if** clause.\n\nKeep in mind, though, that every built-in tool that scans from left to right across objects uses the iteration protocol.\n\nNotice that, unlike map and others, sorted returns an actual list in Python 3.X\ninstead of an iterable.\n\nOne of the fundamental distinctions of Python 3.X is its stronger emphasis on iterators than 2.X. This, along with its Unicode model and mandated new-style classes, is one of 3.X’s most sweeping changes.\n\nUnlike **range**, **map**, **zip**, **filter** are their own iterators—after you step through their results once, they are exhausted.\n\nIn Python 3.X the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time.\n\n## Documentation Interlude\nThe PyDoc system covered here can render a module’s internal documentation as either plain text in a shell, or HTML in a web browser.\n\nThe **help** function: press the space bar to move to the next page, Enter to go to the next line, and Q to quit:\n\nSphinx\n\n# Functions and Generators\n## Function Basics\n* *def* is executable code. it’s legal (and even occasionally useful) to nest def statements inside if statements, while loops, and even other *def*s.\n* *def* creates an object and assigns it to a name. Function objects may also have arbitrary user-defined *attributes* attached to them to record data.\n\nNames are always looked up in *scopes*—places where variables are stored— and assignments bind names to scopes.\n\n>Files must generally be rewound (e.g., with a file.seek(0) or another\nopen) after they have been read to end-of-file once, and so are single-pass iterators\n\n## Scopes\nWhen we talk about the search for a name’s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name’s assignment in your source\ncode determines the scope of the name’s visibility to your code.\n\nBy default, all names assigned inside a function are associated with that function’s namespace, and no other.\n\nLexical scoping:\n- If a variable is assigned inside a def, it is local to that function.\n- If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n- If a variable is assigned outside all defs, it is global to the entire file.\n\nEach module is a global scope, the global scope spans a single file only.\n* Assigned names are local unless declared global or nonlocal\n* All other names are enclosing function locals, globals, or built-ins.\n* Each call to a function creates a new local scope.\n\n> Note `L=X` within a function will classify L as a local, but L.append(X) will not.\n\n### Name Resolution: The LEGB Rule\n- Name assignments create or change local names by default.\n- Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in.\n- Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively.\n\nNote that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup level.\n\nAlso keep in mind that these rules apply only to simple variable names (e.g., spam). Qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here.\n\nThere are technically three more scopes in Python—temporary loop variables in some comprehensions, exception reference variables in some try handlers, and local scopes in class statements\n\nIn 3.X, the loop variables are local to the expression itself in all comprehension forms: generator, list, set, and dictionary. In 2.X, they are local to generator expressions and set and dictionary compressions, but not to list comprehensions that map their names to the scope outside the expression. By contrast, for loop statements never localize their variables to the statement block in any Python.\n\nIn 3.X, exception reference variables are local to that except block, and in fact are removed when the block is exited (even if you’ve used it earlier in your code!).\n\nAlthough the LEGB rule is used to resolve\nnames used in both the top level of a class itself as well as the top level of method functions nested within it, classes themselves are skipped by scope lookups—their names must be fetched as object attributes.\n\n### The global/nonlocal Statement\nThe global statement consists of the keyword global, followed by one or more names separated by commas. All the listed names will be mapped to the enclosing module’s scope when assigned or referenced within the function body. \n```\nglobal x\n```\n\nThe name x do not need even exist in the enclosing module\nbefore the function runs; in this case, the first assignment in the function creates x in the module.\n\nIf, on the other hand, X is declared nonlocal within the function in 3.X (only), the assignment changes the name X in the closest enclosing function’s local scope. The name X must have been defined in at least one enclosing function.\n\n```\ndef f1():\nx = 88\ndef f2(x=x): # Remember enclosing scope X with defaults\nprint(x)\nf2()\nf1() # Prints 88\n```\nBecause the second x is evaluated before Python steps into the nested def, it still refers to the x in f1.\n```\ndef func():\nx = 4\naction = (lambda n, x=x: x ** n) # Pass x in manually\nreturn action\n```\nLoop variables may require defaults, not scopes, Compare\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Tries to remember each i\nacts.append(lambda x: i ** x) # But all remember same last i!\nreturn acts\n```\nwith\n```\n>>> def makeActions():\nacts = []\nfor i in range(5): # Use defaults instead\nacts.append(lambda x, i=i: i ** x) # Remember current i\nreturn acts\n```\nBecause defaults are implemented as single objects attached to functions, mutable defaults retain state from call to call, rather than being initialized anew on each call.\n\nUnlike global, nonlocal names must already exist in the enclosing function’s scope when declared. In fact, they are checked at function definition time before either an enclosing or nested function is called.\n\nNonlocal both allows assignment to names in enclosing function scopes and limits scope lookups for such names to enclosing defs.\n\nPython uses naming conventions in both 2.X and 3.X that ensure that the arbitrary names you assign as function attributes won’t clash with names related to internal implementation.\n\nTo summarize: globals, nonlocals, classes, and function attributes all offer changeable state-retention options.\n\n## Arguments\nIn Python 2.X, it’s also possible to automatically unpack tuples in arguments passed to a function.\n```\ndef f((a,(b,c)))\n```\nThis def syntax is no longer supported in Python 3.X. Instead, code this function as:\n```\ndef f(T): (a, (b, c)) = T\n```\nTuple unpacking argument syntax is also disallowed by 3.X in lambda\nfunction argument lists. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.X for loops targets\n\nBy default, arguments are matched by position, from left to right, and you must pass exactly as many arguments as there are argument names in the function header.\n\n![Table 18-1]($resource/2018-09-04-20-04-02.png)\n\nIn a function call, arguments must appear in this order: any positional arguments or the  *iterable form, followed by any keyword arguments or the **dict form. If we see *iterable and **dict as being unpacked to positional arguments and keyword arguments, the order becomes: any positional arguments, followed by any keyword arguments. In a broad sense, there are only two arguments: positional and keyword.\n```\ndef foo(a,b,c,d,e,f,g):\n  print('ok')\nb=[2]\nx = {'d':4,'e':5}\ny = {'f':6}\nfoo(1,*b,3,**x,g=7,**y)  //ok\n```\n> In a function header, we use the term \"parameter\" instead of \"argument\"\n\nIn a function header, parameters must appear in this order: any normal parameter(name); followed by any default parameters (name=value); followed by the *name (or \\* in 3.X) form; followed by any name or name=value keyword-only arguments (in 3.X); followed by the **name form\n\nWe can use a * character by itself in the arguments list to indicate that a function does not accept a variable-length argument list but still expects all arguments following the * to be passed as keywords.\n\nThe *name=value* form has two meaning:\n- before the form *name, it's positional with default value\n- after the form *name, it's keyword-only with default value\n\nThere can be at most one *name parameter, which collects all remaining positional arguments (including those in *iterabe). Similarly, There can be at most one *\\*dict parameter, which collects all remaining keyword arguments (including those in *\\*dict arguments).\n\n```\ndef foo(a,b=3,*c,d,**e):\n    print(b,e)\nx = [3,4]\ny = {'d':5,'e':6,'f':7}\nfoo(1,2,*x,**y)   # 2 {'e': 6, 'f': 7}\n```\nThe steps that Python internally carries out to match arguments before\nassignment can roughly be described as follows:\n1. Assign nonkeyword arguments by position.\n2. Assign keyword arguments by matching names.\n3. Assign extra nonkeyword arguments to *name tuple.\n4. Assign extra keyword arguments to **name dictionary.\n5. Assign default values to unassigned arguments in header.\n\n> Note that in both function call and header, the *name = value* form are not assignments.\n\nThe default parameters are attached to function objects, if you code\na default to be a mutable object (e.g., def f(a=[])), the same, single\nmutable object is reused every time the function is later called—even if\nit is changed in place within the function.\n\nBelow is a tracer function example:\n```\ndef tracer(func, *pargs, **kargs): # Accept arbitrary arguments\n  print('calling:', func.__name__)\n  return func(*pargs, **kargs) # Pass along arbitrary arguments\n```\n\n## Advanced Function Topics\nIn fact, recursion is not used nearly as often in Python as in\nmore esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural.\n\nOn the other hand, recursion—or equivalent explicit stack-based algorithms we’ll meet shortly—can be required to traverse arbitrarily shaped structures.\n\nAlso note that standard Python limits the depth of its runtime call stack—crucial to recursive call programs—to trap infinite recursion errors. To expand it, use the **sys** module:\n```\n>>> sys.getrecursionlimit() # 1000 calls deep default\n1000\n>>> sys.setrecursionlimit(10000) # Allow deeper nesting\n>>> help(sys.setrecursionlimit) # Read more about it\n```\n\n### Function attributes and annotations\n```\n>>> func.__code__\n>>> func.__code__.co_varnames\n```\nPython’s own implementation-related data stored on functions follows naming conventions that prevent them from clashing with the more arbitrary attribute names you might assign yourself. In 3.X, all function internals’ names have leading and trailing double underscores (“_\\_X__”);\n\nAttributes are related to objects instead of scopes (and must be referenced through the function name within its code).\n\nPython provides special syntax for specifying annotations, but it doesn’t do anything with them itself; annotations are completely optional, and when present are simply attached to the function object’s __annotations__ attribute for use by other tools. Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values.\n```\n>>> def func(a: 'spam', b: (1, 10), c: float) -> int:\nreturn a + b + c\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'c': <class 'float'="">, 'b': (1, 10), 'a': 'spam', 'return': <class 'int'="">}\n```\n\nFinally, note that annotations work only in def statements, not lambda expressions.\n\n- **lambda** is an expression, not a statement.\n- lambda’s body is a single expression, not a block of statements.\n- Defaults work on lambda arguments, just like in a def.\n- The code in a lambda body also follows the same scope lookup rules as code inside a def. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule)\n\n```\n>>> ((lambda x: (lambda y: x + y))(99))(4)\n103\n```\n\nuseful library: functools, operator\n\n## Comprehensions and Generations\nmap calls can be twice as fast as equivalent for loops, and list comprehensions are often faster than map calls.\n\nGenerator function vs. Generator vs. Generator expression\n- *send* advances to the next item  \n- *yield* is now an expression form, it must be enclose in parentheses unless it's the only item on the right ride of the assignment statement.\n- methods: *throw*, *close*\n- *yield from*\n\nGenerator expressions may also run slightly slower than list comprehensions in practice, so they are probably best used only for very large result sets, or applications that cannot wait for full results generation.\n\nA subtle but important point: both generator functions and generator expressions are their own iterators and thus support just one active iteration.\n\nPython 3.X localizes loop variables in all four forms—temporary loop variable names in generator, set, dictionary, and list comprehensions are local to the expression.\n\nIn general, list comprehensions are usually the quickest of the bunch; map beats list comprehensions in Python only when all tools must call functions; for loops tend to be slower than comprehensions; and generator functions and expressions are slower than comprehensions by a constant factor. Under\n\n## The benchmarking Interlude\nTimeing modules: time, timer, profile, timeit, pystone.py\n\n#  Part V. Modules and Packages\nModules are processed with two statements and one important function:\n- import: Lets a client (importer) fetch a module as a whole\n- from: Allows clients to fetch particular names from a module\n- imp.reload (reload in 2.X): Provides a way to reload a module’s code without stopping Python\n\nIn Python, cross-file module linking is not resolved until such import statements are executed at runtime; their net effect is to assign module names—simple variables like b—to loaded module objects. In fact, the module name used in an import statement serves two purposes: it identifies the external file to be loaded, but it also becomes a variable assigned to the loaded module.\n\nSimilarly, objects defined by a module are also created at runtime, as the import is executing: import literally runs statements in the target file one at a time to create its contents.\n\nIn python, imports perform three distinct steps the first time a program imports a given file:\n1. Find the module’s file.\n2. Compile it to byte code (if needed).\n3. Run the module’s code to build the objects it defines.\n\nBear in mind that all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named **sys.mod** ules and checking there at the start of an import operation. If the module is not present, a three-step process begins. (see **imp.reload**)\n> Python keeps already imported modules in the built-in **sys.modules** dictionary so it can keep track of what’s been loaded.\n\nNotice that compilation happens when a file is being imported. Because of this, you will not usually see a .pyc byte code file for the top-level file of your program, unless it is also imported elsewhere—only imported files leave behind .pyc files on your machine.\n\n### The Module Search Path\nRoughly, Python’s module search path is composed of the concatenation of these major components, some of which are preset for you and some of which you can tailor to tell Python where to look:\n1. The home directory of the program (subdirectories not included)\n2. PYTHONPATH directories (if set)\n3. Standard library directories\n4. The contents of any .pth files (if present)\n5. The site-packages home of third-party extensions\n\nUltimately, the concatenation of these four components becomes **sys.path**, a mutable list of directory. The first and\nthird elements of the search path are defined automatically. Because Python searches the concatenation of these components from first to last, though, the second and fourth elements can be used to extend the path to include your own source code directories.\n\nBy modifying the sys.path list, you can modify the search path for all future imports made in a program’s run. Such changes last only for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path—the first per user, and the second per installation.\n\nPython automatically selects any type that matches a module’s name. For same names with different extensions, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations. \n\nBy using import hooks, archived files are automatically extracted at import time when a  .zip file is selected from the module import search path.\n\nFor details, see the builtin **importlib._\\_import__** function\n\nThird-party extensions for Python typically use the **distutils** tools in the standard library to automatically install themselves, so no path configuration is required to use their code.\n\nSystems that use distutils generally come with a setup.py script, which is run to install them; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\site-packages subdirectory of the Python install tree, wherever that resides on the target machine).\n\n## Module Coding Basics\n### Module Filenames\nThe .py is technically optional for top-level files that will be run but not imported.\n\nIn fact, both the names of module files and the names of directories used in\npackage imports (discussed in the next chapter) must conform to the rules for variable names presented.\n\n**import** fetches the module as a whole, so you\nmust qualify to fetch its names; in contrast, **from** fetches (or copies) specific names out of the module.\n\nIn Python 3.X, the from ...* statement form described here can be used\nonly at the top level of a module file, not within a function.\n\nJust like def, import and from are executable statements, not compile-time declarations. They may be nested in if tests, to select among options; appear in function defs, to be loaded only on calls (subject to the preceding note); be used in try statements, to provide defaults; and so on.\n```\n>>> from small import x, y # Copy two names out\n>>> x = 42 # Changes local x only\n>>> y[0] = 42 # Changes shared mutable in place\n```\n\nAt least conceptually, a from statement like this one:\n```\nfrom module import name1, name2 # Copy these two names out (only)\n```\nis equivalent to this statement sequence:\n\n```\nimport module # Fetch the module object\nname1 = module.name1 # Copy names out by assignment\nname2 = module.name2\ndel module # Get rid of the module name\n```\n\nThe **from** always imports the entire module into memory if it has not yet been imported, regardless of how many names it copies out of the file. There is no way to load just part of a module file.\n\nMoreover, the from module import * form really can corrupt namespaces and make names difficult to understand, especially when applied to more than one file.\n\nProbably the best real-world advice here is to generally prefer import to from for simple modules, to explicitly list the variables you want in most from statements, and to limit the from * form to just one import per file.\n\nThe **as** extension works in both import and from as a simple renaming tool.\n\nIn fact, internally, module namespaces are stored as dictionary objects.\n\nThe LEGB scope rule applies only to bare, unqualified names—it may be used for the leftmost name in a name path, but later names after dots search specific objects instead.\n\nlexical scoping notion—in Python, the scopes surrounding\na piece of code are completely determined by the code’s physical position in your file. Scopes are never influenced by function calls or module imports.\n\nimport operations never give upward visibility to code in imported files\n—an imported file cannot see names in the importing file. In some sense, although imports do not nest namespaces upward, they do nest downward.\n```\nprint(mod2.mod3.X) # Nested mod3's X\n```\n\n### Reloading Modules\nThe **reload** function forces an already loaded module’s code to be reloaded and rerun. Assignments in the file’s new code change the existing module object in place.\n\n> Note that reload currently only works on modules\nwritten in Python;\n\nBecause reload expects an object, a module must have been previously imported successfully before you can reload it.\n\nWhen you call reload, Python rereads the module file’s source code and reruns its toplevel statements. Perhaps the most important thing to know about reload is that it changes a module object in place; it does not delete and re-create the module object.\n- Reloads impact all clients that use **import** to fetch modules\n- Reloads impact future from clients only. Clients that used from to fetch attributes in the past won’t be affected by a reload; they’ll still have references to the old objects fetched before the reload.\n- Reloads apply to a single module only. You must run them on each module you wish to update, unless you use code or tools that apply reloads transitively.\n\n## Module Packages\nDotted package  \n**from package import item**: the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable.\n**import item.subitem.subitem**: each item except for the last must be a package; the last item can be a module or a package but can't be a class or function or variable defined in the previous item.\n\nTow kinds of imports:\n- absolute imports\n- relative imports\n\nIn sum, Python imports select between relative (in the containing directory) and absolute (in a directory on sys.path) resolutions as follows:\n- Dotted imports: from . import m  \nAre relative-only in both 2.X and 3.X\n- Nondotted imports: import m, from m import x  \nAre relative-then-absolute in 2.X, and absolute-only in 3.X\n\nNote that relative imports are based on the name of the current module. Since the name of the main module is always \"__main__\", modules intended for use as the main module of a Python application must always use absolute imports.\n\nPython 3.3 adds another flavor to modules: *namespace packages*.\n\nPackages are just a special kind of module. Specifically, any module that contains a `__path__` attribute is considered a package.\n\nTwo kinds of packages:\n* regular packages\n* namespace packages",[[1566089846661,["yonggu@yongs-MacBook-Air.local",[[1,670,"\n"]],[669,669],[670,670]]],[1566089849019,["yonggu@yongs-MacBook-Air.local",[[1,670,"jdkskjl"]],[670,670],[677,677]]],[1566089850622,["yonggu@yongs-MacBook-Air.local",[[-1,670,"jdkskjl"]],[677,677],[670,670]]]],null,"yonggu@yongs-MacBook-Air.local"]]}</class></class></class></class></class></class></class></class>