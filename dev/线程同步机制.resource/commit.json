{"compress":true,"commitItems":[["fa788285-2556-458d-9373-c9e449f25132",1565784609876,"---\ntitle: 线程同步机制\n---\n## 线程基础知识\n\n线程同步的底层支持包括： \n1. TSL （或其它）原子操作 \n2. 中断服务\n## 互斥锁Mutex\n\n最基本的同步机制是锁（Lock），包括 互斥锁(Mutex), Read-Write 锁, 空转锁。以Mutex为例：\n* 对Mutex状态的判断及修改是通过机器提供的原子性指令完成的。\n* 每个Mutex上有一个等待队列（waiting list)\n* Lock()操作在”locked” 情况下会被挂起，实际上是先空转（spin）一小会再挡土挂起（yield），当前线程会加入到Mutex的waiting list中。\n* 挂起是指将线程置于”睡眠“状态，并调用线程调试函数切换到其它线程\n* Unlock() 操作会释放锁, 并且唤醒waiting list中的一个（或所有）线程。\n## Condition Variables\n\npthread_join()解决的是多个线程等待同一个线程的结束。Condition variable解决的是多个线程等待某个条件发生。\n\n* Condition主要用来实现通知/同步机制，内部也是由waiting list实现。实际上Mutex也有”通知唤醒“功能，但Mutex功能过于简单，用来实现通知/同步功能时容易出问题：每个线程需要不断的试图获取Mutex锁并检查条件是否发生，从而浪费大量资源。（python的condition内部就是用多个waiter lock实现的。）\n* Condition 一定要配合 Mutex 才能使用，因为状态的检测/改变与等待/发信操作需要具有原子性。\n* wait() 会自动释放Mutex, 等到被唤醒时会自动去获取Mutex\n* notify() 会唤唤醒waiting list中的线程\n* 检测条件状态要用while, 发信号要在临界区\n## Semaphore 信号量\n\nsemaphore是进程间PV，可以理解为带计数器的Condition variable\n\n## Python中的Event, Queue\n\n## References\n[操作系统如何实现mutex](http://blog.csdn.net/goondrift/article/details/19044361)\n[pthread的各种同步机制](https://casatwy.com/pthreadde-ge-chong-tong-bu-ji-zhi.html)\n[When is a condition variable needed, isn't a mutex enough?](https://stackoverflow.com/questions/12551341/when-is-a-condition-variable-needed-isnt-a-mutex-enough)\n[Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues](http://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/)\n[关于Condition Variable为什么需要一个Mutex的思考](http://www.cnblogs.com/Dahaka/archive/2012/02/19/2358528.html)\n[Linux并发与同步](https://www.cnblogs.com/vamei/archive/2012/10/09/2715393.html)",[[1565784545957,["yonggu@yongs-MacBook-Air.local",[[1,84,"``"]],[84,84],[85,85]]],[1565784547528,["yonggu@yongs-MacBook-Air.local",[[-1,84,"``"]],[85,85],[84,84]]]],null,"yonggu@yongs-MacBook-Air.local"]]}